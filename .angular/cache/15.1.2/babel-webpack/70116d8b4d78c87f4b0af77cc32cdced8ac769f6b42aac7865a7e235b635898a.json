{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, NgModule, HostBinding, Injectable, Component, EventEmitter, Output, ContentChildren, HostListener, Inject, ViewChild, forwardRef, Optional, ElementRef, ContentChild, PLATFORM_ID, TemplateRef, ViewContainerRef, Pipe, ChangeDetectionStrategy, VERSION } from '@angular/core';\nimport * as i1$1 from '@angular/common';\nimport { CommonModule, DOCUMENT, isPlatformBrowser } from '@angular/common';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/animations';\nimport { animation, animate, style, useAnimation, trigger, state, transition, group, query } from '@angular/animations';\nimport * as i3 from '@angular/router';\nimport { NavigationEnd, RouterModule } from '@angular/router';\nimport { BehaviorSubject, Observable, fromEvent, zipWith, withLatestFrom, Subject } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { createPopper } from '@popperjs/core';\nimport * as i1$2 from '@angular/cdk/layout';\nimport * as i3$1 from '@angular/cdk/a11y';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { __classPrivateFieldSet, __classPrivateFieldGet } from 'tslib';\nimport * as i5 from '@coreui/icons-angular';\nimport { IconModule } from '@coreui/icons-angular';\nconst _c0 = [\"*\"];\nfunction AccordionItemComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AccordionItemComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AccordionItemComponent_ng_template_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AccordionItemComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function AccordionItemComponent_ng_template_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.toggleItem());\n    });\n    i0.ɵɵtemplate(1, AccordionItemComponent_ng_template_5_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    const _r4 = i0.ɵɵreference(8);\n    i0.ɵɵproperty(\"collapsed\", !ctx_r3.visible);\n    i0.ɵɵattribute(\"aria-controls\", ctx_r3.contentId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.templates[\"accordionHeader\"] || _r4)(\"ngTemplateOutletContext\", ctx_r3.itemContext);\n  }\n}\nfunction AccordionItemComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction AccordionItemComponent_ng_template_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AccordionItemComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtemplate(1, AccordionItemComponent_ng_template_9_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    const _r8 = i0.ɵɵreference(12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r7.templates[\"accordionBody\"] || _r8)(\"ngTemplateOutletContext\", ctx_r7.itemContext);\n  }\n}\nfunction AccordionItemComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\nconst _c1 = [\"*\", \"*\"];\nfunction AlertComponent_ng_container_0_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AlertComponent_ng_container_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, AlertComponent_ng_container_0_ng_template_1_ng_container_0_Template, 1, 0, \"ng-container\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    const _r1 = i0.ɵɵreference(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r3.templates == null ? null : ctx_r3.templates.alertButtonCloseTemplate) || _r1);\n  }\n}\nfunction AlertComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, AlertComponent_ng_container_0_ng_template_1_Template, 1, 1, \"ng-template\", 2);\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.dismissible);\n  }\n}\nfunction AlertComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 4);\n    i0.ɵɵlistener(\"click\", function AlertComponent_ng_template_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.visible = false);\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction AvatarComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction AvatarComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.statusClass);\n  }\n}\nfunction AvatarComponent_ng_template_3_img_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 6);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"src\", ctx_r4.src, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction AvatarComponent_ng_template_3_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction AvatarComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, AvatarComponent_ng_template_3_img_0_Template, 1, 1, \"img\", 4);\n    i0.ɵɵtemplate(1, AvatarComponent_ng_template_3_ng_template_1_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n  }\n  if (rf & 2) {\n    const _r5 = i0.ɵɵreference(2);\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", !!ctx_r3.src)(\"ngIfElse\", _r5);\n  }\n}\nfunction BreadcrumbItemComponent_a_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nconst _c2 = function () {\n  return {};\n};\nfunction BreadcrumbItemComponent_a_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 3);\n    i0.ɵɵtemplate(1, BreadcrumbItemComponent_a_0_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(4);\n    let tmp_1_0;\n    let tmp_3_0;\n    let tmp_5_0;\n    let tmp_6_0;\n    let tmp_7_0;\n    let tmp_8_0;\n    let tmp_9_0;\n    i0.ɵɵproperty(\"routerLink\", ctx_r0.url)(\"cHtmlAttr\", (tmp_1_0 = ctx_r0.attributes) !== null && tmp_1_0 !== undefined ? tmp_1_0 : i0.ɵɵpureFunction0(11, _c2))(\"target\", ctx_r0.attributes == null ? null : ctx_r0.attributes[\"target\"])(\"queryParams\", (tmp_3_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.queryParams) !== null && tmp_3_0 !== undefined ? tmp_3_0 : null)(\"fragment\", ctx_r0.linkProps == null ? null : ctx_r0.linkProps.fragment)(\"queryParamsHandling\", (tmp_5_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.queryParamsHandling) !== null && tmp_5_0 !== undefined ? tmp_5_0 : null)(\"preserveFragment\", (tmp_6_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.preserveFragment) !== null && tmp_6_0 !== undefined ? tmp_6_0 : false)(\"skipLocationChange\", (tmp_7_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.skipLocationChange) !== null && tmp_7_0 !== undefined ? tmp_7_0 : false)(\"replaceUrl\", (tmp_8_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.replaceUrl) !== null && tmp_8_0 !== undefined ? tmp_8_0 : false)(\"state\", (tmp_9_0 = ctx_r0.linkProps == null ? null : ctx_r0.linkProps.state) !== null && tmp_9_0 !== undefined ? tmp_9_0 : i0.ɵɵpureFunction0(12, _c2));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\nfunction BreadcrumbItemComponent_ng_template_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction BreadcrumbItemComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtemplate(1, BreadcrumbItemComponent_ng_template_1_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(4);\n    let tmp_0_0;\n    i0.ɵɵproperty(\"cHtmlAttr\", (tmp_0_0 = ctx_r2.attributes) !== null && tmp_0_0 !== undefined ? tmp_0_0 : i0.ɵɵpureFunction0(2, _c2));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\nfunction BreadcrumbItemComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction BreadcrumbRouterComponent_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"c-breadcrumb-item\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    const last_r2 = ctx_r4.last;\n    const breadcrumb_r1 = ctx_r4.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"active\", last_r2)(\"url\", breadcrumb_r1 == null ? null : breadcrumb_r1.url)(\"attributes\", breadcrumb_r1 == null ? null : breadcrumb_r1.attributes)(\"linkProps\", breadcrumb_r1 == null ? null : breadcrumb_r1.linkProps);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", breadcrumb_r1 == null ? null : breadcrumb_r1.label, \" \");\n  }\n}\nfunction BreadcrumbRouterComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, BreadcrumbRouterComponent_ng_template_1_ng_container_0_Template, 3, 5, \"ng-container\", 2);\n  }\n  if (rf & 2) {\n    const breadcrumb_r1 = ctx.$implicit;\n    const last_r2 = ctx.last;\n    i0.ɵɵproperty(\"ngIf\", (breadcrumb_r1 == null ? null : breadcrumb_r1.label) && ((breadcrumb_r1 == null ? null : breadcrumb_r1.url == null ? null : breadcrumb_r1.url.slice(-1)) === \"/\" || last_r2));\n  }\n}\nconst _c3 = [\"content\"];\nfunction CarouselControlComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", null, 2);\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction CarouselControlComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\");\n    i0.ɵɵelementStart(1, \"span\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r2.carouselControlIconClass);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.direction)(\"aria-hidden\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r2.caption);\n  }\n}\nconst _c4 = function (a0) {\n  return {\n    active: a0\n  };\n};\nfunction CarouselIndicatorsComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function CarouselIndicatorsComponent_ng_container_1_Template_button_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const i_r2 = restoredCtx.index;\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.onClick(i_r2));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const i_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(i0.ɵɵpureFunction1(4, _c4, ctx_r0.active === i_r2));\n    i0.ɵɵattribute(\"data-coreui-target\", i_r2)(\"aria-current\", ctx_r0.active === i_r2);\n  }\n}\nfunction CarouselItemComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"active\"]);\n  }\n}\nfunction HeaderComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r0.headerClasses);\n  }\n}\nfunction HeaderComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\nfunction NavbarComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction NavbarComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.containerClass);\n  }\n}\nfunction NavbarComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\nconst _c5 = \"[_nghost-%COMP%]{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\";\nconst _c6 = [\"popoverTemplate\"];\nconst _c7 = function (a0) {\n  return {\n    \"popover-arrow\": a0\n  };\n};\nfunction SidebarBrandComponent_ng_template_0_img_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cHtmlAttr\", ctx_r2.brandFull)(\"ngClass\", \"sidebar-brand-full\");\n  }\n}\nfunction SidebarBrandComponent_ng_template_0_img_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cHtmlAttr\", ctx_r3.brandNarrow)(\"ngClass\", \"sidebar-brand-narrow\");\n  }\n}\nfunction SidebarBrandComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 1);\n    i0.ɵɵtemplate(1, SidebarBrandComponent_ng_template_0_img_1_Template, 1, 2, \"img\", 2);\n    i0.ɵɵtemplate(2, SidebarBrandComponent_ng_template_0_img_2_Template, 1, 2, \"img\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"routerLink\", ctx_r0.routerLink);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.brandFull);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.brandNarrow);\n  }\n}\nfunction SidebarBrandComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction SidebarNavLabelComponent_i_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"i\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.getLabelIconClass());\n  }\n}\nfunction SidebarNavLabelComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵpipe(1, \"cSidebarNavBadge\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 2, ctx_r1.item));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.item.badge.text);\n  }\n}\nfunction SidebarNavLinkContentComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0)(1);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementContainerEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    let tmp_0_0;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate((tmp_0_0 = ctx_r0.item == null ? null : ctx_r0.item.name) !== null && tmp_0_0 !== undefined ? tmp_0_0 : \"\");\n  }\n}\nfunction SidebarNavLinkComponent_a_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction SidebarNavLinkComponent_a_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavBadge\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 2, ctx_r6.item));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r6.item.badge == null ? null : ctx_r6.item.badge.text);\n  }\n}\nconst _c8 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nfunction SidebarNavLinkComponent_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 5);\n    i0.ɵɵpipe(1, \"cSidebarNavLink\");\n    i0.ɵɵtemplate(2, SidebarNavLinkComponent_a_1_ng_container_2_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelement(3, \"c-sidebar-nav-link-content\", 7);\n    i0.ɵɵtemplate(4, SidebarNavLinkComponent_a_1_span_4_Template, 3, 4, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(5);\n    let tmp_1_0;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 6, ctx_r0.item))(\"cHtmlAttr\", (tmp_1_0 = ctx_r0.item.attributes) !== null && tmp_1_0 !== undefined ? tmp_1_0 : i0.ɵɵpureFunction0(8, _c2));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(9, _c8, ctx_r0.item));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"item\", ctx_r0.item);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.item.badge);\n  }\n}\nfunction SidebarNavLinkComponent_a_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction SidebarNavLinkComponent_a_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavBadge\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 2, ctx_r8.item));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r8.item.badge == null ? null : ctx_r8.item.badge.text);\n  }\n}\nfunction SidebarNavLinkComponent_a_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function SidebarNavLinkComponent_a_2_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.linkClicked());\n    });\n    i0.ɵɵpipe(1, \"cSidebarNavLink\");\n    i0.ɵɵtemplate(2, SidebarNavLinkComponent_a_2_ng_container_2_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelement(3, \"c-sidebar-nav-link-content\", 7);\n    i0.ɵɵtemplate(4, SidebarNavLinkComponent_a_2_span_4_Template, 3, 4, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(5);\n    let tmp_2_0;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 7, ctx_r1.item))(\"href\", ctx_r1.href, i0.ɵɵsanitizeUrl)(\"cHtmlAttr\", (tmp_2_0 = ctx_r1.item.attributes) !== null && tmp_2_0 !== undefined ? tmp_2_0 : i0.ɵɵpureFunction0(9, _c2));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(10, _c8, ctx_r1.item));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"item\", ctx_r1.item);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.item.badge);\n  }\n}\nfunction SidebarNavLinkComponent_a_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction SidebarNavLinkComponent_a_3_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavBadge\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 2, ctx_r12.item));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r12.item.badge == null ? null : ctx_r12.item.badge.text);\n  }\n}\nconst _c9 = function () {\n  return {\n    exact: false\n  };\n};\nfunction SidebarNavLinkComponent_a_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 11);\n    i0.ɵɵlistener(\"click\", function SidebarNavLinkComponent_a_3_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.linkClicked());\n    });\n    i0.ɵɵpipe(1, \"cSidebarNavLink\");\n    i0.ɵɵtemplate(2, SidebarNavLinkComponent_a_3_ng_container_2_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelement(3, \"c-sidebar-nav-link-content\", 7);\n    i0.ɵɵtemplate(4, SidebarNavLinkComponent_a_3_span_4_Template, 3, 4, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(5);\n    let tmp_1_0;\n    let tmp_3_0;\n    let tmp_6_0;\n    let tmp_7_0;\n    let tmp_8_0;\n    let tmp_9_0;\n    let tmp_11_0;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 16, ctx_r2.item))(\"cHtmlAttr\", (tmp_1_0 = ctx_r2.item.attributes) !== null && tmp_1_0 !== undefined ? tmp_1_0 : i0.ɵɵpureFunction0(18, _c2))(\"target\", ctx_r2.item.attributes == null ? null : ctx_r2.item.attributes[\"target\"])(\"queryParams\", (tmp_3_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.queryParams) !== null && tmp_3_0 !== undefined ? tmp_3_0 : null)(\"fragment\", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.fragment)(\"queryParamsHandling\", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.queryParamsHandling)(\"preserveFragment\", (tmp_6_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.preserveFragment) !== null && tmp_6_0 !== undefined ? tmp_6_0 : false)(\"skipLocationChange\", (tmp_7_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.skipLocationChange) !== null && tmp_7_0 !== undefined ? tmp_7_0 : false)(\"replaceUrl\", (tmp_8_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.replaceUrl) !== null && tmp_8_0 !== undefined ? tmp_8_0 : false)(\"state\", (tmp_9_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.state) !== null && tmp_9_0 !== undefined ? tmp_9_0 : i0.ɵɵpureFunction0(19, _c2))(\"routerLink\", ctx_r2.item.url)(\"routerLinkActiveOptions\", (tmp_11_0 = ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.routerLinkActiveOptions) !== null && tmp_11_0 !== undefined ? tmp_11_0 : i0.ɵɵpureFunction0(20, _c9));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(21, _c8, ctx_r2.item));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"item\", ctx_r2.item);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.item.badge);\n  }\n}\nfunction SidebarNavLinkComponent_ng_template_4_i_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"i\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r15 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 1, item_r15));\n  }\n}\nfunction SidebarNavLinkComponent_ng_template_4_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"svg\", 13);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r15 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"cIcon\", item_r15.iconComponent == null ? null : item_r15.iconComponent.content)(\"name\", item_r15.iconComponent == null ? null : item_r15.iconComponent.name)(\"customClasses\", i0.ɵɵpipeBind1(1, 3, item_r15));\n  }\n}\nfunction SidebarNavLinkComponent_ng_template_4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r15 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 1, item_r15));\n  }\n}\nfunction SidebarNavLinkComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, SidebarNavLinkComponent_ng_template_4_i_0_Template, 2, 3, \"i\", 8);\n    i0.ɵɵtemplate(1, SidebarNavLinkComponent_ng_template_4_ng_template_1_Template, 2, 5, \"ng-template\", 12);\n    i0.ɵɵtemplate(2, SidebarNavLinkComponent_ng_template_4_span_2_Template, 2, 3, \"span\", 8);\n  }\n  if (rf & 2) {\n    const item_r15 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", item_r15 == null ? null : item_r15.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r15 == null ? null : item_r15.iconComponent);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(item_r15 == null ? null : item_r15.icon) && !(item_r15 == null ? null : item_r15.iconComponent));\n  }\n}\nconst _c10 = function () {\n  return {\n    exact: true\n  };\n};\nfunction SidebarNavComponent_ng_container_0_c_sidebar_nav_group_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"c-sidebar-nav-group\", 7, 8);\n    i0.ɵɵpipe(2, \"cSidebarNavItemClass\");\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"dropdownMode\", ctx_r2.dropdownMode)(\"item\", item_r1)(\"ngClass\", i0.ɵɵpipeBind1(2, 4, item_r1))(\"routerLinkActiveOptions\", i0.ɵɵpureFunction0(6, _c10));\n  }\n}\nfunction SidebarNavComponent_ng_container_0_c_sidebar_nav_divider_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"c-sidebar-nav-divider\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavItemClass\");\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    let tmp_0_0;\n    i0.ɵɵproperty(\"cHtmlAttr\", (tmp_0_0 = item_r1.attributes) !== null && tmp_0_0 !== undefined ? tmp_0_0 : i0.ɵɵpureFunction0(5, _c2))(\"item\", item_r1)(\"ngClass\", i0.ɵɵpipeBind1(1, 3, item_r1));\n  }\n}\nfunction SidebarNavComponent_ng_container_0_c_sidebar_nav_title_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"c-sidebar-nav-title\", 9);\n    i0.ɵɵpipe(1, \"cSidebarNavItemClass\");\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    let tmp_0_0;\n    i0.ɵɵproperty(\"cHtmlAttr\", (tmp_0_0 = item_r1.attributes) !== null && tmp_0_0 !== undefined ? tmp_0_0 : i0.ɵɵpureFunction0(5, _c2))(\"item\", item_r1)(\"ngClass\", i0.ɵɵpipeBind1(1, 3, item_r1));\n  }\n}\nfunction SidebarNavComponent_ng_container_0_c_sidebar_nav_label_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"c-sidebar-nav-label\", 10);\n    i0.ɵɵpipe(1, \"cSidebarNavItemClass\");\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"item\", item_r1)(\"ngClass\", i0.ɵɵpipeBind1(1, 2, item_r1));\n  }\n}\nfunction SidebarNavComponent_ng_container_0_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"c-sidebar-nav-link\", 11);\n    i0.ɵɵlistener(\"linkClick\", function SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template_c_sidebar_nav_link_linkClick_0_listener() {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r13.hideMobile());\n    });\n    i0.ɵɵpipe(1, \"cSidebarNavItemClass\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"item\", item_r1)(\"ngClass\", i0.ɵɵpipeBind1(1, 2, item_r1));\n  }\n}\nfunction SidebarNavComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0)(1, 1);\n    i0.ɵɵtemplate(2, SidebarNavComponent_ng_container_0_c_sidebar_nav_group_2_Template, 3, 7, \"c-sidebar-nav-group\", 2);\n    i0.ɵɵtemplate(3, SidebarNavComponent_ng_container_0_c_sidebar_nav_divider_3_Template, 2, 6, \"c-sidebar-nav-divider\", 3);\n    i0.ɵɵtemplate(4, SidebarNavComponent_ng_container_0_c_sidebar_nav_title_4_Template, 2, 6, \"c-sidebar-nav-title\", 3);\n    i0.ɵɵtemplate(5, SidebarNavComponent_ng_container_0_c_sidebar_nav_label_5_Template, 2, 4, \"c-sidebar-nav-label\", 4);\n    i0.ɵɵtemplate(6, SidebarNavComponent_ng_container_0_ng_container_6_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵtemplate(7, SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template, 2, 4, \"c-sidebar-nav-link\", 6);\n    i0.ɵɵelementContainerEnd()();\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r0.helper.itemType(item_r1));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"group\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"divider\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"title\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"label\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"empty\");\n  }\n}\nfunction SidebarNavGroupComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction SidebarNavGroupComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵpipe(1, \"cSidebarNavBadge\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 2, ctx_r1.item));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.item.badge.text);\n  }\n}\nfunction SidebarNavGroupComponent_ng_template_6_i_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"i\", 5);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r4 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 1, item_r4));\n  }\n}\nfunction SidebarNavGroupComponent_ng_template_6_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"svg\", 7);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r4 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"cIcon\", item_r4.iconComponent == null ? null : item_r4.iconComponent.content)(\"customClasses\", i0.ɵɵpipeBind1(1, 3, item_r4))(\"name\", item_r4.iconComponent == null ? null : item_r4.iconComponent.name);\n  }\n}\nfunction SidebarNavGroupComponent_ng_template_6_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 5);\n    i0.ɵɵpipe(1, \"cSidebarNavIcon\");\n  }\n  if (rf & 2) {\n    const item_r4 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBind1(1, 1, item_r4));\n  }\n}\nfunction SidebarNavGroupComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, SidebarNavGroupComponent_ng_template_6_i_0_Template, 2, 3, \"i\", 2);\n    i0.ɵɵtemplate(1, SidebarNavGroupComponent_ng_template_6_ng_template_1_Template, 2, 5, \"ng-template\", 6);\n    i0.ɵɵtemplate(2, SidebarNavGroupComponent_ng_template_6_span_2_Template, 2, 3, \"span\", 2);\n  }\n  if (rf & 2) {\n    const item_r4 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", item_r4 == null ? null : item_r4.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r4 == null ? null : item_r4.iconComponent);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(item_r4 == null ? null : item_r4.icon) && !(item_r4 == null ? null : item_r4.iconComponent));\n  }\n}\nconst _c11 = function () {\n  return {\n    outline: 0\n  };\n};\nfunction ToastHeaderComponent_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleMap(i0.ɵɵpureFunction0(3, _c11));\n    i0.ɵɵproperty(\"cToastClose\", ctx_r0.toast);\n  }\n}\nfunction ToasterComponent_ng_template_0_Template(rf, ctx) {}\nconst _c12 = [\"tooltipTemplate\"];\nfunction WidgetStatAComponent_div_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatAComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtemplate(1, WidgetStatAComponent_div_3_ng_container_1_Template, 1, 0, \"ng-container\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r0.templates == null ? null : ctx_r0.templates.widgetValueTemplate) || _r6);\n  }\n}\nfunction WidgetStatAComponent_div_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatAComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, WidgetStatAComponent_div_4_ng_container_1_Template, 1, 0, \"ng-container\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    const _r4 = i0.ɵɵreference(8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r1.templates == null ? null : ctx_r1.templates.widgetTitleTemplate) || _r4);\n  }\n}\nfunction WidgetStatAComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatAComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatAComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.title, \"\\n\");\n  }\n}\nfunction WidgetStatAComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.value, \"\\n\");\n  }\n}\nfunction WidgetStatAComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction WidgetStatAComponent_ng_template_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\nconst _c13 = [[[\"\", 8, \"chart-wrapper\"]], \"*\"];\nconst _c14 = [\".chart-wrapper\", \"*\"];\nfunction WidgetStatBComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.value);\n  }\n}\nfunction WidgetStatBComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.title);\n  }\n}\nfunction WidgetStatBComponent_small_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"small\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.inverse ? \"text-medium-emphasis-inverse\" : \"text-medium-emphasis\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.text, \" \");\n  }\n}\nfunction WidgetStatCComponent_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatCComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtemplate(1, WidgetStatCComponent_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r4 = i0.ɵɵreference(6);\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.iconClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r0.templates == null ? null : ctx_r0.templates.widgetIconTemplate) || _r4);\n  }\n}\nfunction WidgetStatCComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.valueClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.value, \" \");\n  }\n}\nfunction WidgetStatCComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.titleClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.title, \" \");\n  }\n}\nfunction WidgetStatCComponent_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatCComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, WidgetStatCComponent_ng_container_4_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r3.templates == null ? null : ctx_r3.templates.widgetProgressTemplate) || _r6);\n  }\n}\nfunction WidgetStatCComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.icon, \"\\n\");\n  }\n}\nfunction WidgetStatCComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nfunction WidgetStatDComponent_ng_template_3_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n}\nfunction WidgetStatDComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, WidgetStatDComponent_ng_template_3_div_0_Template, 1, 0, \"div\", 3);\n    i0.ɵɵelementStart(1, \"c-col\")(2, \"div\", 4);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"div\", 5);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const i_r1 = ctx.index;\n    const item_r2 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", i_r1 % 2 !== 0);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(item_r2.value);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r2.title);\n  }\n}\nfunction WidgetStatEComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.titleClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\nfunction WidgetStatEComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.value);\n  }\n}\nfunction WidgetStatFComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatFComponent_c_card_footer_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction WidgetStatFComponent_c_card_footer_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"c-card-footer\");\n    i0.ɵɵtemplate(1, WidgetStatFComponent_c_card_footer_9_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    const _r4 = i0.ɵɵreference(13);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r1.templates == null ? null : ctx_r1.templates.widgetFooterTemplate) || _r4);\n  }\n}\nfunction WidgetStatFComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.icon);\n  }\n}\nfunction WidgetStatFComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r5.footer);\n  }\n}\nvar BreakpointInfix = /*#__PURE__*/(() => {\n  (function (BreakpointInfix) {\n    BreakpointInfix[\"xs\"] = \"xs\";\n    BreakpointInfix[\"sm\"] = \"sm\";\n    BreakpointInfix[\"md\"] = \"md\";\n    BreakpointInfix[\"lg\"] = \"lg\";\n    BreakpointInfix[\"xl\"] = \"xl\";\n    BreakpointInfix[\"xxl\"] = \"xxl\";\n  })(BreakpointInfix || (BreakpointInfix = {}));\n  return BreakpointInfix;\n})();\nlet HtmlAttributesDirective = /*#__PURE__*/(() => {\n  class HtmlAttributesDirective {\n    constructor(renderer, el) {\n      this.renderer = renderer;\n      this.el = el;\n    }\n    ngOnInit() {\n      const attribs = this.cHtmlAttr;\n      for (const attr in attribs) {\n        if (attr === 'style' && typeof attribs[attr] === 'object') {\n          this.setStyle(attribs[attr]);\n        } else if (attr === 'class') {\n          this.addClass(attribs[attr]);\n        } else {\n          this.setAttrib(attr, attribs[attr]);\n        }\n      }\n    }\n    setStyle(styles) {\n      for (const style in styles) {\n        if (style) {\n          this.renderer.setStyle(this.el.nativeElement, style, styles[style]);\n        }\n      }\n    }\n    addClass(classes) {\n      const classArray = Array.isArray(classes) ? classes : classes.split(' ');\n      classArray.filter(element => element.length > 0).forEach(element => {\n        this.renderer.addClass(this.el.nativeElement, element);\n      });\n    }\n    setAttrib(key, value) {\n      value !== null ? this.renderer.setAttribute(this.el.nativeElement, key, value) : this.renderer.removeAttribute(this.el.nativeElement, key);\n    }\n  }\n  HtmlAttributesDirective.ɵfac = function HtmlAttributesDirective_Factory(t) {\n    return new (t || HtmlAttributesDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  HtmlAttributesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HtmlAttributesDirective,\n    selectors: [[\"\", \"cHtmlAttr\", \"\"]],\n    inputs: {\n      cHtmlAttr: \"cHtmlAttr\"\n    },\n    exportAs: [\"cHtmlAttr\"]\n  });\n  return HtmlAttributesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TemplateIdDirective = /*#__PURE__*/(() => {\n  class TemplateIdDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  }\n  TemplateIdDirective.ɵfac = function TemplateIdDirective_Factory(t) {\n    return new (t || TemplateIdDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  TemplateIdDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateIdDirective,\n    selectors: [[\"\", \"cTemplateId\", \"\"]],\n    inputs: {\n      id: [\"cTemplateId\", \"id\"]\n    }\n  });\n  return TemplateIdDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {\n    static forRoot() {\n      return {\n        ngModule: SharedModule\n        // providers: [\n        //   {provide: OutClickService}\n        // ]\n      };\n    }\n  }\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return SharedModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AccordionButtonDirective = /*#__PURE__*/(() => {\n  class AccordionButtonDirective {\n    constructor() {\n      /**\n      * Default type for cAccordionButton. [docs]\n       * @type string\n       * @default 'button'\n       */\n      this.type = 'button';\n    }\n    get hostClasses() {\n      return {\n        'accordion-button': true,\n        collapsed: this.collapsed\n      };\n    }\n    get ariaExpanded() {\n      return !this.collapsed;\n    }\n  }\n  AccordionButtonDirective.ɵfac = function AccordionButtonDirective_Factory(t) {\n    return new (t || AccordionButtonDirective)();\n  };\n  AccordionButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AccordionButtonDirective,\n    selectors: [[\"\", \"cAccordionButton\", \"\"]],\n    hostVars: 4,\n    hostBindings: function AccordionButtonDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type)(\"aria-expanded\", ctx.ariaExpanded);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      collapsed: \"collapsed\",\n      type: \"type\"\n    }\n  });\n  return AccordionButtonDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AccordionService = /*#__PURE__*/(() => {\n  class AccordionService {\n    constructor() {\n      this.items = [];\n      this.alwaysOpen = false;\n    }\n    addItem(item) {\n      this.items.push(item);\n    }\n    removeItem(item) {\n      const index = this.items.indexOf(item);\n      if (index !== -1) {\n        this.items.splice(index, 1);\n      }\n    }\n    toggleItem(item) {\n      item.visible = !item.visible;\n      this.closeOtherItems(item);\n    }\n    closeOtherItems(openItem) {\n      if (!this.alwaysOpen) {\n        this.items.forEach(item => {\n          if (item !== openItem) {\n            item.visible = false;\n          }\n        });\n      }\n    }\n  }\n  AccordionService.ɵfac = function AccordionService_Factory(t) {\n    return new (t || AccordionService)();\n  };\n  AccordionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AccordionService,\n    factory: AccordionService.ɵfac\n  });\n  return AccordionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AccordionComponent = /*#__PURE__*/(() => {\n  class AccordionComponent {\n    constructor(accordionService) {\n      this.accordionService = accordionService;\n    }\n    /**\n     * Make accordion items stay open when another item is opened\n     * @type boolean\n     */\n    set alwaysOpen(value) {\n      this.accordionService.alwaysOpen = coerceBooleanProperty(value);\n    }\n    get alwaysOpen() {\n      return this.accordionService.alwaysOpen;\n    }\n    get hostClasses() {\n      return {\n        accordion: true,\n        'accordion-flush': !!this.flush\n      };\n    }\n  }\n  AccordionComponent.ɵfac = function AccordionComponent_Factory(t) {\n    return new (t || AccordionComponent)(i0.ɵɵdirectiveInject(AccordionService));\n  };\n  AccordionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AccordionComponent,\n    selectors: [[\"c-accordion\"]],\n    hostVars: 2,\n    hostBindings: function AccordionComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      flush: \"flush\",\n      alwaysOpen: \"alwaysOpen\"\n    },\n    exportAs: [\"cAccordionItem\"],\n    features: [i0.ɵɵProvidersFeature([AccordionService])],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function AccordionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return AccordionComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst expandAnimation = animation([animate('{{ time }} {{ easing }}')]);\nconst collapseAnimation = animation([style({\n  height: '*',\n  minHeight: '*'\n}), animate('{{ time }} {{ easing }}', style({\n  height: 0,\n  minHeight: 0\n}))]);\nconst expandHorizontalAnimation = animation([animate('{{ time }} {{ easing }}')]);\nconst collapseHorizontalAnimation = animation([\n// style({ opacity: '*' }),\nanimate('{{ time }} {{ easing }}'\n// style({ opacity: 0 })\n)]);\n\n// todo\n// tslint:disable-next-line:no-conflicting-lifecycle\nlet CollapseDirective = /*#__PURE__*/(() => {\n  class CollapseDirective {\n    constructor(hostElement, renderer, animationBuilder) {\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.animationBuilder = animationBuilder;\n      this._animate = true;\n      this._horizontal = false;\n      this._visible = false;\n      this._navbar = false;\n      /**\n       * @ignore\n       */\n      this.duration = '350ms';\n      /**\n       * @ignore\n       */\n      this.transition = 'ease';\n      /**\n       * Event emitted on visibility change. [docs]\n       * @type string\n       */\n      this.collapseChange = new EventEmitter();\n      this.collapsing = false;\n      this.host = this.hostElement.nativeElement;\n      this.renderer.setStyle(this.host, 'display', 'none');\n    }\n    /**\n     * @ignore\n     */\n    set animate(value) {\n      this._animate = value;\n    }\n    get animate() {\n      return this._animate;\n    }\n    /**\n     * Set horizontal collapsing to transition the width instead of height.\n     */\n    set horizontal(value) {\n      this._horizontal = coerceBooleanProperty(value);\n    }\n    get horizontal() {\n      return this._horizontal;\n    }\n    /**\n     * Toggle the visibility of collapsible element.\n     */\n    set visible(value) {\n      this._visible = coerceBooleanProperty(value);\n    }\n    get visible() {\n      return this._visible;\n    }\n    /**\n     * Add `navbar` prop for grouping and hiding navbar contents by a parent breakpoint.\n     */\n    set navbar(value) {\n      this._navbar = coerceBooleanProperty(value);\n    }\n    get navbar() {\n      return this._navbar;\n    }\n    get hostClasses() {\n      return {\n        'navbar-collapse': this.navbar,\n        'collapse-horizontal': this.horizontal\n      };\n    }\n    ngAfterViewInit() {\n      if (this.visible) {\n        this.toggle();\n      }\n    }\n    ngOnDestroy() {\n      this.destroyPlayer();\n    }\n    ngOnChanges(changes) {\n      if (changes['visible']) {\n        if (!changes['visible'].firstChange || !changes['visible'].currentValue) {\n          this.toggle(changes['visible'].currentValue);\n        }\n      }\n    }\n    ngDoCheck() {\n      if (this._visible !== this.visible) {\n        this.toggle();\n      }\n    }\n    toggle(visible = this.visible) {\n      this.createPlayer(visible);\n      this.player?.play();\n    }\n    destroyPlayer() {\n      this.player?.destroy();\n    }\n    createPlayer(visible = this.visible) {\n      if (this.player?.hasStarted()) {\n        this.destroyPlayer();\n      }\n      if (visible) {\n        this.renderer.removeStyle(this.host, 'display');\n      }\n      const duration = this.animate ? this.duration : '0ms';\n      const expand = this.horizontal ? expandHorizontalAnimation : expandAnimation;\n      const collapse = this.horizontal ? collapseHorizontalAnimation : collapseAnimation;\n      const dimension = this.horizontal ? 'width' : 'height';\n      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      const scrollSize = `scroll${capitalizedDimension}`;\n      const animationFactory = this.animationBuilder.build(useAnimation(visible ? expand : collapse, {\n        params: {\n          time: duration,\n          easing: this.transition\n        }\n      }));\n      this.player = animationFactory.create(this.host);\n      this.renderer.setStyle(this.host, dimension, visible ? 0 : `${this.host.getBoundingClientRect()[dimension]}px`);\n      !visible && this.host.offsetHeight;\n      this.player.onStart(() => {\n        this.setMaxSize();\n        this.renderer.removeClass(this.host, 'collapse');\n        this.renderer.addClass(this.host, 'collapsing');\n        this.renderer.removeClass(this.host, 'show');\n        this.collapsing = true;\n        if (visible) {\n          // @ts-ignore\n          this.renderer.setStyle(this.host, dimension, `${this.host[scrollSize]}px`);\n        } else {\n          this.renderer.setStyle(this.host, dimension, '');\n        }\n        this.collapseChange.emit(visible ? 'opening' : 'collapsing');\n      });\n      this.player.onDone(() => {\n        this.visible = visible;\n        this.collapsing = false;\n        this.renderer.removeClass(this.host, 'collapsing');\n        this.renderer.addClass(this.host, 'collapse');\n        if (visible) {\n          this.renderer.addClass(this.host, 'show');\n          this.renderer.setStyle(this.host, dimension, '');\n        } else {\n          this.renderer.removeClass(this.host, 'show');\n        }\n        this.collapseChange.emit(visible ? 'open' : 'collapsed');\n      });\n    }\n    setMaxSize() {\n      // setTimeout(() => {\n      if (this.horizontal) {\n        this.scrollWidth = this.host.scrollWidth;\n        this.scrollWidth > 0 && this.renderer.setStyle(this.host, 'maxWidth', `${this.scrollWidth}px`);\n        // } else {\n        // this.scrollHeight = this.host.scrollHeight;\n        // this.scrollHeight > 0 && this.renderer.setStyle(this.host, 'maxHeight', `${this.scrollHeight}px`);\n      }\n      // });\n    }\n  }\n\n  CollapseDirective.ɵfac = function CollapseDirective_Factory(t) {\n    return new (t || CollapseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AnimationBuilder));\n  };\n  CollapseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CollapseDirective,\n    selectors: [[\"\", \"cCollapse\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CollapseDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      animate: \"animate\",\n      horizontal: \"horizontal\",\n      visible: \"visible\",\n      navbar: \"navbar\",\n      duration: \"duration\",\n      transition: \"transition\"\n    },\n    outputs: {\n      collapseChange: \"collapseChange\"\n    },\n    exportAs: [\"cCollapse\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return CollapseDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId$1 = 0;\nlet AccordionItemComponent = /*#__PURE__*/(() => {\n  class AccordionItemComponent {\n    constructor(accordionService) {\n      this.accordionService = accordionService;\n      this._visible = false;\n      this.contentId = `accordion-item-${nextId$1++}`;\n      this.itemContext = {\n        $implicit: this.visible\n      };\n      this.templates = {};\n    }\n    /**\n     * Toggle an accordion item programmatically\n     * @type boolean\n     * @default false\n     */\n    set visible(value) {\n      this._visible = coerceBooleanProperty(value);\n    }\n    get visible() {\n      return this._visible;\n    }\n    set open(value) {\n      console.warn('c-accordion-item \"open\" prop is deprecated, use \"visible\"  prop instead.');\n      this.visible = value || this.visible;\n    }\n    get open() {\n      return this.visible;\n    }\n    get hostClasses() {\n      return {\n        'accordion-item': true\n      };\n    }\n    ngOnInit() {\n      this.accordionService.addItem(this);\n    }\n    ngOnDestroy() {\n      this.accordionService.removeItem(this);\n    }\n    toggleItem() {\n      this.accordionService.toggleItem(this);\n    }\n    ngAfterContentInit() {\n      this.contentTemplates.forEach(child => {\n        this.templates[child.id] = child.templateRef;\n      });\n    }\n  }\n  AccordionItemComponent.ɵfac = function AccordionItemComponent_Factory(t) {\n    return new (t || AccordionItemComponent)(i0.ɵɵdirectiveInject(AccordionService));\n  };\n  AccordionItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AccordionItemComponent,\n    selectors: [[\"c-accordion-item\"]],\n    contentQueries: function AccordionItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateIdDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplates = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function AccordionItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      visible: \"visible\",\n      open: \"open\"\n    },\n    exportAs: [\"cAccordionItem\"],\n    ngContentSelectors: _c1,\n    decls: 13,\n    vars: 7,\n    consts: [[1, \"accordion-header\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"cCollapse\", \"\", 1, \"accordion-collapse\", 3, \"visible\", \"id\"], [\"defaultAccordionHeaderTemplate\", \"\"], [\"defaultAccordionHeaderContentTemplate\", \"\"], [\"defaultAccordionBodyTemplate\", \"\"], [\"defaultAccordionBodyContentTemplate\", \"\"], [\"cAccordionButton\", \"\", 3, \"collapsed\", \"click\"], [1, \"accordion-body\"]],\n    template: function AccordionItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c1);\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelementStart(1, \"div\", 0);\n        i0.ɵɵtemplate(2, AccordionItemComponent_ng_container_2_Template, 1, 0, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2);\n        i0.ɵɵtemplate(4, AccordionItemComponent_ng_container_4_Template, 1, 0, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(5, AccordionItemComponent_ng_template_5_Template, 2, 4, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, AccordionItemComponent_ng_template_7_Template, 1, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, AccordionItemComponent_ng_template_9_Template, 2, 2, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, AccordionItemComponent_ng_template_11_Template, 1, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(6);\n        const _r6 = i0.ɵɵreference(10);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates[\"accordionHeaderTemplate\"] || _r2)(\"ngTemplateOutletContext\", ctx.itemContext);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"visible\", ctx.visible)(\"id\", ctx.contentId);\n        i0.ɵɵattribute(\"aria-expanded\", ctx.visible);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates[\"accordionBodyTemplate\"] || _r6)(\"ngTemplateOutletContext\", ctx.itemContext);\n      }\n    },\n    dependencies: [i1$1.NgTemplateOutlet, CollapseDirective, AccordionButtonDirective],\n    styles: [\"[_nghost-%COMP%]{display:block;overflow:hidden}\"]\n  });\n  return AccordionItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CollapseModule = /*#__PURE__*/(() => {\n  class CollapseModule {\n    static forRoot() {\n      return {\n        ngModule: CollapseModule,\n        providers: []\n      };\n    }\n  }\n  CollapseModule.ɵfac = function CollapseModule_Factory(t) {\n    return new (t || CollapseModule)();\n  };\n  CollapseModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CollapseModule\n  });\n  CollapseModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return CollapseModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AccordionModule = /*#__PURE__*/(() => {\n  class AccordionModule {}\n  AccordionModule.ɵfac = function AccordionModule_Factory(t) {\n    return new (t || AccordionModule)();\n  };\n  AccordionModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AccordionModule\n  });\n  AccordionModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AccordionService],\n    imports: [CommonModule, CollapseModule, SharedModule]\n  });\n  return AccordionModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlertHeadingDirective = /*#__PURE__*/(() => {\n  class AlertHeadingDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'alert-heading': true\n      };\n    }\n  }\n  AlertHeadingDirective.ɵfac = function AlertHeadingDirective_Factory(t) {\n    return new (t || AlertHeadingDirective)();\n  };\n  AlertHeadingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AlertHeadingDirective,\n    selectors: [[\"\", \"cAlertHeading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function AlertHeadingDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return AlertHeadingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlertLinkDirective = /*#__PURE__*/(() => {\n  class AlertLinkDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'alert-link': true\n      };\n    }\n  }\n  AlertLinkDirective.ɵfac = function AlertLinkDirective_Factory(t) {\n    return new (t || AlertLinkDirective)();\n  };\n  AlertLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AlertLinkDirective,\n    selectors: [[\"\", \"cAlertLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function AlertLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return AlertLinkDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonDirective = /*#__PURE__*/(() => {\n  class ButtonDirective {\n    constructor() {\n      this._active = false;\n      this._disabled = false;\n      /**\n       * Sets the color context of the component to one of CoreUI’s themed colors. [docs]\n       * @type Colors\n       */\n      this.color = 'primary';\n      /**\n       * Size the component small or large.\n       * @type {'sm' | 'lg'}\n       */\n      this.size = '';\n      /**\n       * Specifies the type of button. Always specify the type attribute for the `<button>` element.\n       * Different browsers may use different default types for the `<button>` element.\n       */\n      this.type = 'button';\n    }\n    /**\n     * Toggle the active state for the component. [docs]\n     * @type boolean\n     */\n    get active() {\n      return this._active;\n    }\n    set active(value) {\n      this._active = coerceBooleanProperty(value);\n    }\n    /**\n     * Toggle the disabled state for the component.\n     * @type boolean\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        btn: true,\n        [`btn-${this.color}`]: !!this.color && !this.variant,\n        [`btn-${this.variant}`]: !!this.variant && !this.color,\n        [`btn-${this.variant}-${this.color}`]: !!this.variant && !!this.color,\n        [`btn-${this.size}`]: !!this.size,\n        [`${this.shape}`]: !!this.shape,\n        disabled: this.disabled,\n        active: this.active\n      };\n    }\n    get ariaDisabled() {\n      return this.disabled || null;\n    }\n    get isActive() {\n      return this.active || null;\n    }\n    get attrDisabled() {\n      return this.disabled ? '' : null;\n    }\n    get tabIndex() {\n      return this.disabled ? '-1' : null;\n    }\n  }\n  ButtonDirective.ɵfac = function ButtonDirective_Factory(t) {\n    return new (t || ButtonDirective)();\n  };\n  ButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ButtonDirective,\n    selectors: [[\"\", \"cButton\", \"\"]],\n    hostVars: 7,\n    hostBindings: function ButtonDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type)(\"aria-disabled\", ctx.ariaDisabled)(\"aria-pressed\", ctx.isActive)(\"disabled\", ctx.attrDisabled)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      color: \"color\",\n      disabled: \"disabled\",\n      shape: \"shape\",\n      size: \"size\",\n      type: \"type\",\n      variant: \"variant\"\n    },\n    exportAs: [\"cButton\"]\n  });\n  return ButtonDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonCloseDirective = /*#__PURE__*/(() => {\n  class ButtonCloseDirective extends ButtonDirective {\n    constructor() {\n      super(...arguments);\n      this._white = false;\n    }\n    /**\n     * Change the default color to white.\n     * @type boolean\n     */\n    get white() {\n      return this._white;\n    }\n    set white(value) {\n      this._white = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        btn: true,\n        'btn-close': true,\n        'btn-close-white': this.white,\n        [`btn-${this.size}`]: !!this.size,\n        disabled: this.disabled,\n        active: this.active\n      };\n    }\n  }\n  ButtonCloseDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵButtonCloseDirective_BaseFactory;\n    return function ButtonCloseDirective_Factory(t) {\n      return (ɵButtonCloseDirective_BaseFactory || (ɵButtonCloseDirective_BaseFactory = i0.ɵɵgetInheritedFactory(ButtonCloseDirective)))(t || ButtonCloseDirective);\n    };\n  }();\n  ButtonCloseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ButtonCloseDirective,\n    selectors: [[\"\", \"cButtonClose\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ButtonCloseDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      white: \"white\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ButtonCloseDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlertComponent = /*#__PURE__*/(() => {\n  class AlertComponent {\n    constructor() {\n      /**\n       * Sets the color context of the component to one of CoreUI’s themed colors.\n       *\n       * @type Colors\n       * @default 'primary'\n       */\n      this.color = 'primary';\n      this._dismissible = false;\n      this._fade = false;\n      /**\n       * Default role for alert. [docs]\n       * @type string\n       * @default 'alert'\n       */\n      this.role = 'alert';\n      this._visible = true;\n      /**\n       * Event triggered on the alert dismiss.\n       */\n      this.visibleChange = new EventEmitter();\n      this.templates = {};\n    }\n    /**\n     * Optionally adds a close button to alert and allow it to self dismiss.\n     * @type boolean\n     */\n    get dismissible() {\n      return this._dismissible;\n    }\n    set dismissible(value) {\n      this._dismissible = coerceBooleanProperty(value);\n    }\n    /**\n     * Adds animation for dismissible alert.\n     * @type boolean\n     */\n    get fade() {\n      return this._fade;\n    }\n    set fade(value) {\n      this._fade = coerceBooleanProperty(value);\n    }\n    /**\n     * Toggle the visibility of alert component.\n     * @type boolean\n     */\n    set visible(value) {\n      if (this._visible !== value) {\n        this._visible = coerceBooleanProperty(value);\n        this.visibleChange.emit(value);\n      }\n    }\n    get visible() {\n      return this._visible;\n    }\n    get animationDisabled() {\n      return !this.fade;\n    }\n    get animateType() {\n      return this.visible ? 'show' : 'hide';\n    }\n    get hostClasses() {\n      return {\n        alert: true,\n        'alert-dismissible': this.dismissible,\n        fade: this.fade,\n        show: !this.hide,\n        [`alert-${this.color}`]: !!this.color && this.variant !== 'solid',\n        [`bg-${this.color}`]: !!this.color && this.variant === 'solid',\n        'text-white': !!this.color && this.variant === 'solid'\n      };\n    }\n    onAnimationStart($event) {\n      this.onAnimationEvent($event);\n    }\n    onAnimationDone($event) {\n      this.onAnimationEvent($event);\n    }\n    ngAfterContentInit() {\n      this.contentTemplates.forEach(child => {\n        this.templates[child.id] = child.templateRef;\n      });\n    }\n    onAnimationEvent(event) {\n      this.hide = event.phaseName === 'start' && event.toState === 'show';\n      if (event.phaseName === 'done') {\n        this.hide = event.toState === 'hide' || event.toState === 'void';\n        if (event.toState === 'show') {\n          this.hide = false;\n        }\n      }\n    }\n  }\n  AlertComponent.ɵfac = function AlertComponent_Factory(t) {\n    return new (t || AlertComponent)();\n  };\n  AlertComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AlertComponent,\n    selectors: [[\"c-alert\"]],\n    contentQueries: function AlertComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateIdDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplates = _t);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function AlertComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@fadeInOut.start\", function AlertComponent_animation_fadeInOut_start_HostBindingHandler($event) {\n          return ctx.onAnimationStart($event);\n        })(\"@fadeInOut.done\", function AlertComponent_animation_fadeInOut_done_HostBindingHandler($event) {\n          return ctx.onAnimationDone($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.animationDisabled)(\"@fadeInOut\", ctx.animateType);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      dismissible: \"dismissible\",\n      fade: \"fade\",\n      role: \"role\",\n      variant: \"variant\",\n      visible: \"visible\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\"\n    },\n    exportAs: [\"cAlert\"],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"defaultAlertButtonCloseTemplate\", \"\"], [3, \"ngIf\"], [4, \"ngTemplateOutlet\"], [\"aria-label\", \"Close\", \"cButtonClose\", \"\", 3, \"click\"]],\n    template: function AlertComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, AlertComponent_ng_container_0_Template, 3, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, AlertComponent_ng_template_1_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.visible || !ctx.hide);\n      }\n    },\n    dependencies: [i1$1.NgIf, i1$1.NgTemplateOutlet, ButtonCloseDirective],\n    styles: [\"[_nghost-%COMP%]{display:block;overflow:hidden}\"],\n    data: {\n      animation: [trigger('fadeInOut', [state('show', style({\n        opacity: 1,\n        height: '*',\n        padding: '*',\n        border: '*',\n        margin: '*'\n      })), state('hide', style({\n        opacity: 0,\n        height: 0,\n        padding: 0,\n        border: 0,\n        margin: 0\n      })), state('void', style({\n        opacity: 0,\n        height: 0,\n        padding: 0,\n        border: 0,\n        margin: 0\n      })), transition('show => hide', [animate('.3s ease-out')]), transition('hide => show', [animate('.3s ease-in')]), transition('show => void', [animate('.3s ease-out')]), transition('void => show', [animate('.3s ease-in')])])]\n    }\n  });\n  return AlertComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonModule = /*#__PURE__*/(() => {\n  class ButtonModule {}\n  ButtonModule.ɵfac = function ButtonModule_Factory(t) {\n    return new (t || ButtonModule)();\n  };\n  ButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ButtonModule\n  });\n  ButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return ButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlertModule = /*#__PURE__*/(() => {\n  class AlertModule {}\n  AlertModule.ɵfac = function AlertModule_Factory(t) {\n    return new (t || AlertModule)();\n  };\n  AlertModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AlertModule\n  });\n  AlertModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, ButtonModule]\n  });\n  return AlertModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AvatarComponent = /*#__PURE__*/(() => {\n  class AvatarComponent {\n    constructor() {\n      /**\n       * Size the component small, large, or extra large.\n       * @default 'md'\n       */\n      this.size = 'md';\n    }\n    get statusClass() {\n      return {\n        'avatar-status': true,\n        [`bg-${this.status}`]: !!this.status\n      };\n    }\n    get hostClasses() {\n      return {\n        avatar: true,\n        [`avatar-${this.size}`]: !!this.size,\n        [`bg-${this.color}`]: !!this.color,\n        [`${this.shape}`]: !!this.shape,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n  }\n  AvatarComponent.ɵfac = function AvatarComponent_Factory(t) {\n    return new (t || AvatarComponent)();\n  };\n  AvatarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AvatarComponent,\n    selectors: [[\"c-avatar\"]],\n    hostVars: 2,\n    hostBindings: function AvatarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      shape: \"shape\",\n      size: \"size\",\n      src: \"src\",\n      status: \"status\",\n      textColor: \"textColor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 2,\n    consts: [[4, \"ngTemplateOutlet\"], [3, \"ngClass\", 4, \"ngIf\"], [\"defaultImageTemplate\", \"\"], [3, \"ngClass\"], [\"class\", \"avatar-img\", 3, \"src\", 4, \"ngIf\", \"ngIfElse\"], [\"imageContent\", \"\"], [1, \"avatar-img\", 3, \"src\"]],\n    template: function AvatarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵtemplate(1, AvatarComponent_ng_container_1_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(2, AvatarComponent_span_2_Template, 1, 1, \"span\", 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(3, AvatarComponent_ng_template_3_Template, 3, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(4);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.status);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet]\n  });\n  return AvatarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AvatarModule = /*#__PURE__*/(() => {\n  class AvatarModule {}\n  AvatarModule.ɵfac = function AvatarModule_Factory(t) {\n    return new (t || AvatarModule)();\n  };\n  AvatarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AvatarModule\n  });\n  AvatarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return AvatarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BadgeComponent = /*#__PURE__*/(() => {\n  class BadgeComponent {\n    constructor() {}\n    get hostClasses() {\n      const positionClasses = {\n        'position-absolute': !!this.position,\n        'translate-middle': !!this.position,\n        'top-0': this.position?.includes('top'),\n        'top-100': this.position?.includes('bottom'),\n        'start-100': this.position?.includes('end'),\n        'start-0': this.position?.includes('start')\n      };\n      return Object.assign({\n        badge: true,\n        [`bg-${this.color}`]: !!this.color,\n        [`text-${this.textColor}`]: !!this.textColor,\n        [`badge-${this.size}`]: !!this.size,\n        [`${this.shape}`]: !!this.shape\n      }, !!this.position ? positionClasses : {});\n    }\n  }\n  BadgeComponent.ɵfac = function BadgeComponent_Factory(t) {\n    return new (t || BadgeComponent)();\n  };\n  BadgeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BadgeComponent,\n    selectors: [[\"c-badge\"]],\n    hostVars: 2,\n    hostBindings: function BadgeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      position: \"position\",\n      shape: \"shape\",\n      size: \"size\",\n      textColor: \"textColor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function BadgeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return BadgeComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BadgeModule = /*#__PURE__*/(() => {\n  class BadgeModule {}\n  BadgeModule.ɵfac = function BadgeModule_Factory(t) {\n    return new (t || BadgeModule)();\n  };\n  BadgeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BadgeModule\n  });\n  BadgeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return BadgeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreadcrumbItemComponent = /*#__PURE__*/(() => {\n  class BreadcrumbItemComponent {\n    get ariaCurrent() {\n      return this.active ? 'page' : null;\n    }\n    get hostClasses() {\n      return {\n        'breadcrumb-item': true,\n        active: this.active\n      };\n    }\n  }\n  BreadcrumbItemComponent.ɵfac = function BreadcrumbItemComponent_Factory(t) {\n    return new (t || BreadcrumbItemComponent)();\n  };\n  BreadcrumbItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BreadcrumbItemComponent,\n    selectors: [[\"c-breadcrumb-item\"]],\n    hostVars: 3,\n    hostBindings: function BreadcrumbItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-current\", ctx.ariaCurrent);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      url: \"url\",\n      attributes: \"attributes\",\n      linkProps: \"linkProps\"\n    },\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 2,\n    consts: [[3, \"routerLink\", \"cHtmlAttr\", \"target\", \"queryParams\", \"fragment\", \"queryParamsHandling\", \"preserveFragment\", \"skipLocationChange\", \"replaceUrl\", \"state\", 4, \"ngIf\", \"ngIfElse\"], [\"activeItem\", \"\"], [\"defaultBreadcrumbItemContentTemplate\", \"\"], [3, \"routerLink\", \"cHtmlAttr\", \"target\", \"queryParams\", \"fragment\", \"queryParamsHandling\", \"preserveFragment\", \"skipLocationChange\", \"replaceUrl\", \"state\"], [4, \"ngTemplateOutlet\"], [3, \"cHtmlAttr\"]],\n    template: function BreadcrumbItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, BreadcrumbItemComponent_a_0_Template, 2, 13, \"a\", 0);\n        i0.ɵɵtemplate(1, BreadcrumbItemComponent_ng_template_1_Template, 2, 3, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, BreadcrumbItemComponent_ng_template_3_Template, 1, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.active)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [i1$1.NgIf, i1$1.NgTemplateOutlet, i3.RouterLink, HtmlAttributesDirective],\n    styles: [\"[_nghost-%COMP%]{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\"]\n  });\n  return BreadcrumbItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreadcrumbComponent = /*#__PURE__*/(() => {\n  class BreadcrumbComponent {\n    constructor() {\n      /**\n       * Default aria-label for breadcrumb. [docs]\n       * @type string\n       * @default 'breadcrumb'\n       */\n      this.ariaLabel = 'breadcrumb';\n      /**\n       * Default role for breadcrumb. [docs]\n       * @type string\n       * @default 'navigation'\n       */\n      this.role = 'navigation';\n    }\n    get hostClasses() {\n      return {\n        breadcrumb: true\n      };\n    }\n  }\n  BreadcrumbComponent.ɵfac = function BreadcrumbComponent_Factory(t) {\n    return new (t || BreadcrumbComponent)();\n  };\n  BreadcrumbComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BreadcrumbComponent,\n    selectors: [[\"c-breadcrumb\"]],\n    hostVars: 4,\n    hostBindings: function BreadcrumbComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      ariaLabel: \"ariaLabel\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function BreadcrumbComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return BreadcrumbComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreadcrumbRouterService = /*#__PURE__*/(() => {\n  class BreadcrumbRouterService {\n    constructor(router, route) {\n      this.router = router;\n      this.route = route;\n      this.outlet = 'primary';\n      this.breadcrumbsBehaviorSubject = new BehaviorSubject(new Array());\n      this.breadcrumbs$ = this.breadcrumbsBehaviorSubject.asObservable();\n      this.router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe(event => {\n        const breadcrumbs = [];\n        let currentRoute = this.route.root;\n        let url = '';\n        do {\n          const childrenRoutes = currentRoute.children;\n          currentRoute = null;\n          childrenRoutes.forEach(childRoute => {\n            // console.log('breadcrumb event', event, 'route', route);\n            if (childRoute.outlet === this.outlet) {\n              const routeSnapshot = childRoute.snapshot;\n              url += '/' + routeSnapshot.url.map(segment => segment.path).join('/');\n              breadcrumbs.push({\n                label: childRoute.snapshot.data['title'] || '',\n                url,\n                queryParams: routeSnapshot.queryParams\n              });\n              currentRoute = childRoute;\n            }\n          });\n        } while (currentRoute);\n        this.breadcrumbsBehaviorSubject.next(Object.assign([], breadcrumbs));\n        // console.log('breadcrumbs', breadcrumbs);\n        return breadcrumbs;\n      });\n    }\n  }\n  BreadcrumbRouterService.ɵfac = function BreadcrumbRouterService_Factory(t) {\n    return new (t || BreadcrumbRouterService)(i0.ɵɵinject(i3.Router), i0.ɵɵinject(i3.ActivatedRoute));\n  };\n  BreadcrumbRouterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BreadcrumbRouterService,\n    factory: BreadcrumbRouterService.ɵfac,\n    providedIn: 'root'\n  });\n  return BreadcrumbRouterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreadcrumbRouterComponent = /*#__PURE__*/(() => {\n  class BreadcrumbRouterComponent {\n    constructor(service) {\n      this.service = service;\n    }\n    ngOnInit() {\n      this.breadcrumbs = this.service.breadcrumbs$;\n    }\n    ngOnChanges(changes) {\n      if (changes['items']) {\n        this.setup();\n      }\n    }\n    setup() {\n      if (this.items && this.items.length > 0) {\n        this.breadcrumbs = new Observable(observer => {\n          if (this.items) {\n            observer.next(this.items);\n          }\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.breadcrumbs = undefined;\n    }\n  }\n  BreadcrumbRouterComponent.ɵfac = function BreadcrumbRouterComponent_Factory(t) {\n    return new (t || BreadcrumbRouterComponent)(i0.ɵɵdirectiveInject(BreadcrumbRouterService));\n  };\n  BreadcrumbRouterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BreadcrumbRouterComponent,\n    selectors: [[\"c-breadcrumb-router\"], [\"\", \"cBreadcrumbRouter\", \"\"]],\n    inputs: {\n      items: \"items\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 3,\n    consts: [[1, \"m-0\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [4, \"ngIf\"], [3, \"active\", \"url\", \"attributes\", \"linkProps\"]],\n    template: function BreadcrumbRouterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"c-breadcrumb\", 0);\n        i0.ɵɵtemplate(1, BreadcrumbRouterComponent_ng_template_1_Template, 1, 1, \"ng-template\", 1);\n        i0.ɵɵpipe(2, \"async\");\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx.breadcrumbs));\n      }\n    },\n    dependencies: [i1$1.NgForOf, i1$1.NgIf, BreadcrumbItemComponent, BreadcrumbComponent, i1$1.AsyncPipe]\n  });\n  return BreadcrumbRouterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreadcrumbModule = /*#__PURE__*/(() => {\n  class BreadcrumbModule {}\n  BreadcrumbModule.ɵfac = function BreadcrumbModule_Factory(t) {\n    return new (t || BreadcrumbModule)();\n  };\n  BreadcrumbModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BreadcrumbModule\n  });\n  BreadcrumbModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [BreadcrumbRouterService],\n    imports: [CommonModule, RouterModule, SharedModule]\n  });\n  return BreadcrumbModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonGroupComponent = /*#__PURE__*/(() => {\n  class ButtonGroupComponent {\n    constructor() {\n      /**\n       * Default role attr for ButtonGroup. [docs]\n       * @type string\n       * @default 'group'\n       */\n      this.role = 'group';\n    }\n    get hostClasses() {\n      return {\n        'btn-group': !this.vertical,\n        'btn-group-vertical': this.vertical,\n        [`btn-group-${this.size}`]: !!this.size\n      };\n    }\n  }\n  ButtonGroupComponent.ɵfac = function ButtonGroupComponent_Factory(t) {\n    return new (t || ButtonGroupComponent)();\n  };\n  ButtonGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ButtonGroupComponent,\n    selectors: [[\"c-button-group\"]],\n    hostVars: 3,\n    hostBindings: function ButtonGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      size: \"size\",\n      vertical: \"vertical\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ButtonGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ButtonGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonToolbarComponent = /*#__PURE__*/(() => {\n  class ButtonToolbarComponent {\n    constructor() {\n      /**\n       * Default role attr for ButtonToolbar. [docs]\n       * @type string\n       * @default 'toolbar'\n       */\n      this.role = 'toolbar';\n    }\n    get hostClasses() {\n      return {\n        'btn-toolbar': true\n      };\n    }\n  }\n  ButtonToolbarComponent.ɵfac = function ButtonToolbarComponent_Factory(t) {\n    return new (t || ButtonToolbarComponent)();\n  };\n  ButtonToolbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ButtonToolbarComponent,\n    selectors: [[\"c-button-toolbar\"]],\n    hostVars: 3,\n    hostBindings: function ButtonToolbarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ButtonToolbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ButtonToolbarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonGroupModule = /*#__PURE__*/(() => {\n  class ButtonGroupModule {}\n  ButtonGroupModule.ɵfac = function ButtonGroupModule_Factory(t) {\n    return new (t || ButtonGroupModule)();\n  };\n  ButtonGroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ButtonGroupModule\n  });\n  ButtonGroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return ButtonGroupModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CalloutComponent = /*#__PURE__*/(() => {\n  class CalloutComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        callout: true,\n        [`callout-${this.color}`]: !!this.color\n      };\n    }\n  }\n  CalloutComponent.ɵfac = function CalloutComponent_Factory(t) {\n    return new (t || CalloutComponent)();\n  };\n  CalloutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CalloutComponent,\n    selectors: [[\"c-callout\"], [\"\", \"cCallout\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CalloutComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CalloutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return CalloutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CalloutModule = /*#__PURE__*/(() => {\n  class CalloutModule {}\n  CalloutModule.ɵfac = function CalloutModule_Factory(t) {\n    return new (t || CalloutModule)();\n  };\n  CalloutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CalloutModule\n  });\n  CalloutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return CalloutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardComponent = /*#__PURE__*/(() => {\n  class CardComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        card: true,\n        [`bg-${this.color}`]: !!this.color,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n  }\n  CardComponent.ɵfac = function CardComponent_Factory(t) {\n    return new (t || CardComponent)();\n  };\n  CardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardComponent,\n    selectors: [[\"c-card\"], [\"\", \"c-card\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      textColor: \"textColor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardBodyComponent = /*#__PURE__*/(() => {\n  class CardBodyComponent {\n    get hostClasses() {\n      return {\n        'card-body': true\n      };\n    }\n  }\n  CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) {\n    return new (t || CardBodyComponent)();\n  };\n  CardBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardBodyComponent,\n    selectors: [[\"c-card-body\"], [\"\", \"c-card-body\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardFooterComponent = /*#__PURE__*/(() => {\n  class CardFooterComponent {\n    get hostClasses() {\n      return {\n        'card-footer': true\n      };\n    }\n  }\n  CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) {\n    return new (t || CardFooterComponent)();\n  };\n  CardFooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardFooterComponent,\n    selectors: [[\"c-card-footer\"], [\"\", \"c-card-footer\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardFooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardFooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardFooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardGroupComponent = /*#__PURE__*/(() => {\n  class CardGroupComponent {\n    get hostClasses() {\n      return {\n        'card-group': true\n      };\n    }\n  }\n  CardGroupComponent.ɵfac = function CardGroupComponent_Factory(t) {\n    return new (t || CardGroupComponent)();\n  };\n  CardGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardGroupComponent,\n    selectors: [[\"c-card-group\"], [\"\", \"c-card-group\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardHeaderComponent = /*#__PURE__*/(() => {\n  class CardHeaderComponent {\n    get hostClasses() {\n      return {\n        'card-header': true\n      };\n    }\n  }\n  CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) {\n    return new (t || CardHeaderComponent)();\n  };\n  CardHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardHeaderComponent,\n    selectors: [[\"c-card-header\"], [\"\", \"c-card-header\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardHeaderActionsComponent = /*#__PURE__*/(() => {\n  class CardHeaderActionsComponent {\n    constructor() {\n      this.cardHeaderActions = true;\n    }\n  }\n  CardHeaderActionsComponent.ɵfac = function CardHeaderActionsComponent_Factory(t) {\n    return new (t || CardHeaderActionsComponent)();\n  };\n  CardHeaderActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardHeaderActionsComponent,\n    selectors: [[\"c-card-header-actions\"], [\"\", \"c-card-header-actions\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardHeaderActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"card-header-actions\", ctx.cardHeaderActions);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardHeaderActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardHeaderActionsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardImgDirective = /*#__PURE__*/(() => {\n  class CardImgDirective {\n    get hostClasses() {\n      const suffix = !!this.orientation ? `-${this.orientation}` : '';\n      return {\n        [`card-img${suffix}`]: true\n      };\n    }\n  }\n  CardImgDirective.ɵfac = function CardImgDirective_Factory(t) {\n    return new (t || CardImgDirective)();\n  };\n  CardImgDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardImgDirective,\n    selectors: [[\"\", \"cCardImg\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardImgDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      orientation: [\"cCardImg\", \"orientation\"]\n    }\n  });\n  return CardImgDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardImgOverlayComponent = /*#__PURE__*/(() => {\n  class CardImgOverlayComponent {\n    get hostClasses() {\n      return {\n        'card-img-overlay': true\n      };\n    }\n  }\n  CardImgOverlayComponent.ɵfac = function CardImgOverlayComponent_Factory(t) {\n    return new (t || CardImgOverlayComponent)();\n  };\n  CardImgOverlayComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardImgOverlayComponent,\n    selectors: [[\"c-card-img-overlay\"]],\n    hostVars: 2,\n    hostBindings: function CardImgOverlayComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CardImgOverlayComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return CardImgOverlayComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardLinkDirective = /*#__PURE__*/(() => {\n  class CardLinkDirective {\n    get hostClasses() {\n      return {\n        'card-link': true\n      };\n    }\n  }\n  CardLinkDirective.ɵfac = function CardLinkDirective_Factory(t) {\n    return new (t || CardLinkDirective)();\n  };\n  CardLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardLinkDirective,\n    selectors: [[\"\", \"cCardLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return CardLinkDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardSubtitleDirective = /*#__PURE__*/(() => {\n  class CardSubtitleDirective {\n    get hostClasses() {\n      return {\n        'card-subtitle': true\n      };\n    }\n  }\n  CardSubtitleDirective.ɵfac = function CardSubtitleDirective_Factory(t) {\n    return new (t || CardSubtitleDirective)();\n  };\n  CardSubtitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardSubtitleDirective,\n    selectors: [[\"\", \"cCardSubtitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return CardSubtitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardTextDirective = /*#__PURE__*/(() => {\n  class CardTextDirective {\n    get hostClasses() {\n      return {\n        'card-text': true\n      };\n    }\n  }\n  CardTextDirective.ɵfac = function CardTextDirective_Factory(t) {\n    return new (t || CardTextDirective)();\n  };\n  CardTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardTextDirective,\n    selectors: [[\"\", \"cCardText\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardTextDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return CardTextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardTitleDirective = /*#__PURE__*/(() => {\n  class CardTitleDirective {\n    get hostClasses() {\n      return {\n        'card-title': true\n      };\n    }\n  }\n  CardTitleDirective.ɵfac = function CardTitleDirective_Factory(t) {\n    return new (t || CardTitleDirective)();\n  };\n  CardTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardTitleDirective,\n    selectors: [[\"\", \"cCardTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return CardTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CardModule = /*#__PURE__*/(() => {\n  class CardModule {}\n  CardModule.ɵfac = function CardModule_Factory(t) {\n    return new (t || CardModule)();\n  };\n  CardModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CardModule\n  });\n  CardModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return CardModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IntersectionService = /*#__PURE__*/(() => {\n  class IntersectionService {\n    constructor() {\n      this.intersecting = new BehaviorSubject(false);\n      this.intersecting$ = this.intersecting.asObservable();\n      this.defaultObserverOptions = {\n        root: null,\n        rootMargin: '0px',\n        threshold: 0.2\n      };\n    }\n    createIntersectionObserver(hostElement, observerOptions = this.defaultObserverOptions) {\n      const options = {\n        ...this.defaultObserverOptions,\n        ...observerOptions\n      };\n      this.hostElement = hostElement;\n      const handleIntersect = (entries, observer) => {\n        entries.forEach(entry => {\n          this.intersecting.next(entry.isIntersecting);\n        });\n      };\n      this.intersectionObserver = new IntersectionObserver(handleIntersect, options);\n      this.intersectionObserver.observe(hostElement.nativeElement);\n    }\n    ngOnDestroy() {\n      this.intersectionObserver?.unobserve(this.hostElement?.nativeElement);\n    }\n  }\n  IntersectionService.ɵfac = function IntersectionService_Factory(t) {\n    return new (t || IntersectionService)();\n  };\n  IntersectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IntersectionService,\n    factory: IntersectionService.ɵfac\n  });\n  return IntersectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ListenersService = /*#__PURE__*/(() => {\n  class ListenersService {\n    constructor(renderer) {\n      this.renderer = renderer;\n      this.listeners = new Map();\n    }\n    setListeners({\n      hostElement,\n      trigger,\n      callbackOn,\n      callbackOff,\n      callbackToggle\n    }) {\n      const host = hostElement.nativeElement;\n      const triggers = Array.isArray(trigger) ? trigger : trigger?.split(' ') ?? [];\n      if (triggers?.includes('click')) {\n        typeof callbackToggle === 'function' && this.listeners.set('click', this.renderer.listen(host, 'click', callbackToggle));\n      }\n      if (triggers?.includes('focus')) {\n        typeof callbackOn === 'function' && this.listeners.set('focus', this.renderer.listen(host, 'focus', callbackOn));\n      }\n      if (triggers?.includes('click') || triggers?.includes('focus')) {\n        typeof callbackOff === 'function' && this.listeners.set('blur', this.renderer.listen(host, 'blur', callbackOff));\n      }\n      if (triggers?.includes('hover')) {\n        typeof callbackOn === 'function' && this.listeners.set('mouseenter', this.renderer.listen(host, 'mouseenter', callbackOn));\n        typeof callbackOff === 'function' && this.listeners.set('mouseleave', this.renderer.listen(host, 'mouseleave', callbackOff));\n      }\n    }\n    clearListeners() {\n      this.listeners.forEach((unListen, key) => {\n        unListen();\n      });\n      this.listeners.forEach((unListen, key) => {\n        // @ts-ignore\n        this.listeners.set(key, null);\n      });\n      this.listeners.clear();\n    }\n  }\n  ListenersService.ɵfac = function ListenersService_Factory(t) {\n    return new (t || ListenersService)(i0.ɵɵinject(i0.Renderer2));\n  };\n  ListenersService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ListenersService,\n    factory: ListenersService.ɵfac\n  });\n  return ListenersService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselService = /*#__PURE__*/(() => {\n  class CarouselService {\n    constructor() {\n      this.carouselIndex = new BehaviorSubject({});\n      this.carouselIndex$ = this.carouselIndex.asObservable();\n    }\n    setIndex(index) {\n      this.carouselIndex.next(index);\n    }\n  }\n  CarouselService.ɵfac = function CarouselService_Factory(t) {\n    return new (t || CarouselService)();\n  };\n  CarouselService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselService,\n    factory: CarouselService.ɵfac\n  });\n  return CarouselService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselState = /*#__PURE__*/(() => {\n  class CarouselState {\n    constructor(carouselService) {\n      this.carouselService = carouselService;\n      this._state = {\n        activeItemIndex: -1,\n        animate: true,\n        items: [],\n        direction: 'next',\n        transition: 'slide'\n      };\n    }\n    get state() {\n      return this._state;\n    }\n    set state(state) {\n      const prevState = {\n        ...this._state\n      };\n      const nextState = {\n        ...this._state,\n        ...state\n      };\n      this._state = nextState;\n      if (prevState.activeItemIndex !== nextState.activeItemIndex) {\n        const activeItemIndex = this.state.activeItemIndex || 0;\n        const itemInterval = this.state.items && this.state.items[activeItemIndex]?.interval || -1;\n        this.carouselService.setIndex({\n          active: nextState.activeItemIndex,\n          interval: itemInterval,\n          lastItemIndex: (nextState.items?.length ?? 0) - 1\n        });\n      }\n    }\n    setItems(newItems) {\n      if (newItems.length) {\n        const itemsArray = newItems.toArray();\n        itemsArray.forEach((item, i) => {\n          item.index = i;\n        });\n        this.state = {\n          items: itemsArray\n        };\n      } else {\n        this.reset();\n      }\n    }\n    setNextIndex(nextIndex) {\n      this.carouselService.setIndex(nextIndex);\n    }\n    direction(direction = 'next') {\n      this.state = {\n        direction\n      };\n      const {\n        activeItemIndex = -1,\n        items\n      } = this.state;\n      const itemsCount = items?.length ?? 0;\n      if (itemsCount > 0) {\n        return direction === 'next' ? activeItemIndex === itemsCount - 1 ? 0 : activeItemIndex + 1 : activeItemIndex === 0 ? itemsCount - 1 : activeItemIndex - 1;\n      } else {\n        return 0;\n      }\n    }\n    reset() {\n      this.state = {\n        activeItemIndex: -1,\n        animate: true,\n        items: [],\n        direction: 'next',\n        transition: 'slide'\n      };\n    }\n  }\n  CarouselState.ɵfac = function CarouselState_Factory(t) {\n    return new (t || CarouselState)(i0.ɵɵinject(CarouselService));\n  };\n  CarouselState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselState,\n    factory: CarouselState.ɵfac\n  });\n  return CarouselState;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselConfig = /*#__PURE__*/(() => {\n  class CarouselConfig {\n    constructor() {\n      /* Animate transition of slides */\n      this.activeIndex = 0;\n      /* Animate transition of slides */\n      this.animate = true;\n      /* Darken controls, indicators, and captions */\n      this.dark = false;\n      /* Default direction of auto changing of slides */\n      this.direction = 'next';\n      /* Default interval of auto changing of slides */\n      this.interval = 3000;\n    }\n  }\n  CarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n    return new (t || CarouselConfig)();\n  };\n  CarouselConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselConfig,\n    factory: CarouselConfig.ɵfac\n  });\n  return CarouselConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselComponent = /*#__PURE__*/(() => {\n  class CarouselComponent {\n    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {\n      this.config = config;\n      this.hostElement = hostElement;\n      this.carouselService = carouselService;\n      this.carouselState = carouselState;\n      this.intersectionService = intersectionService;\n      this.listenersService = listenersService;\n      /**\n       * Index of the active item.\n       * @type number\n       */\n      this.activeIndex = 0;\n      /**\n       * Carousel automatically starts cycle items.\n       * @type boolean\n       */\n      this.animate = true;\n      /**\n       * Carousel direction. [docs]\n       * @type {'next' | 'prev'}\n       */\n      this.direction = 'next';\n      /**\n       * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.\n       * @type number\n       * @default 0\n       */\n      this.interval = 0;\n      /**\n       * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.\n       * @type {'hover' | 'focus' | 'click'}\n       */\n      this.pause = 'hover';\n      /**\n       * Support left/right swipe interactions on touchscreen devices.\n       * @type boolean\n       * @default true\n       */\n      this.touch = true;\n      /**\n       * Set type of the transition.\n       * @type {'slide' | 'crossfade'}\n       * @default 'slide'\n       */\n      this.transition = 'slide';\n      /**\n       * Set whether the carousel should cycle continuously or have hard stops.\n       * @type boolean\n       * @default true\n       */\n      this.wrap = true;\n      /**\n       * Event emitted on carousel item change. [docs]\n       * @type number\n       */\n      this.itemChange = new EventEmitter();\n      this.activeItemInterval = 0;\n      this._visible = true;\n      Object.assign(this, config);\n    }\n    get hostClasses() {\n      return {\n        carousel: true,\n        slide: true,\n        'carousel-dark': !!this.dark,\n        'carousel-fade': this.transition === 'crossfade'\n      };\n    }\n    ngOnInit() {\n      this.carouselStateSubscribe();\n    }\n    ngOnDestroy() {\n      this.clearListeners();\n      this.carouselStateSubscribe(false);\n      this.intersectionServiceSubscribe(false);\n      this.swipeSubscribe(false);\n    }\n    ngAfterContentInit() {\n      this.intersectionService.createIntersectionObserver(this.hostElement);\n      this.intersectionServiceSubscribe();\n      this.carouselState.state = {\n        activeItemIndex: this.activeIndex,\n        animate: this.animate\n      };\n      this.setListeners();\n      this.swipeSubscribe();\n    }\n    setListeners() {\n      const config = {\n        hostElement: this.hostElement,\n        trigger: this.pause || [],\n        callbackOff: () => {\n          this.setTimer();\n        },\n        callbackOn: () => {\n          this.resetTimer();\n        }\n      };\n      this.listenersService.setListeners(config);\n    }\n    clearListeners() {\n      this.listenersService.clearListeners();\n    }\n    set visible(value) {\n      this._visible = value;\n    }\n    get visible() {\n      return this._visible;\n    }\n    setTimer() {\n      const interval = this.activeItemInterval || 0;\n      this.resetTimer();\n      if (interval > 0) {\n        this.timerId = setTimeout(() => {\n          const nextIndex = this.carouselState.direction(this.direction);\n          this.carouselState.state = {\n            activeItemIndex: nextIndex\n          };\n        }, interval);\n      }\n    }\n    resetTimer() {\n      clearTimeout(this.timerId);\n    }\n    carouselStateSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe(nextItem => {\n          if ('active' in nextItem) {\n            this.itemChange.emit(nextItem.active);\n          }\n          this.activeItemInterval = typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;\n          const isLastItem = nextItem.active === nextItem.lastItemIndex && this.direction === 'next' || nextItem.active === 0 && this.direction === 'prev';\n          !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();\n        });\n      } else {\n        this.carouselIndexSubscription?.unsubscribe();\n      }\n    }\n    intersectionServiceSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.intersectingSubscription = this.intersectionService.intersecting$.subscribe(isIntersecting => {\n          this.visible = isIntersecting;\n          isIntersecting ? this.setTimer() : this.resetTimer();\n        });\n      } else {\n        this.intersectingSubscription?.unsubscribe();\n      }\n    }\n    swipeSubscribe(subscribe = true) {\n      if (this.touch && subscribe) {\n        const carouselElement = this.hostElement.nativeElement;\n        const touchStart$ = fromEvent(carouselElement, 'touchstart');\n        const touchEnd$ = fromEvent(carouselElement, 'touchend');\n        const touchMove$ = fromEvent(carouselElement, 'touchmove');\n        this.swipeSubscription = touchStart$.pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$)))).subscribe(([touchstart, [touchend, touchmove]]) => {\n          touchstart.stopPropagation();\n          touchmove.stopPropagation();\n          const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;\n          if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {\n            const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');\n            this.carouselState.state = {\n              activeItemIndex: nextIndex\n            };\n          }\n        });\n      } else {\n        this.swipeSubscription?.unsubscribe();\n      }\n    }\n  }\n  CarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n    return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(CarouselService), i0.ɵɵdirectiveInject(CarouselState), i0.ɵɵdirectiveInject(IntersectionService), i0.ɵɵdirectiveInject(ListenersService));\n  };\n  CarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselComponent,\n    selectors: [[\"c-carousel\"]],\n    hostVars: 2,\n    hostBindings: function CarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      activeIndex: \"activeIndex\",\n      animate: \"animate\",\n      dark: \"dark\",\n      direction: \"direction\",\n      interval: \"interval\",\n      pause: \"pause\",\n      touch: \"touch\",\n      transition: \"transition\",\n      wrap: \"wrap\"\n    },\n    outputs: {\n      itemChange: \"itemChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([CarouselService, CarouselState, CarouselConfig, IntersectionService, ListenersService])],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return CarouselComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselCaptionComponent = /*#__PURE__*/(() => {\n  class CarouselCaptionComponent {\n    constructor() {\n      this.carouselCaptionClass = true;\n    }\n  }\n  CarouselCaptionComponent.ɵfac = function CarouselCaptionComponent_Factory(t) {\n    return new (t || CarouselCaptionComponent)();\n  };\n  CarouselCaptionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselCaptionComponent,\n    selectors: [[\"c-carousel-caption\"]],\n    hostVars: 2,\n    hostBindings: function CarouselCaptionComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"carousel-caption\", ctx.carouselCaptionClass);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CarouselCaptionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return CarouselCaptionComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselControlComponent = /*#__PURE__*/(() => {\n  class CarouselControlComponent {\n    constructor(changeDetector, carouselState) {\n      this.changeDetector = changeDetector;\n      this.carouselState = carouselState;\n      /**\n       * Carousel control direction. [docs]\n       * @type {'next' | 'prev'}\n       */\n      this.direction = 'next';\n      this.hasContent = true;\n    }\n    /**\n     * Carousel control caption. [docs]\n     * @type string\n     */\n    set caption(value) {\n      this._caption = value;\n    }\n    get caption() {\n      return !!this._caption ? this._caption : this.direction === 'prev' ? 'Previous' : 'Next';\n    }\n    get hostRole() {\n      return 'button';\n    }\n    get hostClasses() {\n      return `carousel-control-${this.direction}`;\n    }\n    get carouselControlIconClass() {\n      return `carousel-control-${this.direction}-icon`;\n    }\n    onKeyUp($event) {\n      if ($event.key === 'Enter') {\n        this.play();\n      }\n      if ($event.key === 'ArrowLeft') {\n        this.play('prev');\n      }\n      if ($event.key === 'ArrowRight') {\n        this.play('next');\n      }\n    }\n    onClick($event) {\n      this.play();\n    }\n    ngAfterViewInit() {\n      this.hasContent = this.content?.nativeElement.childNodes.length ?? false;\n      this.changeDetector.detectChanges();\n    }\n    play(direction = this.direction) {\n      const nextIndex = this.carouselState.direction(direction);\n      this.carouselState.state = {\n        activeItemIndex: nextIndex\n      };\n    }\n  }\n  CarouselControlComponent.ɵfac = function CarouselControlComponent_Factory(t) {\n    return new (t || CarouselControlComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(CarouselState));\n  };\n  CarouselControlComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselControlComponent,\n    selectors: [[\"c-carousel-control\"]],\n    viewQuery: function CarouselControlComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c3, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function CarouselControlComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keyup\", function CarouselControlComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        })(\"click\", function CarouselControlComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      caption: \"caption\",\n      direction: \"direction\"\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\", \"ngIfElse\"], [\"default\", \"\"], [\"content\", \"\"], [1, \"visually-hidden\"]],\n    template: function CarouselControlComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, CarouselControlComponent_div_0_Template, 3, 0, \"div\", 0);\n        i0.ɵɵtemplate(1, CarouselControlComponent_ng_template_1_Template, 3, 5, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasContent)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [i1$1.NgIf]\n  });\n  return CarouselControlComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselIndicatorsComponent = /*#__PURE__*/(() => {\n  class CarouselIndicatorsComponent {\n    constructor(carouselService, carouselState) {\n      this.carouselService = carouselService;\n      this.carouselState = carouselState;\n      this.items = [];\n      this.active = 0;\n    }\n    ngOnInit() {\n      this.carouselStateSubscribe();\n    }\n    ngOnDestroy() {\n      this.carouselStateSubscribe(false);\n    }\n    onClick(index) {\n      if (index !== this.active) {\n        const direction = index < this.active ? 'prev' : 'next';\n        this.carouselState.state = {\n          direction,\n          activeItemIndex: index\n        };\n      }\n    }\n    carouselStateSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe(nextIndex => {\n          this.items = this.carouselState?.state?.items?.map(item => item.index) ?? [];\n          if ('active' in nextIndex) {\n            this.active = nextIndex.active ?? 0;\n          }\n        });\n      } else {\n        this.carouselIndexSubscription?.unsubscribe();\n      }\n    }\n  }\n  CarouselIndicatorsComponent.ɵfac = function CarouselIndicatorsComponent_Factory(t) {\n    return new (t || CarouselIndicatorsComponent)(i0.ɵɵdirectiveInject(CarouselService), i0.ɵɵdirectiveInject(CarouselState));\n  };\n  CarouselIndicatorsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselIndicatorsComponent,\n    selectors: [[\"c-carousel-indicators\"]],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"carousel-indicators\"], [4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 3, \"click\"]],\n    template: function CarouselIndicatorsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, CarouselIndicatorsComponent_ng_container_1_Template, 2, 6, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    dependencies: [i1$1.NgForOf]\n  });\n  return CarouselIndicatorsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction toLeft(fromState, toState) {\n  return toState.left === true;\n}\nfunction toRight(fromState, toState) {\n  return toState.left === false;\n}\nconst slideAnimation = trigger('slideAnimation', [state('*', style({\n  transform: 'translateX(0)',\n  display: 'block',\n  opacity: 1\n})), transition(toLeft, group([query(':leave', [animate('0.6s ease-in-out', style({\n  transform: 'translateX(-100%)'\n}))], {\n  optional: true\n}), query(':enter', [style({\n  transform: 'translateX(100%)'\n}), animate('0.6s ease-in-out', style('*'))], {\n  optional: true\n})])), transition(toRight, group([query(':enter', [style({\n  transform: 'translateX(-100%)'\n}), animate('0.6s ease-in-out', style('*'))], {\n  optional: true\n}), query(':leave', [animate('0.6s ease-in-out', style({\n  transform: 'translateX(100%)'\n}))], {\n  optional: true\n})]))]);\nconst fadeAnimation = trigger('fadeAnimation', [state('*', style({\n  zIndex: 1,\n  opacity: 1\n})), transition(toLeft, group([query(':leave', [animate('0.6s ease-in-out', style({\n  zIndex: 0,\n  opacity: 0\n}))], {\n  optional: true\n}), query(':enter', [style({\n  zIndex: 1,\n  opacity: 1\n}), animate('0.6s ease-in-out', style('*'))], {\n  optional: true\n})])), transition(toRight, group([query(':enter', [style({\n  zIndex: 1,\n  opacity: 1\n}), animate('0.6s ease-in-out', style('*'))], {\n  optional: true\n}), query(':leave', [animate('0.6s ease-in-out', style({\n  zIndex: 0,\n  opacity: 0\n}))], {\n  optional: true\n})]))]);\nlet CarouselItemComponent = /*#__PURE__*/(() => {\n  class CarouselItemComponent {\n    constructor(carouselService, changeDetectorRef) {\n      this.carouselService = carouselService;\n      this.changeDetectorRef = changeDetectorRef;\n      this._active = false;\n      /**\n       * Time delay before cycling to next item. If -1, uses carousel interval value.\n       * @type number\n       * @default -1\n       */\n      this.interval = -1;\n    }\n    /**\n     * @ignore\n     */\n    set active(value) {\n      this._active = coerceBooleanProperty(value);\n      this.changeDetectorRef.markForCheck();\n    }\n    get active() {\n      return this._active;\n    }\n    get hostClasses() {\n      return {\n        'carousel-item': true,\n        active: this.active\n      };\n    }\n    ngOnDestroy() {\n      this.carouselStateSubscribe(false);\n    }\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.carouselStateSubscribe();\n      });\n    }\n    carouselStateSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe(nextIndex => {\n          if ('active' in nextIndex) {\n            this.active = nextIndex.active === this.index;\n          }\n        });\n      } else {\n        this.carouselIndexSubscription?.unsubscribe();\n      }\n    }\n  }\n  CarouselItemComponent.ɵfac = function CarouselItemComponent_Factory(t) {\n    return new (t || CarouselItemComponent)(i0.ɵɵdirectiveInject(CarouselService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  CarouselItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselItemComponent,\n    selectors: [[\"c-carousel-item\"]],\n    hostVars: 2,\n    hostBindings: function CarouselItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      interval: \"interval\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function CarouselItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, CarouselItemComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.active);\n      }\n    },\n    dependencies: [i1$1.NgIf],\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return CarouselItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselInnerComponent = /*#__PURE__*/(() => {\n  class CarouselInnerComponent {\n    constructor(carouselState) {\n      this.carouselState = carouselState;\n      this.carouselInnerClass = true;\n      this.slide = {\n        left: true\n      };\n      this.transition = 'slide';\n    }\n    ngAfterContentInit() {\n      this.setItems();\n    }\n    ngAfterContentChecked() {\n      this.setItems();\n      const state = this.carouselState?.state;\n      const nextIndex = state?.activeItemIndex;\n      const nextDirection = state?.direction;\n      if (this.activeIndex !== nextIndex) {\n        this.animate = state?.animate;\n        this.slide = {\n          left: nextDirection === 'next'\n        };\n        this.activeIndex = state?.activeItemIndex;\n        this.transition = state?.transition ?? 'slide';\n      }\n    }\n    setItems() {\n      if (this.prevContentItems !== this.contentItems) {\n        this.prevContentItems = this.contentItems;\n        this.carouselState.setItems(this.contentItems);\n      }\n    }\n  }\n  CarouselInnerComponent.ɵfac = function CarouselInnerComponent_Factory(t) {\n    return new (t || CarouselInnerComponent)(i0.ɵɵdirectiveInject(CarouselState));\n  };\n  CarouselInnerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselInnerComponent,\n    selectors: [[\"c-carousel-inner\"]],\n    contentQueries: function CarouselInnerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CarouselItemComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItems = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function CarouselInnerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"carousel-inner\", ctx.carouselInnerClass);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    template: function CarouselInnerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\");\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"@slideAnimation\", ctx.slide)(\"@.disabled\", !ctx.animate);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"],\n    data: {\n      animation: [slideAnimation, fadeAnimation]\n    }\n  });\n  return CarouselInnerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselModule = /*#__PURE__*/(() => {\n  class CarouselModule {\n    static forRoot() {\n      return {\n        ngModule: CarouselModule,\n        providers: []\n      };\n    }\n  }\n  CarouselModule.ɵfac = function CarouselModule_Factory(t) {\n    return new (t || CarouselModule)();\n  };\n  CarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CarouselModule\n  });\n  CarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [CarouselService, CarouselState, CarouselConfig],\n    imports: [CommonModule]\n  });\n  return CarouselModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownDividerDirective = /*#__PURE__*/(() => {\n  class DropdownDividerDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'dropdown-divider': true\n      };\n    }\n  }\n  DropdownDividerDirective.ɵfac = function DropdownDividerDirective_Factory(t) {\n    return new (t || DropdownDividerDirective)();\n  };\n  DropdownDividerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownDividerDirective,\n    selectors: [[\"\", \"cDropdownDivider\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DropdownDividerDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return DropdownDividerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownHeaderDirective = /*#__PURE__*/(() => {\n  class DropdownHeaderDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'dropdown-header': true\n      };\n    }\n  }\n  DropdownHeaderDirective.ɵfac = function DropdownHeaderDirective_Factory(t) {\n    return new (t || DropdownHeaderDirective)();\n  };\n  DropdownHeaderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownHeaderDirective,\n    selectors: [[\"\", \"cDropdownHeader\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DropdownHeaderDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return DropdownHeaderDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownService = /*#__PURE__*/(() => {\n  class DropdownService {\n    constructor() {\n      this.dropdownState = new BehaviorSubject({});\n      this.dropdownState$ = this.dropdownState.asObservable();\n    }\n    toggle(state) {\n      this.dropdownState.next(state);\n    }\n  }\n  DropdownService.ɵfac = function DropdownService_Factory(t) {\n    return new (t || DropdownService)();\n  };\n  DropdownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DropdownService,\n    factory: DropdownService.ɵfac\n  });\n  return DropdownService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownMenuDirective = /*#__PURE__*/(() => {\n  class DropdownMenuDirective {\n    constructor(elementRef, dropdownService) {\n      this.elementRef = elementRef;\n      this.dropdownService = dropdownService;\n      /**\n       * Toggle the visibility of dropdown menu component.\n       */\n      this.visible = false;\n      this._dark = false;\n    }\n    /**\n     * Sets a darker color scheme to match a dark navbar.\n     */\n    get dark() {\n      return this._dark;\n    }\n    set dark(value) {\n      this._dark = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        'dropdown-menu': true,\n        'dropdown-menu-dark': this.dark,\n        [`dropdown-menu-${this.alignment}`]: !!this.alignment,\n        show: this.visible\n      };\n    }\n    get hostStyles() {\n      // workaround for popper position calculate (see also: dropdown.component)\n      return {\n        visibility: this.visible ? null : '',\n        display: this.visible ? null : ''\n      };\n    }\n    ngOnInit() {\n      this.dropdownStateSubscribe();\n    }\n    ngOnDestroy() {\n      this.dropdownStateSubscribe(false);\n    }\n    dropdownStateSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.dropdownStateSubscription = this.dropdownService.dropdownState$.subscribe(state => {\n          if ('visible' in state) {\n            this.visible = state.visible === 'toggle' ? !this.visible : state.visible;\n          }\n        });\n      } else {\n        this.dropdownStateSubscription.unsubscribe();\n      }\n    }\n  }\n  DropdownMenuDirective.ɵfac = function DropdownMenuDirective_Factory(t) {\n    return new (t || DropdownMenuDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DropdownService));\n  };\n  DropdownMenuDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownMenuDirective,\n    selectors: [[\"\", \"cDropdownMenu\", \"\"]],\n    hostVars: 4,\n    hostBindings: function DropdownMenuDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleMap(ctx.hostStyles);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      visible: \"visible\",\n      dark: \"dark\"\n    },\n    exportAs: [\"cDropdownMenu\"]\n  });\n  return DropdownMenuDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// lightweight injection token\nclass DropdownToken {}\nlet DropdownToggleDirective = /*#__PURE__*/(() => {\n  class DropdownToggleDirective {\n    constructor(elementRef, dropdownService, dropdown) {\n      this.elementRef = elementRef;\n      this.dropdownService = dropdownService;\n      this.dropdown = dropdown;\n      /**\n       * Disables the toggler.\n       * @type boolean\n       * @default false\n       */\n      this.disabled = false;\n      /**\n       * Enables pseudo element caret on toggler.\n       * @type boolean\n       */\n      this.caret = true;\n      this._split = false;\n    }\n    /**\n     * Create split button dropdowns with virtually the same markup as single button dropdowns, but with the addition of `.dropdown-toggle-split` class for proper spacing around the dropdown caret.\n     * @type boolean\n     */\n    set split(value) {\n      this._split = coerceBooleanProperty(value);\n    }\n    get split() {\n      return this._split;\n    }\n    get hostClasses() {\n      return {\n        'dropdown-toggle': this.caret,\n        'dropdown-toggle-split': this.split,\n        disabled: this.disabled\n      };\n    }\n    onClick($event) {\n      $event.preventDefault();\n      !this.disabled && this.dropdownService.toggle({\n        visible: 'toggle',\n        dropdown: this.dropdown\n      });\n    }\n    ngAfterViewInit() {\n      if (this.dropdownComponent) {\n        this.dropdown = this.dropdownComponent;\n        this.dropdownService = this.dropdownComponent?.dropdownService;\n      }\n    }\n  }\n  DropdownToggleDirective.ɵfac = function DropdownToggleDirective_Factory(t) {\n    return new (t || DropdownToggleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DropdownService), i0.ɵɵdirectiveInject(DropdownToken, 8));\n  };\n  DropdownToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownToggleDirective,\n    selectors: [[\"\", \"cDropdownToggle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DropdownToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function DropdownToggleDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      dropdownComponent: \"dropdownComponent\",\n      disabled: \"disabled\",\n      caret: \"caret\",\n      split: \"split\"\n    },\n    exportAs: [\"cDropdownToggle\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DropdownToken,\n      useExisting: forwardRef(() => DropdownComponent)\n    }])]\n  });\n  return DropdownToggleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownComponent = /*#__PURE__*/(() => {\n  class DropdownComponent {\n    constructor(document, elementRef, renderer, ngZone, changeDetectorRef, dropdownService) {\n      this.document = document;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetectorRef = changeDetectorRef;\n      this.dropdownService = dropdownService;\n      this.autoClose = true;\n      this._dark = false;\n      /**\n       * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.\n       * @type Placement\n       */\n      this.placement = 'bottom-start';\n      this._popper = true;\n      this._popperOptions = {\n        placement: this.placement,\n        modifiers: [],\n        strategy: 'absolute'\n      };\n      /**\n       * Set the dropdown variant to a btn-group, dropdown, input-group, and nav-item.\n       */\n      this.variant = 'dropdown';\n      this._visible = false;\n      this.visibleChange = new EventEmitter();\n      this.dropdownContext = {\n        $implicit: this.visible\n      };\n      this.activeTrap = false;\n      this.listeners = [];\n      this.dropdownStateSubscribe();\n    }\n    /**\n     * Sets a darker color scheme to match a dark navbar.\n     * @type boolean\n     * @default false\n     */\n    set dark(value) {\n      this._dark = coerceBooleanProperty(value);\n    }\n    get dark() {\n      return this._dark;\n    }\n    /**\n     * If you want to disable dynamic positioning set this property to `false`.\n     * @type boolean\n     * @default true\n     */\n    set popper(value) {\n      this._popper = coerceBooleanProperty(value);\n    }\n    get popper() {\n      return this._popper;\n    }\n    /**\n     * Optional popper Options object, placement prop takes precedence over\n     * @type Partial<Options>\n     */\n    set popperOptions(value) {\n      this._popperOptions = {\n        ...this._popperOptions,\n        ...value\n      };\n    }\n    get popperOptions() {\n      let placement = this.placement;\n      switch (this.direction) {\n        case 'dropup':\n          {\n            placement = 'top-start';\n            break;\n          }\n        case 'dropend':\n          {\n            placement = 'right-start';\n            break;\n          }\n        case 'dropstart':\n          {\n            placement = 'left-start';\n            break;\n          }\n        case 'center':\n          {\n            placement = 'bottom';\n            break;\n          }\n        case 'dropup-center':\n          {\n            placement = 'top';\n            break;\n          }\n      }\n      if (this.alignment === 'end') {\n        placement = 'bottom-end';\n      }\n      this._popperOptions = {\n        ...this._popperOptions,\n        placement: placement\n      };\n      return this._popperOptions;\n    }\n    /**\n     * Toggle the visibility of dropdown menu component.\n     * @type boolean\n     * @default false\n     */\n    set visible(value) {\n      const _value = coerceBooleanProperty(value);\n      if (_value !== this._visible) {\n        this.activeTrap = _value;\n        this._visible = _value;\n        _value ? this.createPopperInstance() : this.destroyPopperInstance();\n        this.visibleChange.emit(_value);\n      }\n    }\n    get visible() {\n      return this._visible;\n    }\n    get hostClasses() {\n      return {\n        dropdown: (this.variant === 'dropdown' || this.variant === 'nav-item') && !this.direction,\n        [`${this.direction}`]: !!this.direction,\n        [`${this.variant}`]: !!this.variant,\n        'dropup': this.direction === 'dropup' || this.direction === 'dropup-center',\n        show: this.visible\n      };\n    }\n    // todo: find better solution\n    get hostStyle() {\n      return this.variant === 'input-group' ? {\n        display: 'contents'\n      } : {};\n    }\n    onHostClick($event) {\n      this.clickedTarget = $event.target;\n    }\n    dropdownStateSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.dropdownStateSubscription = this.dropdownService.dropdownState$.pipe(filter(state => {\n          return this === state.dropdown;\n        })).subscribe(state => {\n          if ('visible' in state) {\n            state?.visible === 'toggle' ? this.toggleDropdown() : this.visible = state.visible;\n          }\n        });\n      } else {\n        this.dropdownStateSubscription.unsubscribe();\n      }\n    }\n    toggleDropdown() {\n      this.visible = !this.visible;\n    }\n    onClick(event) {\n      if (!this._toggler?.elementRef.nativeElement.contains(event.target?.closest('[cDropdownToggle]'))) {\n        this.toggleDropdown();\n      }\n    }\n    ngAfterContentInit() {\n      if (this.variant === 'nav-item') {\n        this.renderer.addClass(this._toggler.elementRef.nativeElement, 'nav-link');\n      }\n    }\n    ngOnInit() {\n      this.setVisibleState(this.visible);\n    }\n    ngOnChanges(changes) {\n      if (changes['visible'] && !changes['visible'].firstChange) {\n        this.setVisibleState(changes['visible'].currentValue);\n      }\n    }\n    ngOnDestroy() {\n      this.clearListeners();\n      this.dropdownStateSubscribe(false);\n      this.destroyPopperInstance();\n    }\n    setVisibleState(value) {\n      this.dropdownService.toggle({\n        visible: value,\n        dropdown: this\n      });\n    }\n    // todo: turn off popper in navbar-nav\n    createPopperInstance() {\n      if (this._toggler && this._menu) {\n        this.ngZone.runOutsideAngular(() => {\n          // workaround for popper position calculate (see also: dropdown-menu.component)\n          this._menu.elementRef.nativeElement.style.visibility = 'hidden';\n          this._menu.elementRef.nativeElement.style.display = 'block';\n          if (this.popper) {\n            this.popperInstance = createPopper(this._toggler.elementRef.nativeElement, this._menu.elementRef.nativeElement, {\n              ...this.popperOptions\n            });\n          }\n          this.ngZone.run(() => {\n            this.setListeners();\n            this.changeDetectorRef.markForCheck();\n            this.changeDetectorRef.detectChanges();\n          });\n        });\n      }\n    }\n    destroyPopperInstance() {\n      this.clearListeners();\n      this.popperInstance?.destroy();\n      this.popperInstance = undefined;\n      this.changeDetectorRef.markForCheck();\n    }\n    setListeners() {\n      this.listeners.push(this.renderer.listen(this.document, 'click', event => {\n        const target = event.target;\n        if (this._menuElementRef?.nativeElement.contains(event.target)) {\n          this.clickedTarget = target;\n        }\n        if (this._toggler?.elementRef.nativeElement.contains(event.target)) {\n          return;\n        }\n        if (this.autoClose === true) {\n          this.setVisibleState(false);\n          return;\n        }\n        if (this.clickedTarget === target && this.autoClose === 'inside') {\n          this.setVisibleState(false);\n          return;\n        }\n        if (this.clickedTarget !== target && this.autoClose === 'outside') {\n          this.setVisibleState(false);\n          return;\n        }\n      }));\n      this.listeners.push(this.renderer.listen(this.elementRef.nativeElement, 'keyup', event => {\n        if (event.key === 'Escape' && this.autoClose !== false) {\n          event.stopPropagation();\n          this.setVisibleState(false);\n          return;\n        }\n      }));\n      this.listeners.push(this.renderer.listen(this.document, 'keyup', event => {\n        if (event.key === 'Tab' && this.autoClose !== false && !this.elementRef.nativeElement.contains(event.target)) {\n          this.setVisibleState(false);\n          return;\n        }\n      }));\n    }\n    clearListeners() {\n      this.listeners.forEach(unListen => {\n        unListen();\n      });\n      // @ts-ignore\n      this.listeners.fill(undefined);\n      this.listeners = [];\n    }\n  }\n  DropdownComponent.ɵfac = function DropdownComponent_Factory(t) {\n    return new (t || DropdownComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DropdownService));\n  };\n  DropdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropdownComponent,\n    selectors: [[\"c-dropdown\"]],\n    contentQueries: function DropdownComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DropdownToggleDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DropdownMenuDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DropdownMenuDirective, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._toggler = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menu = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menuElementRef = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function DropdownComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function DropdownComponent_click_HostBindingHandler($event) {\n          return ctx.onHostClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleMap(ctx.hostStyle);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      autoClose: \"autoClose\",\n      dark: \"dark\",\n      direction: \"direction\",\n      placement: \"placement\",\n      popper: \"popper\",\n      popperOptions: \"popperOptions\",\n      variant: \"variant\",\n      visible: \"visible\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\"\n    },\n    exportAs: [\"cDropdown\"],\n    features: [i0.ɵɵProvidersFeature([DropdownService]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function DropdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\".dropdown[_nghost-%COMP%]:not(.btn-group), .dropdown   [_nghost-%COMP%]:not(.btn-group), .dropup[_nghost-%COMP%]:not(.btn-group), .dropup   [_nghost-%COMP%]:not(.btn-group){display:block;min-width:-moz-fit-content;min-width:fit-content}.dropstart[_nghost-%COMP%]:not(.btn-group), .dropstart   [_nghost-%COMP%]:not(.btn-group), .dropend[_nghost-%COMP%]:not(.btn-group), .dropend   [_nghost-%COMP%]:not(.btn-group){display:inline-flex}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:first-child  :first-child, html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:first-child  :first-child, .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:first-child  :first-child{border-top-right-radius:0;border-bottom-right-radius:0}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu), html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu), .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu):not(:only-of-type), html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu):not(:only-of-type), .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:last-child  :first-child, html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:last-child  :first-child, .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:last-child  :first-child{border-top-left-radius:0;border-bottom-left-radius:0}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:last-child  :first-child:not(:only-of-type), html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:last-child  :first-child:not(:only-of-type), .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:last-child  :first-child:not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}html:not([dir=rtl]).input-group   [_nghost-%COMP%]:last-child  :not(:first-child):not(.dropdown-menu), html:not([dir=rtl])   .input-group   [_nghost-%COMP%]:last-child  :not(:first-child):not(.dropdown-menu), .input-group   html:not([dir=rtl])   [_nghost-%COMP%]:last-child  :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]{direction:rtl}[dir=rtl]   .input-group   [_nghost-%COMP%]:first-child  :first-child{border-top-left-radius:0;border-bottom-left-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]:first-child  :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]:last-child  :first-child{border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]:last-child  :first-child:not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}[dir=rtl]   .input-group   [_nghost-%COMP%]:last-child  :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}\"]\n  });\n  return DropdownComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownItemDirective = /*#__PURE__*/(() => {\n  class DropdownItemDirective {\n    constructor(dropdownService, dropdown) {\n      this.dropdownService = dropdownService;\n      this.dropdown = dropdown;\n      /**\n       * Configure dropdown-item close dropdown behavior.\n       * @type boolean\n       * @default true\n       */\n      this.autoClose = true;\n      this._tabIndex = null;\n    }\n    get ariaCurrent() {\n      return this.active ? 'true' : null;\n    }\n    get hostClasses() {\n      return {\n        'dropdown-item': true,\n        active: this.active,\n        disabled: this.disabled\n      };\n    }\n    set tabIndex(value) {\n      this._tabIndex = value;\n    }\n    get tabIndex() {\n      return this.disabled ? '-1' : this._tabIndex;\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    onClick($event) {\n      if (this.autoClose) {\n        this.dropdownService.toggle({\n          visible: 'toggle',\n          dropdown: this.dropdown\n        });\n      }\n    }\n    onKeyUp($event) {\n      if ($event.key === 'Enter') {\n        if (this.autoClose) {\n          this.dropdownService.toggle({\n            visible: false,\n            dropdown: this.dropdown\n          });\n        }\n      }\n    }\n  }\n  DropdownItemDirective.ɵfac = function DropdownItemDirective_Factory(t) {\n    return new (t || DropdownItemDirective)(i0.ɵɵdirectiveInject(DropdownService), i0.ɵɵdirectiveInject(DropdownComponent, 8));\n  };\n  DropdownItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownItemDirective,\n    selectors: [[\"\", \"cDropdownItem\", \"\"]],\n    hostVars: 5,\n    hostBindings: function DropdownItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function DropdownItemDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keyup\", function DropdownItemDirective_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-current\", ctx.ariaCurrent)(\"tabindex\", ctx.tabIndex)(\"aria-disabled\", ctx.isDisabled);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      autoClose: \"autoClose\",\n      disabled: \"disabled\",\n      tabIndex: \"tabIndex\"\n    },\n    exportAs: [\"cDropdownItem\"]\n  });\n  return DropdownItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownItemPlainDirective = /*#__PURE__*/(() => {\n  class DropdownItemPlainDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'dropdown-item-text': true\n      };\n    }\n  }\n  DropdownItemPlainDirective.ɵfac = function DropdownItemPlainDirective_Factory(t) {\n    return new (t || DropdownItemPlainDirective)();\n  };\n  DropdownItemPlainDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownItemPlainDirective,\n    selectors: [[\"\", \"cDropdownItemPlain\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DropdownItemPlainDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return DropdownItemPlainDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownCloseDirective = /*#__PURE__*/(() => {\n  class DropdownCloseDirective {\n    constructor(dropdownService, dropdown) {\n      this.dropdownService = dropdownService;\n      this.dropdown = dropdown;\n      this._tabIndex = null;\n    }\n    ngAfterViewInit() {\n      if (this.dropdownComponent) {\n        this.dropdown = this.dropdownComponent;\n        this.dropdownService = this.dropdownComponent?.dropdownService;\n      }\n    }\n    get hostClasses() {\n      return {\n        disabled: this.disabled\n      };\n    }\n    set tabIndex(value) {\n      this._tabIndex = value;\n    }\n    get tabIndex() {\n      return this.disabled ? '-1' : this._tabIndex;\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    onClick($event) {\n      !this.disabled && this.dropdownService.toggle({\n        visible: false,\n        dropdown: this.dropdown\n      });\n    }\n    onKeyUp($event) {\n      if ($event.key === 'Enter') {\n        !this.disabled && this.dropdownService.toggle({\n          visible: false,\n          dropdown: this.dropdown\n        });\n      }\n    }\n  }\n  DropdownCloseDirective.ɵfac = function DropdownCloseDirective_Factory(t) {\n    return new (t || DropdownCloseDirective)(i0.ɵɵdirectiveInject(DropdownService), i0.ɵɵdirectiveInject(DropdownComponent, 8));\n  };\n  DropdownCloseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropdownCloseDirective,\n    selectors: [[\"\", \"cDropdownClose\", \"\"]],\n    hostVars: 4,\n    hostBindings: function DropdownCloseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function DropdownCloseDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keyup\", function DropdownCloseDirective_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex)(\"aria-disabled\", ctx.isDisabled);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      dropdownComponent: \"dropdownComponent\",\n      tabIndex: \"tabIndex\"\n    },\n    exportAs: [\"cDropdownClose\"]\n  });\n  return DropdownCloseDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DropdownModule = /*#__PURE__*/(() => {\n  class DropdownModule {}\n  DropdownModule.ɵfac = function DropdownModule_Factory(t) {\n    return new (t || DropdownModule)();\n  };\n  DropdownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DropdownModule\n  });\n  DropdownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DropdownService],\n    imports: [CommonModule]\n  });\n  return DropdownModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FooterComponent = /*#__PURE__*/(() => {\n  class FooterComponent {\n    constructor() {\n      /**\n       * Default role for footer. [docs]\n       * @type string\n       * @default 'footer'\n       */\n      this.role = 'footer';\n    }\n    get getClasses() {\n      return {\n        footer: true,\n        [`footer-${this.position}`]: !!this.position\n      };\n    }\n  }\n  FooterComponent.ɵfac = function FooterComponent_Factory(t) {\n    return new (t || FooterComponent)();\n  };\n  FooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FooterComponent,\n    selectors: [[\"c-footer\"], [\"\", \"cFooter\", \"\"]],\n    hostVars: 3,\n    hostBindings: function FooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.getClasses);\n      }\n    },\n    inputs: {\n      position: \"position\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function FooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return FooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FooterModule = /*#__PURE__*/(() => {\n  class FooterModule {}\n  FooterModule.ɵfac = function FooterModule_Factory(t) {\n    return new (t || FooterModule)();\n  };\n  FooterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FooterModule\n  });\n  FooterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return FooterModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormDirective = /*#__PURE__*/(() => {\n  class FormDirective {\n    constructor() {\n      this._validated = false;\n    }\n    /**\n     * Mark a form as validated. If you set it `true`, all validation styles will be applied to the form. [docs]\n     * @type boolean\n     * @default false\n     */\n    set validated(value) {\n      this._validated = coerceBooleanProperty(value);\n    }\n    get validated() {\n      return this._validated;\n    }\n    get hostClasses() {\n      return {\n        'was-validated': this.validated\n      };\n    }\n  }\n  FormDirective.ɵfac = function FormDirective_Factory(t) {\n    return new (t || FormDirective)();\n  };\n  FormDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormDirective,\n    selectors: [[\"form\", \"cForm\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      validated: \"validated\"\n    }\n  });\n  return FormDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormFeedbackComponent = /*#__PURE__*/(() => {\n  class FormFeedbackComponent {\n    constructor() {\n      /**\n       * If your form layout allows it, you can display validation feedback in a styled tooltip.\n       */\n      this._tooltip = false;\n    }\n    set tooltip(value) {\n      this._tooltip = coerceBooleanProperty(value);\n    }\n    get tooltip() {\n      return this._tooltip;\n    }\n    get hostClasses() {\n      return {\n        'valid-feedback': this.valid === true && !this.tooltip,\n        'valid-tooltip': this.valid === true && this.tooltip,\n        'invalid-feedback': this.valid !== true && !this.tooltip,\n        'invalid-tooltip': this.valid !== true && this.tooltip\n      };\n    }\n  }\n  FormFeedbackComponent.ɵfac = function FormFeedbackComponent_Factory(t) {\n    return new (t || FormFeedbackComponent)();\n  };\n  FormFeedbackComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormFeedbackComponent,\n    selectors: [[\"c-form-feedback\"]],\n    hostVars: 2,\n    hostBindings: function FormFeedbackComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      tooltip: \"tooltip\",\n      valid: \"valid\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function FormFeedbackComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return FormFeedbackComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InputGroupComponent = /*#__PURE__*/(() => {\n  class InputGroupComponent {\n    constructor() {\n      /**\n       * Size the component small or large.\n       */\n      this.sizing = '';\n    }\n    get hostClasses() {\n      return {\n        'input-group': true,\n        [`input-group-${this.sizing}`]: !!this.sizing\n      };\n    }\n  }\n  InputGroupComponent.ɵfac = function InputGroupComponent_Factory(t) {\n    return new (t || InputGroupComponent)();\n  };\n  InputGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: InputGroupComponent,\n    selectors: [[\"c-input-group\"]],\n    hostVars: 2,\n    hostBindings: function InputGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      sizing: \"sizing\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function InputGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return InputGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormSelectDirective = /*#__PURE__*/(() => {\n  class FormSelectDirective {\n    constructor() {\n      /**\n       * Size the component small or large.\n       */\n      this.sizing = '';\n    }\n    get hostClasses() {\n      return {\n        'form-select': true,\n        [`form-select-${this.sizing}`]: !!this.sizing,\n        'is-valid': this.valid === true,\n        'is-invalid': this.valid === false\n      };\n    }\n  }\n  FormSelectDirective.ɵfac = function FormSelectDirective_Factory(t) {\n    return new (t || FormSelectDirective)();\n  };\n  FormSelectDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormSelectDirective,\n    selectors: [[\"select\", \"cSelect\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormSelectDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      sizing: \"sizing\",\n      valid: \"valid\"\n    }\n  });\n  return FormSelectDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormLabelDirective = /*#__PURE__*/(() => {\n  class FormLabelDirective {\n    constructor() {\n      /**\n       * For horizontal forms set labels to 'col' and make them vertically centered with their associated form controls.\n       * @type 'col'\n       */\n      this.col = '';\n      /**\n       * Size the label small or large.\n       */\n      this.sizing = '';\n    }\n    get hostClasses() {\n      return {\n        'form-label': true,\n        'col-form-label': this.col === 'col',\n        [`col-form-label-${this.sizing}`]: !!this.sizing && this.col === 'col'\n      };\n    }\n  }\n  FormLabelDirective.ɵfac = function FormLabelDirective_Factory(t) {\n    return new (t || FormLabelDirective)();\n  };\n  FormLabelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormLabelDirective,\n    selectors: [[\"\", \"cLabel\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormLabelDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      col: [\"cLabel\", \"col\"],\n      sizing: \"sizing\"\n    }\n  });\n  return FormLabelDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormCheckLabelDirective = /*#__PURE__*/(() => {\n  class FormCheckLabelDirective {\n    get hostClasses() {\n      return {\n        'form-check-label': true\n      };\n    }\n  }\n  FormCheckLabelDirective.ɵfac = function FormCheckLabelDirective_Factory(t) {\n    return new (t || FormCheckLabelDirective)();\n  };\n  FormCheckLabelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormCheckLabelDirective,\n    selectors: [[\"label\", \"cFormCheckLabel\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormCheckLabelDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return FormCheckLabelDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormCheckComponent = /*#__PURE__*/(() => {\n  class FormCheckComponent {\n    constructor() {\n      this._inline = false;\n      /**\n       * Size the component large or extra large. Works only with `[switch]=\"true\"` [docs]\n       * @type {'lg' | 'xl' | ''}\n       */\n      this.sizing = '';\n      this._switch = false;\n      this._formCheckClass = true;\n    }\n    /**\n     * Group checkboxes or radios on the same horizontal row.\n     * @type boolean\n     * @default false\n     */\n    set inline(value) {\n      this._inline = coerceBooleanProperty(value);\n    }\n    get inline() {\n      return this._inline;\n    }\n    /**\n    * Render a toggle switch on for checkbox.\n    * @type boolean\n    * @default false\n    */\n    set switch(value) {\n      this._switch = coerceBooleanProperty(value);\n    }\n    get switch() {\n      return this._switch;\n    }\n    get hostClasses() {\n      return {\n        'form-check': this.formCheckClass,\n        'form-switch': this.switch,\n        [`form-switch-${this.sizing}`]: this.switch && !!this.sizing,\n        'form-check-inline': this.inline\n      };\n    }\n    get formCheckClass() {\n      return this._formCheckClass;\n    }\n    ngAfterContentInit() {\n      this._formCheckClass = !!this.formCheckLabel;\n    }\n  }\n  FormCheckComponent.ɵfac = function FormCheckComponent_Factory(t) {\n    return new (t || FormCheckComponent)();\n  };\n  FormCheckComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormCheckComponent,\n    selectors: [[\"c-form-check\"]],\n    contentQueries: function FormCheckComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FormCheckLabelDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.formCheckLabel = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function FormCheckComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      inline: \"inline\",\n      sizing: \"sizing\",\n      switch: \"switch\"\n    },\n    exportAs: [\"cFormCheck\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function FormCheckComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return FormCheckComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormCheckInputDirective = /*#__PURE__*/(() => {\n  class FormCheckInputDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      /**\n       * Specifies the type of component.\n       * @type {'checkbox' | 'radio'}\n       * @default 'checkbox'\n       */\n      this.type = 'checkbox';\n      this._indeterminate = false;\n    }\n    /**\n     * Set component indeterminate state.\n     * @type boolean\n     */\n    set indeterminate(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (this._indeterminate !== newValue) {\n        this._indeterminate = newValue;\n        this.renderer.setProperty(this.hostElement.nativeElement, 'indeterminate', newValue);\n      }\n    }\n    get indeterminate() {\n      return this._indeterminate;\n    }\n    get hostClasses() {\n      return {\n        'form-check-input': true,\n        'is-valid': this.valid === true,\n        'is-invalid': this.valid === false\n      };\n    }\n    get checked() {\n      return this.hostElement?.nativeElement?.checked;\n    }\n  }\n  FormCheckInputDirective.ɵfac = function FormCheckInputDirective_Factory(t) {\n    return new (t || FormCheckInputDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  FormCheckInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormCheckInputDirective,\n    selectors: [[\"input\", \"cFormCheckInput\", \"\"]],\n    hostVars: 3,\n    hostBindings: function FormCheckInputDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      type: \"type\",\n      indeterminate: \"indeterminate\",\n      valid: \"valid\"\n    }\n  });\n  return FormCheckInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormControlDirective = /*#__PURE__*/(() => {\n  class FormControlDirective {\n    constructor(hostElement) {\n      this.hostElement = hostElement;\n      /**\n       * Size the component small or large.\n       * @type {'sm' | 'lg'}\n       */\n      this.sizing = '';\n      /**\n       * Specifies the type of input element.\n       */\n      this.type = 'text';\n      this._plaintext = false;\n    }\n    /**\n     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use alongside `readonly` [docs]\n     */\n    set plaintext(value) {\n      this._plaintext = coerceBooleanProperty(value);\n    }\n    get plaintext() {\n      return this._plaintext;\n    }\n    get hostClasses() {\n      const isRangeType = this.type === 'range';\n      return {\n        'form-control': !isRangeType && !this.plaintext,\n        'form-control-plaintext': !isRangeType && this.plaintext,\n        'form-control-color': this.type === 'color',\n        'form-range': isRangeType,\n        [`form-control-${this.sizing}`]: !!this.sizing && !isRangeType,\n        'is-valid': this.valid === true,\n        'is-invalid': this.valid === false\n      };\n    }\n    get hostTag() {\n      return this.hostElement.nativeElement.tagName;\n    }\n    ngOnInit() {\n      const hostTag = this.hostTag.toLowerCase();\n      if (hostTag !== 'input' && hostTag !== 'textarea') {\n        console.warn(`CoreUI [cFormControl] works with '<input>' and '<texarea>' - not with '<${hostTag}>'`);\n      }\n    }\n  }\n  FormControlDirective.ɵfac = function FormControlDirective_Factory(t) {\n    return new (t || FormControlDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  FormControlDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormControlDirective,\n    selectors: [[\"input\", \"cFormControl\", \"\"], [\"textarea\", \"cFormControl\", \"\"]],\n    hostVars: 3,\n    hostBindings: function FormControlDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      sizing: \"sizing\",\n      valid: \"valid\",\n      type: \"type\",\n      plaintext: \"plaintext\"\n    }\n  });\n  return FormControlDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormTextDirective = /*#__PURE__*/(() => {\n  class FormTextDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'form-text': true\n      };\n    }\n  }\n  FormTextDirective.ɵfac = function FormTextDirective_Factory(t) {\n    return new (t || FormTextDirective)();\n  };\n  FormTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormTextDirective,\n    selectors: [[\"\", \"cFormText\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormTextDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return FormTextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormFloatingDirective = /*#__PURE__*/(() => {\n  class FormFloatingDirective {\n    constructor() {\n      this._floating = true;\n    }\n    /**\n     * Enable floating labels\n     * @type boolean\n     */\n    get floating() {\n      return this._floating;\n    }\n    set floating(value) {\n      this._floating = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        'form-floating': this.floating\n      };\n    }\n  }\n  FormFloatingDirective.ɵfac = function FormFloatingDirective_Factory(t) {\n    return new (t || FormFloatingDirective)();\n  };\n  FormFloatingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormFloatingDirective,\n    selectors: [[\"\", \"cFormFloating\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FormFloatingDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      floating: [\"cFormFloating\", \"floating\"]\n    }\n  });\n  return FormFloatingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InputGroupTextDirective = /*#__PURE__*/(() => {\n  class InputGroupTextDirective {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'input-group-text': true\n      };\n    }\n  }\n  InputGroupTextDirective.ɵfac = function InputGroupTextDirective_Factory(t) {\n    return new (t || InputGroupTextDirective)();\n  };\n  InputGroupTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InputGroupTextDirective,\n    selectors: [[\"\", \"cInputGroupText\", \"\"]],\n    hostVars: 2,\n    hostBindings: function InputGroupTextDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return InputGroupTextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormModule = /*#__PURE__*/(() => {\n  class FormModule {}\n  FormModule.ɵfac = function FormModule_Factory(t) {\n    return new (t || FormModule)();\n  };\n  FormModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FormModule\n  });\n  FormModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return FormModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ContainerComponent = /*#__PURE__*/(() => {\n  class ContainerComponent {\n    constructor() {\n      /**\n       * Set container 100% wide until a breakpoint.\n       */\n      this.breakpoint = '';\n      this._fluid = false;\n    }\n    /**\n     * Set container 100% wide, spanning the entire width of the viewport.\n     */\n    set fluid(value) {\n      this._fluid = coerceBooleanProperty(value);\n    }\n    get fluid() {\n      return this._fluid;\n    }\n    get hostClasses() {\n      return {\n        container: !this.fluid && !this.breakpoint,\n        'container-fluid': this.fluid,\n        [`container-${this.breakpoint}`]: !!this.breakpoint\n      };\n    }\n  }\n  ContainerComponent.ɵfac = function ContainerComponent_Factory(t) {\n    return new (t || ContainerComponent)();\n  };\n  ContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ContainerComponent,\n    selectors: [[\"c-container\"], [\"\", \"cContainer\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      breakpoint: \"breakpoint\",\n      fluid: \"fluid\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return ContainerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ColDirective = /*#__PURE__*/(() => {\n  class ColDirective {\n    constructor() {\n      this._xs = false;\n      this._sm = false;\n      this._md = false;\n      this._lg = false;\n      this._xl = false;\n      this._xxl = false;\n    }\n    /**\n     * The number of columns/offset/order on extra small devices (<576px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set cCol(value) {\n      this.xs = this.xs || this.coerceInput(value);\n    }\n    set xs(value) {\n      this._xs = this.coerceInput(value);\n    }\n    get xs() {\n      return this._xs;\n    }\n    /**\n     * The number of columns/offset/order on small devices (<768px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set sm(value) {\n      this._sm = this.coerceInput(value);\n    }\n    get sm() {\n      return this._sm;\n    }\n    /**\n     * The number of columns/offset/order on medium devices (<992px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set md(value) {\n      this._md = this.coerceInput(value);\n    }\n    get md() {\n      return this._md;\n    }\n    /**\n     * The number of columns/offset/order on large devices (<1200px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set lg(value) {\n      this._lg = this.coerceInput(value);\n    }\n    get lg() {\n      return this._lg;\n    }\n    /**\n     * The number of columns/offset/order on X-Large devices (<1400px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set xl(value) {\n      this._xl = this.coerceInput(value);\n    }\n    get xl() {\n      return this._xl;\n    }\n    /**\n     * The number of columns/offset/order on XX-Large devices (≥1400px).\n     * @type { 'auto' | number |  boolean }\n     */\n    set xxl(value) {\n      this._xxl = this.coerceInput(value);\n    }\n    get xxl() {\n      return this._xxl;\n    }\n    get hostClasses() {\n      const classes = {\n        col: true\n      };\n      Object.keys(BreakpointInfix).forEach(breakpoint => {\n        // @ts-ignore\n        const value = this[breakpoint];\n        const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;\n        classes[`col${infix}`] = value === true;\n        classes[`col${infix}-${value}`] = typeof value === 'number' || typeof value === 'string';\n      });\n      if (typeof this.offset === 'object') {\n        const offset = {\n          ...this.offset\n        };\n        Object.entries(offset).forEach(entry => {\n          const [breakpoint, value] = [...entry];\n          const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;\n          classes[`offset${infix}-${value}`] = value >= 0 && value <= 11;\n        });\n      } else {\n        classes[`offset-${this.offset}`] = typeof this.offset === 'number' && this.offset > 0 && this.offset <= 11;\n      }\n      if (typeof this.order === 'object') {\n        const order = {\n          ...this.order\n        };\n        Object.entries(order).forEach(entry => {\n          const [breakpoint, value] = [...entry];\n          const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;\n          classes[`order${infix}-${value}`] = value;\n        });\n      } else {\n        classes[`order-${this.order}`] = !!this.order;\n      }\n      // if there is no 'col' class, add one\n      classes.col = !Object.entries(classes).filter(i => i[0].startsWith('col-') && i[1]).length || this.xs === true;\n      return classes;\n    }\n    coerceInput(value) {\n      if (value === 'auto') {\n        return value;\n      }\n      if (value === '' || value === undefined || value === null) {\n        return coerceBooleanProperty(value);\n      }\n      if (typeof value === 'boolean') {\n        return value;\n      }\n      return coerceNumberProperty(value);\n    }\n  }\n  ColDirective.ɵfac = function ColDirective_Factory(t) {\n    return new (t || ColDirective)();\n  };\n  ColDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColDirective,\n    selectors: [[\"\", \"cCol\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ColDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      cCol: \"cCol\",\n      xs: \"xs\",\n      sm: \"sm\",\n      md: \"md\",\n      lg: \"lg\",\n      xl: \"xl\",\n      xxl: \"xxl\",\n      offset: \"offset\",\n      order: \"order\"\n    }\n  });\n  return ColDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ColComponent = /*#__PURE__*/(() => {\n  class ColComponent extends ColDirective {}\n  ColComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵColComponent_BaseFactory;\n    return function ColComponent_Factory(t) {\n      return (ɵColComponent_BaseFactory || (ɵColComponent_BaseFactory = i0.ɵɵgetInheritedFactory(ColComponent)))(t || ColComponent);\n    };\n  }();\n  ColComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColComponent,\n    selectors: [[\"c-col\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ColComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return ColComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RowDirective = /*#__PURE__*/(() => {\n  class RowDirective {\n    get hostClasses() {\n      const cols = this.xs;\n      const classes = {\n        row: true,\n        [`row-cols-${cols}`]: !!cols\n      };\n      Object.keys(BreakpointInfix).forEach(breakpoint => {\n        // @ts-ignore\n        const value = this[breakpoint];\n        if (typeof value === 'number' || typeof value === 'string') {\n          const infix = breakpoint === 'xs' ? '' : breakpoint;\n          classes[`row-cols-${infix}-${value}`] = !!value;\n        }\n      });\n      return classes;\n    }\n  }\n  RowDirective.ɵfac = function RowDirective_Factory(t) {\n    return new (t || RowDirective)();\n  };\n  RowDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RowDirective,\n    selectors: [[\"\", \"cRow\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RowDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      xs: \"xs\",\n      sm: \"sm\",\n      md: \"md\",\n      lg: \"lg\",\n      xl: \"xl\",\n      xxl: \"xxl\"\n    }\n  });\n  return RowDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RowComponent = /*#__PURE__*/(() => {\n  class RowComponent extends RowDirective {}\n  RowComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵRowComponent_BaseFactory;\n    return function RowComponent_Factory(t) {\n      return (ɵRowComponent_BaseFactory || (ɵRowComponent_BaseFactory = i0.ɵɵgetInheritedFactory(RowComponent)))(t || RowComponent);\n    };\n  }();\n  RowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: RowComponent,\n    selectors: [[\"c-row\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function RowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return RowComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GutterDirective = /*#__PURE__*/(() => {\n  class GutterDirective {\n    constructor() {\n      /**\n       * Define padding between columns to space and align content responsively in the Bootstrap grid system.\n       */\n      this.gutter = {};\n    }\n    get hostClasses() {\n      let gutterClass;\n      if (typeof this.gutter === 'number') {\n        gutterClass = GutterDirective.getGutterClasses({\n          g: this.gutter\n        });\n        return gutterClass;\n      }\n      {\n        // @ts-ignore\n        const {\n          g,\n          gx,\n          gy\n        } = {\n          ...this.gutter\n        };\n        gutterClass = GutterDirective.getGutterClasses({\n          g,\n          gx,\n          gy\n        });\n      }\n      Object.keys(BreakpointInfix).forEach(key => {\n        // @ts-ignore\n        const gutter = this.gutter[key] ? {\n          ...this.gutter[key]\n        } : undefined;\n        if (gutter) {\n          const classes = GutterDirective.getGutterClasses(gutter, key);\n          gutterClass = {\n            ...gutterClass,\n            ...classes\n          };\n        }\n      });\n      return gutterClass;\n    }\n    static getGutterClasses(gutter, breakpoint) {\n      const {\n        g,\n        gx,\n        gy\n      } = {\n        ...gutter\n      };\n      const infix = breakpoint ? `-${breakpoint}` : '';\n      return {\n        [`g${infix}-${g}`]: typeof g === 'number',\n        [`gx${infix}-${gx}`]: typeof gx === 'number',\n        [`gy${infix}-${gy}`]: typeof gy === 'number'\n      };\n    }\n  }\n  GutterDirective.ɵfac = function GutterDirective_Factory(t) {\n    return new (t || GutterDirective)();\n  };\n  GutterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GutterDirective,\n    selectors: [[\"\", \"gutter\", \"\"]],\n    hostVars: 2,\n    hostBindings: function GutterDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      gutter: \"gutter\"\n    }\n  });\n  return GutterDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GridModule = /*#__PURE__*/(() => {\n  class GridModule {}\n  GridModule.ɵfac = function GridModule_Factory(t) {\n    return new (t || GridModule)();\n  };\n  GridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GridModule\n  });\n  GridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return GridModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderComponent = /*#__PURE__*/(() => {\n  class HeaderComponent {\n    constructor() {\n      /**\n       * Default role for header. [docs]\n       * @type string\n       * @default 'header'\n       */\n      this.role = 'header';\n    }\n    get getClasses() {\n      return !!this.container ? this.containerClasses : this.headerClasses;\n    }\n    get headerClasses() {\n      return {\n        header: true,\n        [`header-${this.position}`]: !!this.position\n      };\n    }\n    get containerClasses() {\n      return {\n        container: this.container === true,\n        [`container-${this.container}`]: typeof this.container === 'string'\n      };\n    }\n  }\n  HeaderComponent.ɵfac = function HeaderComponent_Factory(t) {\n    return new (t || HeaderComponent)();\n  };\n  HeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderComponent,\n    selectors: [[\"c-header\"], [\"\", \"c-header\", \"\"]],\n    hostVars: 3,\n    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.getClasses);\n      }\n    },\n    inputs: {\n      container: \"container\",\n      position: \"position\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"class\", 4, \"ngIf\", \"ngIfElse\"], [\"elseBlock\", \"\"]],\n    template: function HeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c1);\n        i0.ɵɵtemplate(0, HeaderComponent_div_0_Template, 2, 2, \"div\", 0);\n        i0.ɵɵtemplate(1, HeaderComponent_ng_template_1_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.container)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [i1$1.NgIf],\n    encapsulation: 2\n  });\n  return HeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderBrandComponent = /*#__PURE__*/(() => {\n  class HeaderBrandComponent {\n    constructor() {\n      /**\n       * Default role for header-brand. [docs]\n       * @type string\n       * @default 'button'\n       */\n      this.role = 'button';\n      this.headerBrandClass = true;\n    }\n  }\n  HeaderBrandComponent.ɵfac = function HeaderBrandComponent_Factory(t) {\n    return new (t || HeaderBrandComponent)();\n  };\n  HeaderBrandComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderBrandComponent,\n    selectors: [[\"c-header-brand\"]],\n    hostVars: 3,\n    hostBindings: function HeaderBrandComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"header-brand\", ctx.headerBrandClass);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function HeaderBrandComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return HeaderBrandComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderDividerComponent = /*#__PURE__*/(() => {\n  class HeaderDividerComponent {\n    constructor() {\n      this.headerDividerClass = true;\n    }\n  }\n  HeaderDividerComponent.ɵfac = function HeaderDividerComponent_Factory(t) {\n    return new (t || HeaderDividerComponent)();\n  };\n  HeaderDividerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderDividerComponent,\n    selectors: [[\"c-header-divider\"], [\"\", \"cHeaderDivider\", \"\"]],\n    hostVars: 2,\n    hostBindings: function HeaderDividerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"header-divider\", ctx.headerDividerClass);\n      }\n    },\n    decls: 0,\n    vars: 0,\n    template: function HeaderDividerComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return HeaderDividerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderNavComponent = /*#__PURE__*/(() => {\n  class HeaderNavComponent {\n    constructor() {\n      /**\n       * Default role for header-nav. [docs]\n       * @type string\n       * @default 'navigation'\n       */\n      this.role = 'navigation';\n      this.headerNavClass = true;\n    }\n  }\n  HeaderNavComponent.ɵfac = function HeaderNavComponent_Factory(t) {\n    return new (t || HeaderNavComponent)();\n  };\n  HeaderNavComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderNavComponent,\n    selectors: [[\"c-header-nav\"]],\n    hostVars: 3,\n    hostBindings: function HeaderNavComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"header-nav\", ctx.headerNavClass);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function HeaderNavComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return HeaderNavComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderTextComponent = /*#__PURE__*/(() => {\n  class HeaderTextComponent {\n    constructor() {\n      this.headerTextClass = true;\n    }\n  }\n  HeaderTextComponent.ɵfac = function HeaderTextComponent_Factory(t) {\n    return new (t || HeaderTextComponent)();\n  };\n  HeaderTextComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderTextComponent,\n    selectors: [[\"c-header-text\"], [\"\", \"cHeaderText\", \"\"]],\n    hostVars: 2,\n    hostBindings: function HeaderTextComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"header-text\", ctx.headerTextClass);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function HeaderTextComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return HeaderTextComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderTogglerDirective = /*#__PURE__*/(() => {\n  class HeaderTogglerDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.headerToggler = true;\n      /**\n       * Default role for header-toggler. [docs]\n       * @type string\n       * @default 'button'\n       */\n      this.type = 'button';\n      /**\n       * Default aria-label attr for header-toggler. [docs]\n       * @type string\n       * @default 'Toggle navigation'\n       */\n      this.ariaLabel = 'Toggle navigation';\n    }\n    addDefaultIcon() {\n      const span = this.renderer.createElement('span');\n      this.renderer.addClass(span, 'header-toggler-icon');\n      this.renderer.appendChild(this.hostElement.nativeElement, span);\n    }\n    ngAfterContentInit() {\n      this.hasContent = this.hostElement.nativeElement.childNodes.length > 0;\n      if (!this.hasContent) {\n        this.addDefaultIcon();\n      }\n    }\n  }\n  HeaderTogglerDirective.ɵfac = function HeaderTogglerDirective_Factory(t) {\n    return new (t || HeaderTogglerDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  HeaderTogglerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HeaderTogglerDirective,\n    selectors: [[\"\", \"cHeaderToggler\", \"\"]],\n    hostVars: 4,\n    hostBindings: function HeaderTogglerDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵclassProp(\"header-toggler\", ctx.headerToggler);\n      }\n    },\n    inputs: {\n      type: \"type\",\n      ariaLabel: \"ariaLabel\"\n    }\n  });\n  return HeaderTogglerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HeaderModule = /*#__PURE__*/(() => {\n  class HeaderModule {}\n  HeaderModule.ɵfac = function HeaderModule_Factory(t) {\n    return new (t || HeaderModule)();\n  };\n  HeaderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: HeaderModule\n  });\n  HeaderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return HeaderModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ImgDirective = /*#__PURE__*/(() => {\n  class ImgDirective {\n    constructor() {\n      /**\n       * Set the horizontal aligment.\n       * @type {'' | 'start' | 'end' | 'center'}\n       */\n      this.align = '';\n      this._fluid = false;\n      this._rounded = false;\n      this._thumbnail = false;\n      /**\n       * Color for image placeholder.\n       */\n      this.placeholderColor = 'transparent';\n    }\n    /**\n     * Make image responsive.\n     * @type boolean\n     */\n    set fluid(value) {\n      this._fluid = coerceBooleanProperty(value);\n    }\n    get fluid() {\n      return this._fluid;\n    }\n    /**\n     * Make image rounded.\n     * @type boolean\n     */\n    set rounded(value) {\n      this._rounded = coerceBooleanProperty(value);\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Give an image a rounded 1px border appearance.\n     * @type boolean\n     */\n    set thumbnail(value) {\n      this._thumbnail = coerceBooleanProperty(value);\n    }\n    get thumbnail() {\n      return this._thumbnail;\n    }\n    get getStyles() {\n      return {\n        backgroundColor: this.placeholderColor\n      };\n    }\n    get hostClasses() {\n      const align = this.align;\n      return {\n        [`float-${align}`]: align === 'start' || align === 'end',\n        'd-block': align === 'center',\n        'mx-auto': align === 'center',\n        'img-fluid': this.fluid,\n        'rounded': this.rounded,\n        'img-thumbnail': this.thumbnail\n      };\n    }\n  }\n  ImgDirective.ɵfac = function ImgDirective_Factory(t) {\n    return new (t || ImgDirective)();\n  };\n  ImgDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ImgDirective,\n    selectors: [[\"\", \"cImg\", \"\"]],\n    hostVars: 4,\n    hostBindings: function ImgDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleMap(ctx.getStyles);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      align: \"align\",\n      fluid: \"fluid\",\n      rounded: \"rounded\",\n      thumbnail: \"thumbnail\",\n      placeholderColor: \"placeholderColor\"\n    }\n  });\n  return ImgDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ImgModule = /*#__PURE__*/(() => {\n  class ImgModule {}\n  ImgModule.ɵfac = function ImgModule_Factory(t) {\n    return new (t || ImgModule)();\n  };\n  ImgModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ImgModule\n  });\n  ImgModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return ImgModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ListGroupDirective = /*#__PURE__*/(() => {\n  class ListGroupDirective {\n    constructor() {\n      this._flush = false;\n    }\n    /**\n     * Remove some borders and rounded corners to render list group items edge-to-edge in a parent component (e.g., `<CCard>`).\n     * @type boolean\n     */\n    set flush(value) {\n      this._flush = coerceBooleanProperty(value);\n    }\n    get flush() {\n      return this._flush;\n    }\n    get hostClasses() {\n      const classes = {\n        'list-group': true,\n        'list-group-horizontal': this.horizontal === true || this.horizontal === '',\n        [`list-group-horizontal-${this.horizontal}`]: !!this.horizontal && typeof this.horizontal !== 'boolean',\n        'list-group-flush': this.flush\n      };\n      return classes;\n    }\n  }\n  ListGroupDirective.ɵfac = function ListGroupDirective_Factory(t) {\n    return new (t || ListGroupDirective)();\n  };\n  ListGroupDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ListGroupDirective,\n    selectors: [[\"\", \"cListGroup\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ListGroupDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      flush: \"flush\",\n      horizontal: \"horizontal\"\n    }\n  });\n  return ListGroupDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ListGroupItemDirective = /*#__PURE__*/(() => {\n  class ListGroupItemDirective {\n    constructor(hostElement) {\n      this.hostElement = hostElement;\n      this._disabled = false;\n    }\n    /**\n     * Set disabled attr for the host element. [docs]\n     * @type boolean\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    get attrDisabled() {\n      return this.disabled ? '' : null;\n    }\n    get getTabindex() {\n      return this.disabled ? '-1' : null;\n    }\n    get ariaCurrent() {\n      return !!this.active;\n    }\n    get hostClasses() {\n      const host = this.hostElement.nativeElement;\n      return {\n        'list-group-item': true,\n        'list-group-item-action': host.nodeName === 'A' || host.nodeName === 'BUTTON',\n        active: !!this.active,\n        disabled: this.isDisabled,\n        [`list-group-item-${this.color}`]: !!this.color\n      };\n    }\n  }\n  ListGroupItemDirective.ɵfac = function ListGroupItemDirective_Factory(t) {\n    return new (t || ListGroupItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  ListGroupItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ListGroupItemDirective,\n    selectors: [[\"\", \"cListGroupItem\", \"\"], [\"c-list-group-item\"]],\n    hostVars: 6,\n    hostBindings: function ListGroupItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"disabled\", ctx.attrDisabled)(\"tabindex\", ctx.getTabindex)(\"aria-current\", ctx.ariaCurrent);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      color: \"color\",\n      disabled: \"disabled\"\n    },\n    exportAs: [\"cListGroupItem\"]\n  });\n  return ListGroupItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ListGroupModule = /*#__PURE__*/(() => {\n  class ListGroupModule {}\n  ListGroupModule.ɵfac = function ListGroupModule_Factory(t) {\n    return new (t || ListGroupModule)();\n  };\n  ListGroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ListGroupModule\n  });\n  ListGroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return ListGroupModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavLinkDirective = /*#__PURE__*/(() => {\n  class NavLinkDirective {\n    constructor() {\n      this._cNavLink = true;\n      this._disabled = false;\n    }\n    /**\n     * Sets .nav-link class to the host. [docs]\n     * @type boolean\n     * @default true\n     */\n    set cNavLink(value) {\n      this._cNavLink = coerceBooleanProperty(value);\n    }\n    get cNavLink() {\n      return this._cNavLink;\n    }\n    /**\n     * Set disabled attr for the host element. [docs]\n     * @type boolean\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    get ariaCurrent() {\n      return this.active ? 'page' : null;\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    get attrDisabled() {\n      return this.disabled ? '' : null;\n    }\n    get getTabindex() {\n      return this.disabled ? '-1' : null;\n    }\n    get getCursorStyle() {\n      return this.disabled ? null : 'pointer';\n    }\n    get hostClasses() {\n      return {\n        'nav-link': this.cNavLink,\n        disabled: this.disabled,\n        active: this.active\n      };\n    }\n  }\n  NavLinkDirective.ɵfac = function NavLinkDirective_Factory(t) {\n    return new (t || NavLinkDirective)();\n  };\n  NavLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NavLinkDirective,\n    selectors: [[\"\", \"cNavLink\", \"\"]],\n    hostVars: 8,\n    hostBindings: function NavLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-current\", ctx.ariaCurrent)(\"aria-disabled\", ctx.isDisabled)(\"disabled\", ctx.attrDisabled)(\"tabindex\", ctx.getTabindex);\n        i0.ɵɵclassMap(ctx.hostClasses);\n        i0.ɵɵstyleProp(\"cursor\", ctx.getCursorStyle);\n      }\n    },\n    inputs: {\n      cNavLink: \"cNavLink\",\n      active: \"active\",\n      disabled: \"disabled\"\n    }\n  });\n  return NavLinkDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavItemComponent = /*#__PURE__*/(() => {\n  class NavItemComponent {\n    get hostClasses() {\n      return {\n        'nav-item': true\n      };\n    }\n  }\n  NavItemComponent.ɵfac = function NavItemComponent_Factory(t) {\n    return new (t || NavItemComponent)();\n  };\n  NavItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavItemComponent,\n    selectors: [[\"c-nav-item\"]],\n    hostVars: 2,\n    hostBindings: function NavItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function NavItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:list-item;text-align:match-parent;text-align:-webkit-match-parent}\"]\n  });\n  return NavItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavComponent = /*#__PURE__*/(() => {\n  class NavComponent {\n    get hostClasses() {\n      return {\n        nav: true,\n        [`nav-${this.layout}`]: !!this.layout,\n        [`nav-${this.variant}`]: !!this.variant\n      };\n    }\n  }\n  NavComponent.ɵfac = function NavComponent_Factory(t) {\n    return new (t || NavComponent)();\n  };\n  NavComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavComponent,\n    selectors: [[\"c-nav\"]],\n    hostVars: 2,\n    hostBindings: function NavComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      layout: \"layout\",\n      variant: \"variant\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function NavComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]   .nav-link[_ngcontent-%COMP%]:focus{outline:0}\"]\n  });\n  return NavComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavModule = /*#__PURE__*/(() => {\n  class NavModule {}\n  NavModule.ɵfac = function NavModule_Factory(t) {\n    return new (t || NavModule)();\n  };\n  NavModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NavModule\n  });\n  NavModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NavModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// todo: fix container prop issue not rendering children\n// todo: workaroud -  use <c-container> component directly in template\nlet NavbarComponent = /*#__PURE__*/(() => {\n  class NavbarComponent {\n    constructor(hostElement, breakpointObserver) {\n      this.hostElement = hostElement;\n      this.breakpointObserver = breakpointObserver;\n      /**\n       * Sets if the color of text should be colored for a light or dark dark background.\n       */\n      this.colorScheme = 'light';\n      this.role = 'navigation';\n    }\n    get hostClasses() {\n      const expandClassSuffix = this.expand === true ? '' : `-${this.expand}`;\n      return {\n        navbar: true,\n        'navbar-light': this.colorScheme === 'light',\n        'navbar-dark': this.colorScheme === 'dark',\n        [`navbar-expand${expandClassSuffix}`]: !!this.expand,\n        [`bg-${this.color}`]: !!this.color,\n        [`${this.placement}`]: !!this.placement\n      };\n    }\n    get containerClass() {\n      return `container${this.container !== true ? '-' + this.container : ''}`;\n    }\n    get breakpoint() {\n      if (typeof this.expand === 'string') {\n        return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--cui-breakpoint-${this.expand}`);\n      }\n      return false;\n    }\n    ngAfterContentInit() {\n      if (this.breakpoint) {\n        const onBreakpoint = `(min-width: ${this.breakpoint})`;\n        this.breakpointObserver.observe([onBreakpoint]).subscribe(result => {\n          if (this.collapse) {\n            const animate = this.collapse.animate;\n            this.collapse.toggle(false);\n            this.collapse.animate = false;\n            setTimeout(() => {\n              this.collapse.toggle(result.matches);\n              setTimeout(() => {\n                this.collapse.animate = animate;\n              });\n            });\n          }\n        });\n      }\n    }\n  }\n  NavbarComponent.ɵfac = function NavbarComponent_Factory(t) {\n    return new (t || NavbarComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$2.BreakpointObserver));\n  };\n  NavbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavbarComponent,\n    selectors: [[\"c-navbar\"]],\n    contentQueries: function NavbarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CollapseDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.collapse = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function NavbarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      colorScheme: \"colorScheme\",\n      container: \"container\",\n      expand: \"expand\",\n      placement: \"placement\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"], [\"withContainerTemplate\", \"\"], [\"noContainerTemplate\", \"\"], [3, \"ngClass\"]],\n    template: function NavbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c1);\n        i0.ɵɵtemplate(0, NavbarComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, NavbarComponent_ng_template_1_Template, 2, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, NavbarComponent_ng_template_3_Template, 1, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        const _r3 = i0.ɵɵreference(4);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.container ? _r1 : _r3);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgTemplateOutlet]\n  });\n  return NavbarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavbarBrandDirective = /*#__PURE__*/(() => {\n  class NavbarBrandDirective {\n    constructor() {\n      this.navbarBrand = true;\n      this.role = 'button';\n    }\n  }\n  NavbarBrandDirective.ɵfac = function NavbarBrandDirective_Factory(t) {\n    return new (t || NavbarBrandDirective)();\n  };\n  NavbarBrandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NavbarBrandDirective,\n    selectors: [[\"\", \"cNavbarBrand\", \"\"]],\n    hostVars: 3,\n    hostBindings: function NavbarBrandDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"navbar-brand\", ctx.navbarBrand);\n      }\n    }\n  });\n  return NavbarBrandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavbarNavComponent = /*#__PURE__*/(() => {\n  class NavbarNavComponent {\n    constructor() {\n      this._scroll = false;\n    }\n    /**\n     * Enable vertical scrolling of a collapsed navbar toggleable contents.\n     * @type boolean\n     */\n    set scroll(value) {\n      this._scroll = coerceBooleanProperty(value);\n    }\n    get scroll() {\n      return this._scroll;\n    }\n    get hostClasses() {\n      return {\n        'navbar-nav': true,\n        'navbar-nav-scroll': this.scroll\n      };\n    }\n  }\n  NavbarNavComponent.ɵfac = function NavbarNavComponent_Factory(t) {\n    return new (t || NavbarNavComponent)();\n  };\n  NavbarNavComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavbarNavComponent,\n    selectors: [[\"c-navbar-nav\"]],\n    hostVars: 2,\n    hostBindings: function NavbarNavComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      scroll: \"scroll\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function NavbarNavComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return NavbarNavComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavbarTextComponent = /*#__PURE__*/(() => {\n  class NavbarTextComponent {\n    constructor() {\n      this.navbarTextClass = true;\n    }\n  }\n  NavbarTextComponent.ɵfac = function NavbarTextComponent_Factory(t) {\n    return new (t || NavbarTextComponent)();\n  };\n  NavbarTextComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavbarTextComponent,\n    selectors: [[\"c-navbar-text\"]],\n    hostVars: 2,\n    hostBindings: function NavbarTextComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"navbar-text\", ctx.navbarTextClass);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function NavbarTextComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return NavbarTextComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavbarTogglerDirective = /*#__PURE__*/(() => {\n  class NavbarTogglerDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.navbarToggler = true;\n      /**\n       * Default type for navbar-toggler. [docs]\n       * @type string\n       * @default 'button'\n       */\n      this.type = 'button';\n      /**\n       * Default aria-label attr for navbar-toggler. [docs]\n       * @type string\n       * @default 'Toggle navigation'\n       */\n      this.ariaLabel = 'Toggle navigation';\n    }\n    handleClick() {\n      this.collapseRef?.toggle(!this.collapseRef?.visible);\n    }\n    addDefaultIcon() {\n      const span = this.renderer.createElement('span');\n      this.renderer.addClass(span, 'navbar-toggler-icon');\n      this.renderer.appendChild(this.hostElement.nativeElement, span);\n    }\n    ngAfterContentInit() {\n      this.hasContent = this.hostElement.nativeElement.childNodes.length;\n      if (!this.hasContent) {\n        this.addDefaultIcon();\n      }\n    }\n  }\n  NavbarTogglerDirective.ɵfac = function NavbarTogglerDirective_Factory(t) {\n    return new (t || NavbarTogglerDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  NavbarTogglerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NavbarTogglerDirective,\n    selectors: [[\"\", \"cNavbarToggler\", \"\"]],\n    hostVars: 4,\n    hostBindings: function NavbarTogglerDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NavbarTogglerDirective_click_HostBindingHandler($event) {\n          return ctx.handleClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵclassProp(\"navbar-toggler\", ctx.navbarToggler);\n      }\n    },\n    inputs: {\n      collapseRef: [\"cNavbarToggler\", \"collapseRef\"],\n      type: \"type\",\n      ariaLabel: \"ariaLabel\"\n    }\n  });\n  return NavbarTogglerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NavbarModule = /*#__PURE__*/(() => {\n  class NavbarModule {}\n  NavbarModule.ɵfac = function NavbarModule_Factory(t) {\n    return new (t || NavbarModule)();\n  };\n  NavbarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NavbarModule\n  });\n  NavbarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, RouterModule]\n  });\n  return NavbarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalBodyComponent = /*#__PURE__*/(() => {\n  class ModalBodyComponent {\n    get hostClasses() {\n      return {\n        'modal-body': true\n      };\n    }\n  }\n  ModalBodyComponent.ɵfac = function ModalBodyComponent_Factory(t) {\n    return new (t || ModalBodyComponent)();\n  };\n  ModalBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalBodyComponent,\n    selectors: [[\"c-modal-body\"]],\n    hostVars: 2,\n    hostBindings: function ModalBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ModalBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return ModalBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalContentComponent = /*#__PURE__*/(() => {\n  class ModalContentComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'modal-content': true\n      };\n    }\n  }\n  ModalContentComponent.ɵfac = function ModalContentComponent_Factory(t) {\n    return new (t || ModalContentComponent)();\n  };\n  ModalContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalContentComponent,\n    selectors: [[\"c-modal-content\"]],\n    hostVars: 2,\n    hostBindings: function ModalContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ModalContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ModalContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalDialogComponent = /*#__PURE__*/(() => {\n  class ModalDialogComponent {\n    get hostClasses() {\n      return {\n        'modal-dialog': true,\n        'modal-dialog-centered': this.alignment === 'center',\n        'modal-fullscreen': this.fullscreen === true,\n        [`modal-fullscreen-${this.fullscreen}-down`]: this.fullscreen,\n        'modal-dialog-scrollable': this.scrollable,\n        [`modal-${this.size}`]: this.size\n      };\n    }\n  }\n  ModalDialogComponent.ɵfac = function ModalDialogComponent_Factory(t) {\n    return new (t || ModalDialogComponent)();\n  };\n  ModalDialogComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalDialogComponent,\n    selectors: [[\"c-modal-dialog\"]],\n    hostVars: 2,\n    hostBindings: function ModalDialogComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      fullscreen: \"fullscreen\",\n      scrollable: \"scrollable\",\n      size: \"size\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ModalDialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}.modal-dialog-centered[_nghost-%COMP%]{display:flex}\"]\n  });\n  return ModalDialogComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalService = /*#__PURE__*/(() => {\n  class ModalService {\n    constructor() {\n      this.modalState = new Subject();\n      this.modalState$ = this.modalState.asObservable();\n    }\n    toggle(action) {\n      this.modalState.next(action);\n    }\n  }\n  ModalService.ɵfac = function ModalService_Factory(t) {\n    return new (t || ModalService)();\n  };\n  ModalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ModalService,\n    factory: ModalService.ɵfac,\n    providedIn: 'root'\n  });\n  return ModalService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalToggleDirective = /*#__PURE__*/(() => {\n  class ModalToggleDirective {\n    constructor(modalService) {\n      this.modalService = modalService;\n    }\n    dismiss($event) {\n      $event.preventDefault();\n      this.modalService.toggle({\n        show: 'toggle',\n        id: this.id\n      });\n    }\n  }\n  ModalToggleDirective.ɵfac = function ModalToggleDirective_Factory(t) {\n    return new (t || ModalToggleDirective)(i0.ɵɵdirectiveInject(ModalService));\n  };\n  ModalToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ModalToggleDirective,\n    selectors: [[\"\", \"cModalToggle\", \"\"]],\n    hostBindings: function ModalToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ModalToggleDirective_click_HostBindingHandler($event) {\n          return ctx.dismiss($event);\n        });\n      }\n    },\n    inputs: {\n      id: [\"cModalToggle\", \"id\"]\n    }\n  });\n  return ModalToggleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalFooterComponent = /*#__PURE__*/(() => {\n  class ModalFooterComponent {\n    get hostClasses() {\n      return {\n        'modal-footer': true\n      };\n    }\n  }\n  ModalFooterComponent.ɵfac = function ModalFooterComponent_Factory(t) {\n    return new (t || ModalFooterComponent)();\n  };\n  ModalFooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalFooterComponent,\n    selectors: [[\"c-modal-footer\"]],\n    hostVars: 2,\n    hostBindings: function ModalFooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ModalFooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ModalFooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalHeaderComponent = /*#__PURE__*/(() => {\n  class ModalHeaderComponent {\n    get hostClasses() {\n      return {\n        'modal-header': true\n      };\n    }\n  }\n  ModalHeaderComponent.ɵfac = function ModalHeaderComponent_Factory(t) {\n    return new (t || ModalHeaderComponent)();\n  };\n  ModalHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalHeaderComponent,\n    selectors: [[\"c-modal-header\"]],\n    hostVars: 2,\n    hostBindings: function ModalHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ModalHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ModalHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalTitleDirective = /*#__PURE__*/(() => {\n  class ModalTitleDirective {\n    get hostClasses() {\n      return {\n        'modal-title': true\n      };\n    }\n  }\n  ModalTitleDirective.ɵfac = function ModalTitleDirective_Factory(t) {\n    return new (t || ModalTitleDirective)();\n  };\n  ModalTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ModalTitleDirective,\n    selectors: [[\"\", \"cModalTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ModalTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return ModalTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BackdropService = /*#__PURE__*/(() => {\n  class BackdropService {\n    constructor(document, rendererFactory) {\n      this.document = document;\n      this.rendererFactory = rendererFactory;\n      this.backdropClick = new Subject();\n      this.backdropClick$ = this.backdropClick.asObservable();\n      this.renderer = rendererFactory.createRenderer(null, null);\n    }\n    setBackdrop(type = 'modal') {\n      const backdropElement = this.renderer.createElement('div');\n      this.renderer.addClass(backdropElement, `${type}-backdrop`);\n      this.renderer.addClass(backdropElement, 'fade');\n      this.renderer.appendChild(this.document.body, backdropElement);\n      this.unListen = this.renderer.listen(backdropElement, 'click', e => {\n        this.onClickHandler();\n      });\n      setTimeout(() => {\n        this.renderer.addClass(backdropElement, 'show');\n      });\n      return backdropElement;\n    }\n    clearBackdrop(backdrop) {\n      if (backdrop) {\n        this.unListen();\n        this.renderer.removeClass(backdrop, 'show');\n        setTimeout(() => {\n          this.renderer.removeChild(this.document.body, backdrop);\n          backdrop = undefined;\n        }, 300);\n      }\n      return backdrop;\n    }\n    onClickHandler() {\n      this.backdropClick.next(true);\n    }\n  }\n  BackdropService.ɵfac = function BackdropService_Factory(t) {\n    return new (t || BackdropService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.RendererFactory2));\n  };\n  BackdropService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BackdropService,\n    factory: BackdropService.ɵfac,\n    providedIn: 'root'\n  });\n  return BackdropService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalComponent = /*#__PURE__*/(() => {\n  class ModalComponent {\n    constructor(document, renderer, hostElement, modalService, backdropService) {\n      this.document = document;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.modalService = modalService;\n      this.backdropService = backdropService;\n      /**\n       * Align the modal in the center or top of the screen.\n       * @type {'top' | 'center'}\n       * @default 'top'\n       */\n      this.alignment = 'top';\n      /**\n       * Apply a backdrop on body while modal is open.\n       * @type boolean | 'static'\n       * @default true\n       */\n      this.backdrop = true;\n      /**\n       * Closes the modal when escape key is pressed.\n       * @type boolean\n       * @default true\n       */\n      this.keyboard = true;\n      /**\n       * Remove animation to create modal that simply appear rather than fade in to view.\n       */\n      this.transition = true;\n      /**\n       * Default role for modal. [docs]\n       * @type string\n       * @default 'dialog'\n       */\n      this.role = 'dialog';\n      /**\n       * Set aria-modal html attr for modal. [docs]\n       * @type boolean\n       * @default true\n       */\n      this.ariaModal = true;\n      this._scrollable = false;\n      /**\n       * Event triggered on modal dismiss.\n       */\n      this.visibleChange = new EventEmitter();\n      this._show = true;\n      this.mouseDownTarget = null;\n    }\n    /**\n     * Create a scrollable modal that allows scrolling the modal body.\n     * @type boolean\n     */\n    set scrollable(value) {\n      this._scrollable = coerceBooleanProperty(value);\n    }\n    get scrollable() {\n      return this._scrollable;\n    }\n    /**\n     * Toggle the visibility of modal component.\n     * @type boolean\n     */\n    set visible(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (this._visible !== newValue) {\n        this._visible = newValue;\n        this.setBackdrop(this.backdrop !== false && newValue);\n        this.setBodyStyles(newValue);\n        this.visibleChange.emit(newValue);\n      }\n    }\n    get visible() {\n      return this._visible;\n    }\n    // private inBoundingClientRect!: boolean;\n    get hostClasses() {\n      return {\n        modal: true,\n        fade: this.transition,\n        show: this.show\n      };\n    }\n    get ariaHidden() {\n      return this.visible ? null : true;\n    }\n    get tabIndex() {\n      return '-1';\n    }\n    get animateTrigger() {\n      return this.visible ? 'visible' : 'hidden';\n    }\n    get show() {\n      return this.visible && this._show;\n    }\n    set show(value) {\n      this._show = value;\n    }\n    get scrollbarWidth() {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n      const documentWidth = this.document.documentElement.clientWidth;\n      const scrollbarWidth = Math.abs((window?.innerWidth ?? documentWidth) - documentWidth);\n      return `${scrollbarWidth}px`;\n    }\n    animateStart(event) {\n      const scrollbarWidth = this.scrollbarWidth;\n      if (event.toState === 'visible') {\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n        this.renderer.setStyle(this.document.body, 'padding-right', scrollbarWidth);\n        this.renderer.setStyle(this.hostElement.nativeElement, 'display', 'block');\n      } else {\n        if (!this.transition) {\n          this.renderer.setStyle(this.hostElement.nativeElement, 'display', 'none');\n        }\n      }\n    }\n    animateDone(event) {\n      setTimeout(() => {\n        if (event.toState === 'hidden') {\n          this.renderer.setStyle(this.hostElement.nativeElement, 'display', 'none');\n          this.renderer.removeStyle(this.document.body, 'overflow');\n          this.renderer.removeStyle(this.document.body, 'padding-right');\n        }\n      });\n      this.show = this.visible;\n    }\n    onKeyDownHandler(event) {\n      if (event.key === 'Escape' && this.keyboard && this.visible) {\n        if (this.backdrop === 'static') {\n          this.setStaticBackdrop();\n        } else {\n          this.modalService.toggle({\n            show: false,\n            modal: this\n          });\n        }\n      }\n    }\n    onMouseDownHandler($event) {\n      this.mouseDownTarget = $event.target;\n    }\n    onClickHandler($event) {\n      if (this.mouseDownTarget !== $event.target) {\n        this.mouseDownTarget = null;\n        return;\n      }\n      const targetElement = $event.target;\n      if (targetElement === this.hostElement.nativeElement) {\n        if (this.backdrop === 'static') {\n          this.setStaticBackdrop();\n          return;\n        }\n        this.modalService.toggle({\n          show: false,\n          modal: this\n        });\n      }\n    }\n    ngOnInit() {\n      this.stateToggleSubscribe();\n    }\n    ngOnDestroy() {\n      this.modalService.toggle({\n        show: false,\n        modal: this\n      });\n      this.stateToggleSubscribe(false);\n    }\n    stateToggleSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.stateToggleSubscription = this.modalService.modalState$.subscribe(action => {\n          if (this === action.modal || this.id === action.id) {\n            if ('show' in action) {\n              this.visible = action?.show === 'toggle' ? !this.visible : action.show;\n            }\n          } else {\n            if (this.visible) {\n              this.visible = false;\n            }\n          }\n        });\n      } else {\n        this.stateToggleSubscription.unsubscribe();\n      }\n    }\n    setBackdrop(setBackdrop) {\n      if (setBackdrop) {\n        this.activeBackdrop = this.backdropService.setBackdrop('modal');\n      } else {\n        this.activeBackdrop = this.backdropService.clearBackdrop(this.activeBackdrop);\n      }\n    }\n    setBodyStyles(open) {\n      if (open) {\n        if (this.backdrop === true) {\n          this.renderer.addClass(this.document.body, 'modal-open');\n        }\n      } else {\n        this.renderer.removeClass(this.document.body, 'modal-open');\n      }\n    }\n    setStaticBackdrop() {\n      if (this.transition) {\n        this.renderer.addClass(this.hostElement.nativeElement, 'modal-static');\n        this.renderer.setStyle(this.hostElement.nativeElement, 'overflow-y', 'hidden');\n        setTimeout(() => {\n          this.renderer.removeClass(this.hostElement.nativeElement, 'modal-static');\n          this.renderer.removeStyle(this.hostElement.nativeElement, 'overflow-y');\n        }, 300);\n      }\n    }\n  }\n  ModalComponent.ɵfac = function ModalComponent_Factory(t) {\n    return new (t || ModalComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ModalService), i0.ɵɵdirectiveInject(BackdropService));\n  };\n  ModalComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ModalComponent,\n    selectors: [[\"c-modal\"]],\n    viewQuery: function ModalComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ModalContentComponent, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modalContent = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function ModalComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@showHide.start\", function ModalComponent_animation_showHide_start_HostBindingHandler($event) {\n          return ctx.animateStart($event);\n        })(\"@showHide.done\", function ModalComponent_animation_showHide_done_HostBindingHandler($event) {\n          return ctx.animateDone($event);\n        });\n        i0.ɵɵlistener(\"keyup\", function ModalComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyDownHandler($event);\n        }, false, i0.ɵɵresolveDocument)(\"mousedown\", function ModalComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDownHandler($event);\n        })(\"click\", function ModalComponent_click_HostBindingHandler($event) {\n          return ctx.onClickHandler($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-modal\", ctx.ariaModal)(\"aria-hidden\", ctx.ariaHidden)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵsyntheticHostProperty(\"@showHide\", ctx.animateTrigger);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      backdrop: \"backdrop\",\n      fullscreen: \"fullscreen\",\n      keyboard: \"keyboard\",\n      id: \"id\",\n      size: \"size\",\n      transition: \"transition\",\n      role: \"role\",\n      ariaModal: \"ariaModal\",\n      scrollable: \"scrollable\",\n      visible: \"visible\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\"\n    },\n    exportAs: [\"cModal\"],\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 6,\n    consts: [[3, \"alignment\", \"fullscreen\", \"scrollable\", \"size\"], [2, \"display\", \"contents\", 3, \"cdkTrapFocus\", \"cdkTrapFocusAutoCapture\"]],\n    template: function ModalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"c-modal-dialog\", 0)(1, \"c-modal-content\")(2, \"div\", 1);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"alignment\", ctx.alignment)(\"fullscreen\", ctx.fullscreen)(\"scrollable\", ctx.scrollable)(\"size\", ctx.size);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"cdkTrapFocus\", ctx.visible)(\"cdkTrapFocusAutoCapture\", ctx.visible);\n      }\n    },\n    dependencies: [i3$1.CdkTrapFocus, ModalContentComponent, ModalDialogComponent],\n    data: {\n      animation: [trigger('showHide', [state('visible', style({\n        // display: 'block'\n      })), state('hidden', style({\n        // display: 'none'\n      })), transition('visible <=> *', [animate('300ms')])])]\n    }\n  });\n  return ModalComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalModule = /*#__PURE__*/(() => {\n  class ModalModule {}\n  ModalModule.ɵfac = function ModalModule_Factory(t) {\n    return new (t || ModalModule)();\n  };\n  ModalModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ModalModule\n  });\n  ModalModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ModalService],\n    imports: [CommonModule, A11yModule]\n  });\n  return ModalModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasService = /*#__PURE__*/(() => {\n  class OffcanvasService {\n    constructor() {\n      this.offcanvasState = new Subject();\n      this.offcanvasState$ = this.offcanvasState.asObservable();\n    }\n    toggle(action) {\n      this.offcanvasState.next(action);\n    }\n  }\n  OffcanvasService.ɵfac = function OffcanvasService_Factory(t) {\n    return new (t || OffcanvasService)();\n  };\n  OffcanvasService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OffcanvasService,\n    factory: OffcanvasService.ɵfac,\n    providedIn: 'root'\n  });\n  return OffcanvasService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId = 0;\nlet OffcanvasComponent = /*#__PURE__*/(() => {\n  class OffcanvasComponent {\n    constructor(document, platformId, renderer, hostElement, offcanvasService, backdropService) {\n      this.document = document;\n      this.platformId = platformId;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.offcanvasService = offcanvasService;\n      this.backdropService = backdropService;\n      /**\n       * Apply a backdrop on body while offcanvas is open.\n       * @type boolean\n       * @default true\n       */\n      this.backdrop = true;\n      /**\n       * Closes the offcanvas when escape key is pressed [docs]\n       * @type boolean\n       * @default true\n       */\n      this.keyboard = true;\n      /**\n       * Components placement, there’s no default placement.\n       * @type {'start' | 'end' | 'top' | 'bottom'}\n       * @default 'start'\n       */\n      this.placement = 'start';\n      this._scroll = false;\n      this.id = `offcanvas-${this.placement}-${nextId++}`;\n      /**\n       * Default role for offcanvas. [docs]\n       * @type string\n       * @default 'dialog'\n       */\n      this.role = 'dialog';\n      /**\n       * Set aria-modal html attr for offcanvas. [docs]\n       * @type boolean\n       * @default true\n       */\n      this.ariaModal = true;\n      /**\n       * Event triggered on visible change.\n       */\n      this.visibleChange = new EventEmitter();\n    }\n    /**\n     * Allow body scrolling while offcanvas is visible.\n     * @type boolean\n     */\n    set scroll(value) {\n      this._scroll = coerceBooleanProperty(value);\n    }\n    get scroll() {\n      return this._scroll;\n    }\n    /**\n     * Toggle the visibility of offcanvas component.\n     * @type boolean\n     */\n    set visible(value) {\n      this._visible = coerceBooleanProperty(value);\n      if (value) {\n        this.setBackdrop(this.backdrop);\n        this.setFocus();\n      } else {\n        this.setBackdrop(false);\n      }\n      this.setScroll();\n      this.visibleChange.emit(value);\n    }\n    get visible() {\n      return this._visible;\n    }\n    get hostClasses() {\n      return {\n        offcanvas: true,\n        [`offcanvas-${this.placement}`]: !!this.placement,\n        show: this.visible\n      };\n    }\n    get ariaHidden() {\n      return this.visible ? null : true;\n    }\n    get tabIndex() {\n      return '-1';\n    }\n    get animateType() {\n      return this.visible;\n    }\n    onKeyDownHandler(event) {\n      if (event.key === 'Escape' && this.keyboard && this.visible) {\n        this.offcanvasService.toggle({\n          show: false,\n          id: this.id\n        });\n      }\n    }\n    ngOnInit() {\n      this.setScroll();\n      this.stateToggleSubscribe();\n    }\n    ngOnDestroy() {\n      this.offcanvasService.toggle({\n        show: false,\n        id: this.id\n      });\n      this.stateToggleSubscribe(false);\n    }\n    ngOnChanges(changes) {\n      if (changes['scroll']) {\n        this.setScroll();\n      }\n    }\n    stateToggleSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.stateToggleSubscription = this.offcanvasService.offcanvasState$.subscribe(action => {\n          if (this === action.offcanvas || this.id === action.id) {\n            if ('show' in action) {\n              this.visible = action?.show === 'toggle' ? !this.visible : action.show;\n            }\n          }\n        });\n      } else {\n        this.stateToggleSubscription.unsubscribe();\n      }\n    }\n    backdropClickSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.backdropClickSubscription = this.backdropService.backdropClick$.subscribe(clicked => {\n          this.offcanvasService.toggle({\n            show: !clicked,\n            id: this.id\n          });\n        });\n      } else {\n        this.backdropClickSubscription?.unsubscribe();\n      }\n    }\n    setBackdrop(setBackdrop) {\n      if (setBackdrop) {\n        this.activeBackdrop = this.backdropService.setBackdrop('offcanvas');\n        this.backdropClickSubscribe();\n      } else {\n        this.activeBackdrop = this.backdropService.clearBackdrop(this.activeBackdrop);\n        this.backdropClickSubscribe(false);\n      }\n    }\n    setFocus() {\n      if (isPlatformBrowser(this.platformId)) {\n        setTimeout(() => this.hostElement.nativeElement.focus());\n      }\n    }\n    setScroll() {\n      if (this.visible) {\n        if (!this.scroll) {\n          this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n          this.renderer.setStyle(this.document.body, 'paddingRight.px', '0');\n        }\n        return;\n      }\n      if (!this.scroll) {\n        this.renderer.removeStyle(this.document.body, 'overflow');\n        this.renderer.removeStyle(this.document.body, 'paddingRight');\n      }\n    }\n  }\n  OffcanvasComponent.ɵfac = function OffcanvasComponent_Factory(t) {\n    return new (t || OffcanvasComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(OffcanvasService), i0.ɵɵdirectiveInject(BackdropService));\n  };\n  OffcanvasComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OffcanvasComponent,\n    selectors: [[\"c-offcanvas\"]],\n    hostVars: 7,\n    hostBindings: function OffcanvasComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function OffcanvasComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDownHandler($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-modal\", ctx.ariaModal)(\"aria-hidden\", ctx.ariaHidden)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵsyntheticHostProperty(\"@showHide\", ctx.animateType);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      backdrop: \"backdrop\",\n      keyboard: \"keyboard\",\n      placement: \"placement\",\n      scroll: \"scroll\",\n      id: \"id\",\n      role: \"role\",\n      ariaModal: \"ariaModal\",\n      visible: \"visible\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\"\n    },\n    exportAs: [\"cOffcanvas\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[\"cdkTrapFocus\", \"\", \"cdkTrapFocusAutoCapture\", \"\"]],\n    template: function OffcanvasComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    dependencies: [i3$1.CdkTrapFocus],\n    data: {\n      animation: [trigger('showHide', [state('true', style({\n        visibility: 'visible'\n      })), state('false', style({\n        visibility: 'hidden'\n      })), transition('true => false', [animate('300ms')])])]\n    }\n  });\n  return OffcanvasComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasBodyComponent = /*#__PURE__*/(() => {\n  class OffcanvasBodyComponent {\n    get hostClasses() {\n      return {\n        'offcanvas-body': true\n      };\n    }\n  }\n  OffcanvasBodyComponent.ɵfac = function OffcanvasBodyComponent_Factory(t) {\n    return new (t || OffcanvasBodyComponent)();\n  };\n  OffcanvasBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OffcanvasBodyComponent,\n    selectors: [[\"c-offcanvas-body\"]],\n    hostVars: 2,\n    hostBindings: function OffcanvasBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function OffcanvasBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return OffcanvasBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasHeaderComponent = /*#__PURE__*/(() => {\n  class OffcanvasHeaderComponent {\n    get hostClasses() {\n      return {\n        'offcanvas-header': true\n      };\n    }\n  }\n  OffcanvasHeaderComponent.ɵfac = function OffcanvasHeaderComponent_Factory(t) {\n    return new (t || OffcanvasHeaderComponent)();\n  };\n  OffcanvasHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OffcanvasHeaderComponent,\n    selectors: [[\"c-offcanvas-header\"]],\n    hostVars: 2,\n    hostBindings: function OffcanvasHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function OffcanvasHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return OffcanvasHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasTitleDirective = /*#__PURE__*/(() => {\n  class OffcanvasTitleDirective {\n    get hostClasses() {\n      return {\n        'offcanvas-title': true\n      };\n    }\n  }\n  OffcanvasTitleDirective.ɵfac = function OffcanvasTitleDirective_Factory(t) {\n    return new (t || OffcanvasTitleDirective)();\n  };\n  OffcanvasTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OffcanvasTitleDirective,\n    selectors: [[\"\", \"cOffcanvasTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function OffcanvasTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return OffcanvasTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasToggleDirective = /*#__PURE__*/(() => {\n  class OffcanvasToggleDirective {\n    constructor(offcanvasService) {\n      this.offcanvasService = offcanvasService;\n    }\n    toggleOpen($event) {\n      $event.preventDefault();\n      this.offcanvasService.toggle({\n        show: 'toggle',\n        id: this.id\n      });\n    }\n  }\n  OffcanvasToggleDirective.ɵfac = function OffcanvasToggleDirective_Factory(t) {\n    return new (t || OffcanvasToggleDirective)(i0.ɵɵdirectiveInject(OffcanvasService));\n  };\n  OffcanvasToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OffcanvasToggleDirective,\n    selectors: [[\"\", \"cOffcanvasToggle\", \"\"]],\n    hostBindings: function OffcanvasToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function OffcanvasToggleDirective_click_HostBindingHandler($event) {\n          return ctx.toggleOpen($event);\n        });\n      }\n    },\n    inputs: {\n      id: [\"cOffcanvasToggle\", \"id\"]\n    }\n  });\n  return OffcanvasToggleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OffcanvasModule = /*#__PURE__*/(() => {\n  class OffcanvasModule {}\n  OffcanvasModule.ɵfac = function OffcanvasModule_Factory(t) {\n    return new (t || OffcanvasModule)();\n  };\n  OffcanvasModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OffcanvasModule\n  });\n  OffcanvasModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [OffcanvasService, BackdropService],\n    imports: [CommonModule, A11yModule]\n  });\n  return OffcanvasModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageLinkDirective = /*#__PURE__*/(() => {\n  class PageLinkDirective {\n    get hostClasses() {\n      return {\n        'page-link': true\n      };\n    }\n  }\n  PageLinkDirective.ɵfac = function PageLinkDirective_Factory(t) {\n    return new (t || PageLinkDirective)();\n  };\n  PageLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PageLinkDirective,\n    selectors: [[\"\", \"cPageLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function PageLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    }\n  });\n  return PageLinkDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageItemDirective = /*#__PURE__*/(() => {\n  class PageItemDirective {\n    constructor(renderer) {\n      this.renderer = renderer;\n    }\n    get ariaCurrent() {\n      return this.active ? 'page' : null;\n    }\n    get hostClasses() {\n      return {\n        'page-item': true,\n        disabled: this.disabled,\n        active: this.active\n      };\n    }\n    ngAfterContentInit() {\n      this.setAttributes();\n    }\n    ngOnChanges(changes) {\n      if (changes['disabled']) {\n        this.setAttributes();\n      }\n    }\n    setAttributes() {\n      if (!this.pageLinkElementRef) {\n        return;\n      }\n      const pageLinkElement = this.pageLinkElementRef.nativeElement;\n      if (this.disabled) {\n        this.renderer.setAttribute(pageLinkElement, 'aria-disabled', 'true');\n        this.renderer.setAttribute(pageLinkElement, 'tabindex', '-1');\n      } else {\n        this.renderer.removeAttribute(pageLinkElement, 'aria-disabled');\n        this.renderer.removeAttribute(pageLinkElement, 'tabindex');\n      }\n    }\n  }\n  PageItemDirective.ɵfac = function PageItemDirective_Factory(t) {\n    return new (t || PageItemDirective)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  PageItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PageItemDirective,\n    selectors: [[\"\", \"cPageItem\", \"\"]],\n    contentQueries: function PageItemDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PageLinkDirective, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pageLinkElementRef = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function PageItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-current\", ctx.ariaCurrent);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      disabled: \"disabled\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PageItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageItemComponent = /*#__PURE__*/(() => {\n  class PageItemComponent extends PageItemDirective {}\n  PageItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵPageItemComponent_BaseFactory;\n    return function PageItemComponent_Factory(t) {\n      return (ɵPageItemComponent_BaseFactory || (ɵPageItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(PageItemComponent)))(t || PageItemComponent);\n    };\n  }();\n  PageItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PageItemComponent,\n    selectors: [[\"c-page-item\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function PageItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [_c5]\n  });\n  return PageItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PaginationComponent = /*#__PURE__*/(() => {\n  class PaginationComponent {\n    constructor() {\n      /**\n       * Set the alignment of pagination components.\n       * @values 'start', 'center', 'end'\n       */\n      this.align = '';\n      /**\n       * Default role for pagination. [docs]\n       * @type string\n       * @default 'navigation'\n       */\n      this.role = 'navigation';\n    }\n    get paginationClass() {\n      return {\n        pagination: true,\n        [`pagination-${this.size}`]: !!this.size,\n        [`justify-content-${this.align}`]: !!this.align\n      };\n    }\n  }\n  PaginationComponent.ɵfac = function PaginationComponent_Factory(t) {\n    return new (t || PaginationComponent)();\n  };\n  PaginationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PaginationComponent,\n    selectors: [[\"c-pagination\"]],\n    hostVars: 1,\n    hostBindings: function PaginationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n      }\n    },\n    inputs: {\n      align: \"align\",\n      size: \"size\",\n      role: \"role\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"ngClass\"]],\n    template: function PaginationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.paginationClass);\n      }\n    },\n    dependencies: [i1$1.NgClass]\n  });\n  return PaginationComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PaginationModule = /*#__PURE__*/(() => {\n  class PaginationModule {}\n  PaginationModule.ɵfac = function PaginationModule_Factory(t) {\n    return new (t || PaginationModule)();\n  };\n  PaginationModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PaginationModule\n  });\n  PaginationModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return PaginationModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PlaceholderDirective = /*#__PURE__*/(() => {\n  class PlaceholderDirective {\n    constructor() {\n      this._visible = false;\n    }\n    /**\n     * placeholder toggler\n     * @type boolean\n     * @default true\n     */\n    set visible(value) {\n      this._visible = coerceBooleanProperty(value);\n    }\n    get visible() {\n      return this._visible;\n    }\n    get ariaHidden() {\n      return this.visible ? null : true;\n    }\n    get hostClasses() {\n      return {\n        'placeholder': this.visible,\n        [`placeholder-${this.size}`]: !!this.size\n      };\n    }\n  }\n  PlaceholderDirective.ɵfac = function PlaceholderDirective_Factory(t) {\n    return new (t || PlaceholderDirective)();\n  };\n  PlaceholderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PlaceholderDirective,\n    selectors: [[\"\", \"cPlaceholder\", \"\"]],\n    hostVars: 3,\n    hostBindings: function PlaceholderDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-hidden\", ctx.ariaHidden);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      visible: [\"cPlaceholder\", \"visible\"],\n      size: [\"cPlaceholderSize\", \"size\"]\n    },\n    exportAs: [\"cPlaceholder\"]\n  });\n  return PlaceholderDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PlaceholderAnimationDirective = /*#__PURE__*/(() => {\n  class PlaceholderAnimationDirective {\n    constructor() {\n      this.animate = false;\n    }\n    get hostClasses() {\n      return {\n        [`placeholder-${this.animation}`]: this.animate && !!this.animation\n      };\n    }\n    ngAfterContentInit() {\n      this.animate = this.placeholder?.visible;\n    }\n  }\n  PlaceholderAnimationDirective.ɵfac = function PlaceholderAnimationDirective_Factory(t) {\n    return new (t || PlaceholderAnimationDirective)();\n  };\n  PlaceholderAnimationDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PlaceholderAnimationDirective,\n    selectors: [[\"\", \"cPlaceholderAnimation\", \"\"]],\n    contentQueries: function PlaceholderAnimationDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PlaceholderDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.placeholder = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function PlaceholderAnimationDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      animation: [\"cPlaceholderAnimation\", \"animation\"]\n    }\n  });\n  return PlaceholderAnimationDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PlaceholderModule = /*#__PURE__*/(() => {\n  class PlaceholderModule {}\n  PlaceholderModule.ɵfac = function PlaceholderModule_Factory(t) {\n    return new (t || PlaceholderModule)();\n  };\n  PlaceholderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PlaceholderModule\n  });\n  PlaceholderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return PlaceholderModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PopoverComponent = /*#__PURE__*/(() => {\n  class PopoverComponent {\n    constructor(renderer) {\n      this.renderer = renderer;\n      /**\n       * Content of popover\n       * @type {string | TemplateRef}\n       */\n      this.content = '';\n      /**\n       * Toggle the visibility of popover component.\n       * @type boolean\n       */\n      this.visible = false;\n      this.role = 'tooltip';\n    }\n    get hostClasses() {\n      return {\n        popover: true,\n        fade: true,\n        show: this.visible,\n        'bs-popover-auto': true\n      };\n    }\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.updateView(this.content);\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes['content']) {\n        setTimeout(() => {\n          this.updateView(this.content);\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.clear();\n    }\n    clear() {\n      this.viewContainerRef?.clear();\n      if (!!this.textNode) {\n        this.renderer.removeChild(this.textNode.parentNode, this.textNode);\n      }\n    }\n    updateView(content) {\n      this.clear();\n      if (!content) {\n        return;\n      }\n      if (content instanceof TemplateRef) {\n        this.viewContainerRef.createEmbeddedView(content);\n      } else {\n        this.textNode = this.renderer.createText(content);\n        const popoverBody = this.renderer.createElement('div');\n        this.renderer.addClass(popoverBody, 'popover-body');\n        this.renderer.appendChild(popoverBody, this.textNode);\n        const element = this.viewContainerRef.element.nativeElement;\n        this.renderer.appendChild(element.parentNode, popoverBody);\n      }\n    }\n  }\n  PopoverComponent.ɵfac = function PopoverComponent_Factory(t) {\n    return new (t || PopoverComponent)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  PopoverComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PopoverComponent,\n    selectors: [[\"c-popover\"]],\n    viewQuery: function PopoverComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function PopoverComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      content: \"content\",\n      visible: \"visible\",\n      id: \"id\",\n      role: \"role\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 3,\n    consts: [[\"data-popper-arrow\", \"\", 3, \"ngClass\"], [\"popoverTemplate\", \"\"]],\n    template: function PopoverComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelement(1, \"div\", 0);\n        i0.ɵɵelementContainer(2, null, 1);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(1, _c7, !!ctx.content));\n      }\n    },\n    dependencies: [i1$1.NgClass],\n    encapsulation: 2\n  });\n  return PopoverComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PopoverDirective = /*#__PURE__*/(() => {\n  class PopoverDirective {\n    constructor(document, renderer, hostElement, viewContainerRef, listenersService, changeDetectorRef) {\n      this.document = document;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.viewContainerRef = viewContainerRef;\n      this.listenersService = listenersService;\n      this.changeDetectorRef = changeDetectorRef;\n      /**\n       * Content of popover\n       * @type {string | TemplateRef}\n       */\n      this.content = '';\n      /**\n       * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.\n       */\n      this.placement = 'top';\n      /**\n       * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.\n       * @type {'hover' | 'focus' | 'click'}\n       */\n      this.trigger = 'hover';\n      this._visible = false;\n      this._popperOptions = {\n        modifiers: [{\n          name: 'offset',\n          options: {\n            offset: [0, 8]\n          }\n        }]\n      };\n    }\n    /**\n     * Optional popper Options object, takes precedence over cPopoverPlacement prop\n     * @type Partial<Options>\n     */\n    set popperOptions(value) {\n      this._popperOptions = {\n        ...this._popperOptions,\n        placement: this.placement,\n        ...value\n      };\n    }\n    get popperOptions() {\n      return {\n        placement: this.placement,\n        ...this._popperOptions\n      };\n    }\n    /**\n     * Toggle the visibility of popover component.\n     */\n    set visible(value) {\n      this._visible = value;\n    }\n    get visible() {\n      return this._visible;\n    }\n    get ariaDescribedBy() {\n      return this.popoverId ? this.popoverId : null;\n    }\n    ngOnChanges(changes) {\n      if (changes['visible']) {\n        changes['visible'].currentValue ? this.addPopoverElement() : this.removePopoverElement();\n      }\n    }\n    ngOnDestroy() {\n      this.clearListeners();\n      this.destroyPopoverElement();\n    }\n    ngOnInit() {\n      this.setListeners();\n    }\n    setListeners() {\n      const config = {\n        hostElement: this.hostElement,\n        trigger: this.trigger,\n        callbackToggle: () => {\n          this.visible = !this.visible;\n          this.visible ? this.addPopoverElement() : this.removePopoverElement();\n        },\n        callbackOff: () => {\n          this.visible = false;\n          this.removePopoverElement();\n        },\n        callbackOn: () => {\n          this.visible = true;\n          this.addPopoverElement();\n        }\n      };\n      this.listenersService.setListeners(config);\n    }\n    clearListeners() {\n      this.listenersService.clearListeners();\n    }\n    getUID(prefix) {\n      let uid = prefix ?? 'random-id';\n      do {\n        uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;\n      } while (this.document.getElementById(uid));\n      return uid;\n    }\n    createPopoverElement() {\n      if (!this.popoverRef) {\n        this.popoverRef = this.viewContainerRef.createComponent(PopoverComponent);\n        // this.viewContainerRef.detach();\n      }\n    }\n\n    destroyPopoverElement() {\n      this.popover?.remove();\n      this.popoverRef?.destroy();\n      // @ts-ignore\n      this.popoverRef = undefined;\n      this.popperInstance?.destroy();\n      this.viewContainerRef?.detach();\n      this.viewContainerRef?.clear();\n    }\n    addPopoverElement() {\n      if (!this.popoverRef) {\n        this.createPopoverElement();\n      }\n      this.popoverRef.instance.content = this.content;\n      this.popover = this.popoverRef.location.nativeElement;\n      this.renderer.addClass(this.popover, 'd-none');\n      this.renderer.addClass(this.popover, 'fade');\n      this.popperInstance?.destroy();\n      setTimeout(() => {\n        this.popperInstance = createPopper(this.hostElement.nativeElement, this.popover, {\n          ...this.popperOptions\n        });\n        this.viewContainerRef.insert(this.popoverRef.hostView);\n        this.renderer.appendChild(this.document.body, this.popover);\n        if (!this.visible) {\n          this.removePopoverElement();\n          return;\n        }\n        setTimeout(() => {\n          this.popoverId = this.getUID('popover');\n          this.popoverRef.instance.id = this.popoverId;\n          if (!this.visible) {\n            this.removePopoverElement();\n            return;\n          }\n          this.renderer.removeClass(this.popover, 'd-none');\n          this.popoverRef.instance.visible = this.visible;\n          this.popperInstance.forceUpdate();\n          this.changeDetectorRef.markForCheck();\n        }, 100);\n      });\n    }\n    removePopoverElement() {\n      this.popoverId = '';\n      if (!this.popoverRef) {\n        return;\n      }\n      this.popoverRef.instance.visible = false;\n      this.popoverRef.instance.id = undefined;\n      this.changeDetectorRef.markForCheck();\n      setTimeout(() => {\n        this.viewContainerRef.detach();\n      }, 300);\n    }\n  }\n  PopoverDirective.ɵfac = function PopoverDirective_Factory(t) {\n    return new (t || PopoverDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(ListenersService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  PopoverDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverDirective,\n    selectors: [[\"\", \"cPopover\", \"\"]],\n    hostVars: 1,\n    hostBindings: function PopoverDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-describedby\", ctx.ariaDescribedBy);\n      }\n    },\n    inputs: {\n      content: [\"cPopover\", \"content\"],\n      popperOptions: [\"cPopoverOptions\", \"popperOptions\"],\n      placement: [\"cPopoverPlacement\", \"placement\"],\n      trigger: [\"cPopoverTrigger\", \"trigger\"],\n      visible: [\"cPopoverVisible\", \"visible\"]\n    },\n    exportAs: [\"cPopover\"],\n    features: [i0.ɵɵProvidersFeature([ListenersService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return PopoverDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PopoverModule = /*#__PURE__*/(() => {\n  class PopoverModule {}\n  PopoverModule.ɵfac = function PopoverModule_Factory(t) {\n    return new (t || PopoverModule)();\n  };\n  PopoverModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PopoverModule\n  });\n  PopoverModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return PopoverModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProgressComponent = /*#__PURE__*/(() => {\n  class ProgressComponent {\n    constructor() {\n      this._height = 0;\n      this._thin = false;\n      this._white = false;\n    }\n    /**\n     * Sets the height of the component. If you set that value the inner `<CProgressBar>` will automatically resize accordingly.\n     * @type number\n     */\n    set height(value) {\n      this._height = coerceNumberProperty(value);\n    }\n    get height() {\n      return this._height;\n    }\n    /**\n     * Displays thin progress.\n     * @type boolean\n     */\n    set thin(value) {\n      this._thin = coerceBooleanProperty(value);\n    }\n    get thin() {\n      return this._thin;\n    }\n    /**\n     * Change the default color to white.\n     * @type boolean\n     */\n    get white() {\n      return this._white;\n    }\n    set white(value) {\n      this._white = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        progress: true,\n        'progress-thin': this.thin,\n        'progress-white': this.white\n      };\n    }\n    get hostStyle() {\n      return !!this.height ? `${this.height}px` : '';\n    }\n  }\n  ProgressComponent.ɵfac = function ProgressComponent_Factory(t) {\n    return new (t || ProgressComponent)();\n  };\n  ProgressComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ProgressComponent,\n    selectors: [[\"c-progress\"]],\n    hostVars: 4,\n    hostBindings: function ProgressComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n        i0.ɵɵstyleProp(\"height\", ctx.hostStyle);\n      }\n    },\n    inputs: {\n      height: \"height\",\n      thin: \"thin\",\n      white: \"white\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ProgressComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ProgressComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProgressBarComponent = /*#__PURE__*/(() => {\n  class ProgressBarComponent {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this._animated = false;\n      // TODO: check if this is necessary.\n      this.precision = 0;\n      this._value = 0;\n      /**\n       * Set default html role attribute.\n       * @type string\n       */\n      this.role = 'progressbar';\n      this.state = {\n        percent: 0,\n        min: 0,\n        max: 100\n      };\n    }\n    /**\n     * Use to animate the stripes right to left via CSS3 animations.\n     * @type boolean\n     */\n    set animated(value) {\n      this._animated = coerceBooleanProperty(value);\n    }\n    get animated() {\n      return this._animated;\n    }\n    /**\n     * The percent to progress the ProgressBar.\n     */\n    set value(value) {\n      this._value = coerceNumberProperty(value);\n    }\n    get value() {\n      return this._value;\n    }\n    get min() {\n      return this.state.min;\n    }\n    set min(value) {\n      this.state.min = isNaN(value) ? 0 : value;\n    }\n    get max() {\n      return this.state.max;\n    }\n    set max(value) {\n      this.state.max = isNaN(value) || value <= 0 || value === this.min ? 100 : value;\n    }\n    get hostClasses() {\n      return {\n        'progress-bar': true,\n        'progress-bar-animated': this.animated,\n        [`progress-bar-${this.variant}`]: !!this.variant,\n        [`bg-${this.color}`]: !!this.color\n      };\n    }\n    ngOnInit() {\n      this.setValues();\n    }\n    setPercent() {\n      this.state.percent = +(this.value / (this.max - this.min) * 100).toFixed(this.precision);\n    }\n    setValues() {\n      this.setPercent();\n      const host = this.hostElement.nativeElement;\n      this.renderer.setStyle(host, 'width', `${this.state.percent}%`);\n      this.renderer.setAttribute(host, 'aria-valuenow', String(this.value));\n      this.renderer.setAttribute(host, 'aria-valuemin', String(this.min));\n      this.renderer.setAttribute(host, 'aria-valuemax', String(this.max));\n    }\n    ngOnChanges(changes) {\n      this.setValues();\n    }\n  }\n  ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) {\n    return new (t || ProgressBarComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  ProgressBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ProgressBarComponent,\n    selectors: [[\"c-progress-bar\"]],\n    hostVars: 3,\n    hostBindings: function ProgressBarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      animated: \"animated\",\n      color: \"color\",\n      precision: \"precision\",\n      value: \"value\",\n      variant: \"variant\",\n      role: \"role\",\n      min: \"min\",\n      max: \"max\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ProgressBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ProgressBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProgressModule = /*#__PURE__*/(() => {\n  class ProgressModule {}\n  ProgressModule.ɵfac = function ProgressModule_Factory(t) {\n    return new (t || ProgressModule)();\n  };\n  ProgressModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProgressModule\n  });\n  ProgressModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return ProgressModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClassToggleService = /*#__PURE__*/(() => {\n  class ClassToggleService {\n    constructor(document, rendererFactory) {\n      this.document = document;\n      this.rendererFactory = rendererFactory;\n      this.renderer = rendererFactory.createRenderer(null, null);\n    }\n    toggle(selector, className) {\n      const element = document.querySelector(selector);\n      if (element) {\n        element.classList.contains(className) ? this.renderer.removeClass(element, className) : this.renderer.addClass(element, className);\n      }\n    }\n  }\n  ClassToggleService.ɵfac = function ClassToggleService_Factory(t) {\n    return new (t || ClassToggleService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.RendererFactory2));\n  };\n  ClassToggleService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClassToggleService,\n    factory: ClassToggleService.ɵfac,\n    providedIn: 'root'\n  });\n  return ClassToggleService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SpinnerComponent = /*#__PURE__*/(() => {\n  class SpinnerComponent {\n    constructor() {\n      /**\n       * Label for accessibility.\n       * @type string\n       * @default 'Loading...'\n       */\n      this.label = \"Loading...\";\n      /**\n       * Set the button variant to an outlined button or a ghost button.\n       * @values 'border' | 'grow'\n       * @default 'border'\n       */\n      this.variant = 'border';\n      this.role = 'status';\n    }\n    get hostClasses() {\n      return {\n        [`spinner-${this.variant}`]: true,\n        [`text-${this.color}`]: !!this.color,\n        [`spinner-${this.variant}-${this.size}`]: !!this.size\n      };\n    }\n  }\n  SpinnerComponent.ɵfac = function SpinnerComponent_Factory(t) {\n    return new (t || SpinnerComponent)();\n  };\n  SpinnerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SpinnerComponent,\n    selectors: [[\"c-spinner\"]],\n    hostVars: 3,\n    hostBindings: function SpinnerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      label: \"label\",\n      size: \"size\",\n      variant: \"variant\",\n      role: \"role\"\n    },\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"visually-hidden\"]],\n    template: function SpinnerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.label);\n      }\n    },\n    encapsulation: 2\n  });\n  return SpinnerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SpinnerModule = /*#__PURE__*/(() => {\n  class SpinnerModule {}\n  SpinnerModule.ɵfac = function SpinnerModule_Factory(t) {\n    return new (t || SpinnerModule)();\n  };\n  SpinnerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SpinnerModule\n  });\n  SpinnerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, SharedModule]\n  });\n  return SpinnerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarService = /*#__PURE__*/(() => {\n  class SidebarService {\n    constructor() {\n      this.sidebarState = new BehaviorSubject({});\n      this.sidebarState$ = this.sidebarState.asObservable();\n    }\n    toggle(action) {\n      this.sidebarState.next(action);\n    }\n  }\n  SidebarService.ɵfac = function SidebarService_Factory(t) {\n    return new (t || SidebarService)();\n  };\n  SidebarService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SidebarService,\n    factory: SidebarService.ɵfac,\n    providedIn: 'root'\n  });\n  return SidebarService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarBackdropService = /*#__PURE__*/(() => {\n  class SidebarBackdropService {\n    constructor(document,\n    // private rendererFactory: RendererFactory2,\n    sidebarService) {\n      this.document = document;\n      this.sidebarService = sidebarService;\n      this.clickListener = () => {};\n      // this.renderer = rendererFactory.createRenderer(null, null);\n    }\n\n    setBackdrop(sidebar) {\n      const backdrop = this.document.getElementsByClassName('sidebar-backdrop');\n      // console.log(`sidebar-${this.id}`, ' setBackdrop', backdrop);\n      if (backdrop.length === 0) {\n        this.backdrop = this.renderer.createElement('div');\n        this.renderer.addClass(this.backdrop, 'sidebar-backdrop');\n        this.renderer.appendChild(this.document.body, this.backdrop);\n        this.clickListener = this.renderer.listen(this.backdrop, 'click', e => {\n          // console.log(`sidebar-${this.id}`, ' backdrop click', e);\n          this.sidebarService.toggle({\n            toggle: 'visible',\n            sidebar\n          });\n        });\n      }\n      // console.log(this.backdrop, sidebar.sidebarState.mobile, sidebar.sidebarState.show);\n      if (this.backdrop && sidebar.sidebarState.mobile && sidebar.sidebarState.visible) {\n        this.renderer.addClass(this.backdrop, 'fade');\n        this.renderer.addClass(this.backdrop, 'show');\n        // this.renderer.removeClass(this.backdrop, 'd-none');\n      } else {\n        this.renderer.removeClass(this.backdrop, 'show');\n        this.renderer.removeClass(this.backdrop, 'fade');\n        // this.renderer.addClass(this.backdrop, 'd-none');\n      }\n    }\n\n    clearBackdrop() {\n      if (this.backdrop) {\n        // clear backdrop click Listener\n        this.clickListener();\n        // this.renderer.listen(this.backdrop, 'click', (e): void => {} );\n        this.renderer.removeChild(this.document.body, this.backdrop);\n        // @ts-ignore\n        this.backdrop = undefined;\n      }\n    }\n  }\n  SidebarBackdropService.ɵfac = function SidebarBackdropService_Factory(t) {\n    return new (t || SidebarBackdropService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(SidebarService));\n  };\n  SidebarBackdropService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SidebarBackdropService,\n    factory: SidebarBackdropService.ɵfac,\n    providedIn: 'root'\n  });\n  return SidebarBackdropService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar _SidebarComponent_narrow, _SidebarComponent_overlaid, _SidebarComponent_unfoldable, _SidebarComponent_visible, _SidebarComponent_onMobile, _SidebarComponent_layoutChangeSubscription, _SidebarComponent_stateToggleSubscription, _SidebarComponent_stateInitial;\nclass SidebarComponent {\n  constructor(document, renderer, breakpointObserver, sidebarService, backdropService) {\n    this.document = document;\n    this.renderer = renderer;\n    this.breakpointObserver = breakpointObserver;\n    this.sidebarService = sidebarService;\n    this.backdropService = backdropService;\n    _SidebarComponent_narrow.set(this, false);\n    _SidebarComponent_overlaid.set(this, false);\n    _SidebarComponent_unfoldable.set(this, false);\n    _SidebarComponent_visible.set(this, false);\n    _SidebarComponent_onMobile.set(this, false);\n    _SidebarComponent_layoutChangeSubscription.set(this, void 0);\n    _SidebarComponent_stateToggleSubscription.set(this, void 0);\n    this.state = {\n      sidebar: this\n    };\n    _SidebarComponent_stateInitial.set(this, {\n      narrow: false,\n      visible: false,\n      unfoldable: false\n    });\n    /**\n     * Place sidebar in non-static positions. [docs]\n     * @default 'fixed'\n     */\n    this.position = 'fixed';\n    /**\n     * Event emitted on visibility change. [docs]\n     * @type boolean\n     */\n    this.visibleChange = new EventEmitter();\n    this.backdropService.renderer = renderer;\n  }\n  /**\n   * Make sidebar narrow. [docs]\n   * @type boolean\n   */\n  set narrow(value) {\n    __classPrivateFieldSet(this, _SidebarComponent_narrow, coerceBooleanProperty(value), \"f\");\n  }\n  get narrow() {\n    return __classPrivateFieldGet(this, _SidebarComponent_narrow, \"f\");\n  }\n  /**\n   * Set sidebar to overlaid variant.\n   * @type boolean\n   */\n  set overlaid(value) {\n    __classPrivateFieldSet(this, _SidebarComponent_overlaid, coerceBooleanProperty(value), \"f\");\n  }\n  get overlaid() {\n    return __classPrivateFieldGet(this, _SidebarComponent_overlaid, \"f\");\n  }\n  /**\n   * Expand narrowed sidebar on hover. [docs]\n   */\n  set unfoldable(value) {\n    __classPrivateFieldSet(this, _SidebarComponent_unfoldable, coerceBooleanProperty(value), \"f\");\n  }\n  get unfoldable() {\n    return __classPrivateFieldGet(this, _SidebarComponent_unfoldable, \"f\");\n  }\n  /**\n   * Toggle the visibility of sidebar component. [docs]\n   */\n  set visible(value) {\n    const visible = coerceBooleanProperty(value);\n    if (__classPrivateFieldGet(this, _SidebarComponent_visible, \"f\") !== visible) {\n      __classPrivateFieldSet(this, _SidebarComponent_visible, visible, \"f\");\n      this.visibleChange.emit(__classPrivateFieldGet(this, _SidebarComponent_visible, \"f\"));\n    }\n  }\n  get visible() {\n    return __classPrivateFieldGet(this, _SidebarComponent_visible, \"f\");\n  }\n  set sidebarState(value) {\n    const newState = value;\n    if ('toggle' in newState) {\n      if (newState.toggle === 'visible') {\n        newState.visible = !this.state.visible;\n        this.visible = newState.visible;\n      } else if (newState.toggle === 'unfoldable') {\n        newState.unfoldable = !this.state.unfoldable;\n        this.unfoldable = newState.unfoldable;\n      }\n    } else {\n      this.visible = (newState.visible ?? this.visible) && !this.overlaid;\n    }\n    this.state = {\n      ...this.state,\n      ...newState\n    };\n    this.state.mobile && this.state.visible ? this.backdropService.setBackdrop(this) : this.backdropService.clearBackdrop();\n  }\n  get sidebarState() {\n    return this.state;\n  }\n  get getMobileBreakpoint() {\n    const element = this.document.documentElement;\n    const mobileBreakpoint = getComputedStyle(element).getPropertyValue('--cui-mobile-breakpoint') || 'md';\n    const breakpointValue = getComputedStyle(element).getPropertyValue(`--cui-breakpoint-${mobileBreakpoint.trim()}`) || '768px';\n    return `${parseFloat(breakpointValue.trim()) - 0.02}px` || '767.98px';\n  }\n  get getClasses() {\n    const {\n      mobile,\n      visible\n    } = this.sidebarState;\n    return {\n      sidebar: true,\n      'sidebar-fixed': this.position === 'fixed' && !mobile,\n      'sidebar-narrow': this.narrow && !this.unfoldable,\n      'sidebar-narrow-unfoldable': this.unfoldable,\n      'sidebar-overlaid': this.overlaid,\n      [`sidebar-${this.size}`]: !!this.size,\n      show: visible && __classPrivateFieldGet(this, _SidebarComponent_onMobile, \"f\"),\n      hide: !visible\n    };\n  }\n  ngOnInit() {\n    this.setInitialState();\n    this.layoutChangeSubscribe();\n    this.stateToggleSubscribe();\n  }\n  ngOnDestroy() {\n    this.stateToggleSubscribe(false);\n    this.layoutChangeSubscribe(false);\n  }\n  ngOnChanges(changes) {\n    const oldStateMap = new Map(Object.entries(this.state));\n    const newStateMap = new Map();\n    newStateMap.set('sidebar', this);\n    const propList = ['visible', 'unfoldable', 'narrow'];\n    for (const propName in changes) {\n      if (propList.includes(propName)) {\n        if (changes[propName] && !changes[propName].firstChange) {\n          const value = coerceBooleanProperty(changes[propName].currentValue);\n          if (oldStateMap.get(propName) !== value) {\n            newStateMap.set(propName, value);\n          }\n        }\n      }\n    }\n    if (newStateMap.size > 1) {\n      const state = Object.fromEntries(newStateMap.entries());\n      this.sidebarService.toggle(state);\n    }\n  }\n  setInitialState() {\n    __classPrivateFieldSet(this, _SidebarComponent_stateInitial, {\n      narrow: this.narrow,\n      visible: this.visible,\n      unfoldable: this.unfoldable\n    }, \"f\");\n    this.sidebarService.toggle({\n      ...__classPrivateFieldGet(this, _SidebarComponent_stateInitial, \"f\"),\n      sidebar: this\n    });\n  }\n  stateToggleSubscribe(subscribe = true) {\n    if (subscribe) {\n      __classPrivateFieldSet(this, _SidebarComponent_stateToggleSubscription, this.sidebarService.sidebarState$.subscribe(state => {\n        if (this === state.sidebar || this.id === state.id) {\n          this.sidebarState = state;\n        }\n      }), \"f\");\n    } else {\n      __classPrivateFieldGet(this, _SidebarComponent_stateToggleSubscription, \"f\").unsubscribe();\n    }\n  }\n  layoutChangeSubscribe(subscribe = true) {\n    const onMobile = `(max-width: ${this.getMobileBreakpoint})`;\n    if (subscribe) {\n      const layoutChanges = this.breakpointObserver.observe([onMobile]);\n      __classPrivateFieldSet(this, _SidebarComponent_layoutChangeSubscription, layoutChanges.subscribe(result => {\n        const isOnMobile = result.breakpoints[onMobile];\n        const isUnfoldable = isOnMobile ? false : this.unfoldable;\n        if (__classPrivateFieldGet(this, _SidebarComponent_onMobile, \"f\") !== isOnMobile) {\n          __classPrivateFieldSet(this, _SidebarComponent_onMobile, isOnMobile, \"f\");\n          this.sidebarService.toggle({\n            mobile: isOnMobile,\n            unfoldable: isUnfoldable,\n            visible: isOnMobile ? !isOnMobile : __classPrivateFieldGet(this, _SidebarComponent_stateInitial, \"f\").visible,\n            sidebar: this\n          });\n        }\n      }), \"f\");\n    } else {\n      __classPrivateFieldGet(this, _SidebarComponent_layoutChangeSubscription, \"f\").unsubscribe();\n    }\n  }\n}\n_SidebarComponent_narrow = new WeakMap(), _SidebarComponent_overlaid = new WeakMap(), _SidebarComponent_unfoldable = new WeakMap(), _SidebarComponent_visible = new WeakMap(), _SidebarComponent_onMobile = new WeakMap(), _SidebarComponent_layoutChangeSubscription = new WeakMap(), _SidebarComponent_stateToggleSubscription = new WeakMap(), _SidebarComponent_stateInitial = new WeakMap();\nSidebarComponent.ɵfac = function SidebarComponent_Factory(t) {\n  return new (t || SidebarComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1$2.BreakpointObserver), i0.ɵɵdirectiveInject(SidebarService), i0.ɵɵdirectiveInject(SidebarBackdropService));\n};\nSidebarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: SidebarComponent,\n  selectors: [[\"c-sidebar\"]],\n  hostVars: 2,\n  hostBindings: function SidebarComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassMap(ctx.getClasses);\n    }\n  },\n  inputs: {\n    colorScheme: \"colorScheme\",\n    id: \"id\",\n    narrow: \"narrow\",\n    overlaid: \"overlaid\",\n    placement: \"placement\",\n    position: \"position\",\n    size: \"size\",\n    unfoldable: \"unfoldable\",\n    visible: \"visible\"\n  },\n  outputs: {\n    visibleChange: \"visibleChange\"\n  },\n  exportAs: [\"cSidebar\"],\n  features: [i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function SidebarComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n    }\n  },\n  encapsulation: 2\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarBrandComponent = /*#__PURE__*/(() => {\n  class SidebarBrandComponent {\n    constructor() {\n      this.sidebarBrandClass = true;\n      this.brandImg = false;\n    }\n    ngOnInit() {\n      this.brandImg = Boolean(this.brandFull || this.brandNarrow);\n    }\n  }\n  SidebarBrandComponent.ɵfac = function SidebarBrandComponent_Factory(t) {\n    return new (t || SidebarBrandComponent)();\n  };\n  SidebarBrandComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarBrandComponent,\n    selectors: [[\"c-sidebar-brand\"]],\n    hostVars: 2,\n    hostBindings: function SidebarBrandComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"sidebar-brand\", ctx.sidebarBrandClass);\n      }\n    },\n    inputs: {\n      brandFull: \"brandFull\",\n      brandNarrow: \"brandNarrow\",\n      routerLink: \"routerLink\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[3, \"ngIf\"], [3, \"routerLink\"], [3, \"cHtmlAttr\", \"ngClass\", 4, \"ngIf\"], [3, \"cHtmlAttr\", \"ngClass\"]],\n    template: function SidebarBrandComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, SidebarBrandComponent_ng_template_0_Template, 3, 3, \"ng-template\", 0);\n        i0.ɵɵtemplate(1, SidebarBrandComponent_ng_template_1_Template, 1, 0, \"ng-template\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.brandImg);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.brandImg);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i3.RouterLink, HtmlAttributesDirective],\n    encapsulation: 2\n  });\n  return SidebarBrandComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Allows the sidebar to be toggled/folded via click on host element.\n */\nlet SidebarToggleDirective = /*#__PURE__*/(() => {\n  class SidebarToggleDirective {\n    constructor(sidebarService) {\n      this.sidebarService = sidebarService;\n      /**\n       * Sidebar property name for toggle action. [docs]\n       *\n       * @type 'visible' | 'unfoldable'\n       * @default 'visible'\n       */\n      this.toggle = 'visible';\n    }\n    toggleOpen($event) {\n      $event.preventDefault();\n      this.sidebarService.toggle({\n        toggle: this.toggle,\n        id: this.id\n      });\n    }\n  }\n  SidebarToggleDirective.ɵfac = function SidebarToggleDirective_Factory(t) {\n    return new (t || SidebarToggleDirective)(i0.ɵɵdirectiveInject(SidebarService));\n  };\n  SidebarToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SidebarToggleDirective,\n    selectors: [[\"\", \"cSidebarToggle\", \"\"]],\n    hostBindings: function SidebarToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function SidebarToggleDirective_click_HostBindingHandler($event) {\n          return ctx.toggleOpen($event);\n        });\n      }\n    },\n    inputs: {\n      id: [\"cSidebarToggle\", \"id\"],\n      toggle: \"toggle\"\n    },\n    exportAs: [\"cSidebarToggle\"]\n  });\n  return SidebarToggleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarTogglerComponent = /*#__PURE__*/(() => {\n  class SidebarTogglerComponent {\n    constructor() {\n      this.role = 'button';\n      this.sidebarTogglerClass = true;\n    }\n  }\n  SidebarTogglerComponent.ɵfac = function SidebarTogglerComponent_Factory(t) {\n    return new (t || SidebarTogglerComponent)();\n  };\n  SidebarTogglerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarTogglerComponent,\n    selectors: [[\"c-sidebar-toggler\"]],\n    hostVars: 3,\n    hostBindings: function SidebarTogglerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"sidebar-toggler\", ctx.sidebarTogglerClass);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function SidebarTogglerComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SidebarTogglerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarHeaderComponent = /*#__PURE__*/(() => {\n  class SidebarHeaderComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'sidebar-header': true\n      };\n    }\n  }\n  SidebarHeaderComponent.ɵfac = function SidebarHeaderComponent_Factory(t) {\n    return new (t || SidebarHeaderComponent)();\n  };\n  SidebarHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarHeaderComponent,\n    selectors: [[\"c-sidebar-header\"]],\n    hostVars: 2,\n    hostBindings: function SidebarHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function SidebarHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return SidebarHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarFooterComponent = /*#__PURE__*/(() => {\n  class SidebarFooterComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'sidebar-footer': true\n      };\n    }\n  }\n  SidebarFooterComponent.ɵfac = function SidebarFooterComponent_Factory(t) {\n    return new (t || SidebarFooterComponent)();\n  };\n  SidebarFooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarFooterComponent,\n    selectors: [[\"c-sidebar-footer\"]],\n    hostVars: 2,\n    hostBindings: function SidebarFooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function SidebarFooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return SidebarFooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavService = /*#__PURE__*/(() => {\n  class SidebarNavService {}\n  SidebarNavService.ɵfac = function SidebarNavService_Factory(t) {\n    return new (t || SidebarNavService)();\n  };\n  SidebarNavService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SidebarNavService,\n    factory: SidebarNavService.ɵfac\n  });\n  return SidebarNavService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavHelper = /*#__PURE__*/(() => {\n  class SidebarNavHelper {\n    constructor() {\n      this.hasBadge = item => Boolean(item.badge);\n      this.hasIcon = item => Boolean(item.icon) || item.icon === '';\n      this.hasIconComponent = item => Boolean(item.iconComponent);\n    }\n    itemType(item) {\n      if (item.divider) {\n        return 'divider';\n      } else if (item.title) {\n        return 'title';\n      } else if (item.children && item.children.length > 0) {\n        return 'group';\n      } else if (item.label) {\n        return 'label';\n      } else if (!Object.keys(item).length) {\n        return 'empty';\n      } else {\n        return 'link';\n      }\n    }\n    isActive(router, item) {\n      return router.isActive(item.url, false);\n    }\n    getIconClass(item) {\n      const classes = {\n        'nav-icon': true\n      };\n      const icon = item.icon;\n      // @ts-ignore\n      classes[icon] = this.hasIcon(item);\n      return classes;\n    }\n  }\n  SidebarNavHelper.ɵfac = function SidebarNavHelper_Factory(t) {\n    return new (t || SidebarNavHelper)();\n  };\n  SidebarNavHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SidebarNavHelper,\n    factory: SidebarNavHelper.ɵfac\n  });\n  return SidebarNavHelper;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavDividerComponent = /*#__PURE__*/(() => {\n  class SidebarNavDividerComponent {\n    constructor() {}\n  }\n  SidebarNavDividerComponent.ɵfac = function SidebarNavDividerComponent_Factory(t) {\n    return new (t || SidebarNavDividerComponent)();\n  };\n  SidebarNavDividerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavDividerComponent,\n    selectors: [[\"c-sidebar-nav-divider\"]],\n    inputs: {\n      item: \"item\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function SidebarNavDividerComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SidebarNavDividerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavBadgePipe = /*#__PURE__*/(() => {\n  class SidebarNavBadgePipe {\n    transform(item, args) {\n      const badge = item.badge;\n      return {\n        badge: true,\n        'ms-auto': true,\n        'badge-sm': !badge.size,\n        [`badge-${badge.size}`]: !!badge.size,\n        [`bg-${badge.color}`]: !!badge.color,\n        [`${badge.class}`]: !!badge.class\n      };\n    }\n  }\n  SidebarNavBadgePipe.ɵfac = function SidebarNavBadgePipe_Factory(t) {\n    return new (t || SidebarNavBadgePipe)();\n  };\n  SidebarNavBadgePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cSidebarNavBadge\",\n    type: SidebarNavBadgePipe,\n    pure: true\n  });\n  return SidebarNavBadgePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavLabelComponent = /*#__PURE__*/(() => {\n  class SidebarNavLabelComponent {\n    constructor(helper) {\n      this.helper = helper;\n      this.classes = {\n        'c-nav-label': true,\n        'c-active': true\n      };\n      this.iconClasses = {};\n    }\n    ngOnInit() {\n      this.iconClasses = this.helper.getIconClass(this.item);\n    }\n    getItemClass() {\n      const itemClass = this.item.class;\n      // @ts-ignore\n      this.classes[itemClass] = !!itemClass;\n      return this.classes;\n    }\n    getLabelIconClass() {\n      const variant = `text-${this.item.label.variant}`;\n      // @ts-ignore\n      this.iconClasses[variant] = !!this.item.label.variant;\n      const labelClass = this.item.label.class;\n      // @ts-ignore\n      this.iconClasses[labelClass] = !!labelClass;\n      return this.iconClasses;\n    }\n  }\n  SidebarNavLabelComponent.ɵfac = function SidebarNavLabelComponent_Factory(t) {\n    return new (t || SidebarNavLabelComponent)(i0.ɵɵdirectiveInject(SidebarNavHelper));\n  };\n  SidebarNavLabelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavLabelComponent,\n    selectors: [[\"c-sidebar-nav-label\"]],\n    inputs: {\n      item: \"item\"\n    },\n    decls: 5,\n    vars: 6,\n    consts: [[3, \"ngClass\", \"href\", \"cHtmlAttr\"], [3, \"ngClass\", 4, \"ngIf\"], [3, \"ngClass\"]],\n    template: function SidebarNavLabelComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"a\", 0);\n        i0.ɵɵtemplate(1, SidebarNavLabelComponent_i_1_Template, 1, 1, \"i\", 1);\n        i0.ɵɵelementContainerStart(2);\n        i0.ɵɵtext(3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(4, SidebarNavLabelComponent_span_4_Template, 3, 4, \"span\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵpropertyInterpolate(\"href\", ctx.item.url, i0.ɵɵsanitizeUrl);\n        i0.ɵɵproperty(\"ngClass\", ctx.getItemClass())(\"cHtmlAttr\", ctx.item.attributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.helper.hasIcon(ctx.item));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.item.name);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.helper.hasBadge(ctx.item));\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, HtmlAttributesDirective, SidebarNavBadgePipe],\n    encapsulation: 2\n  });\n  return SidebarNavLabelComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavIconPipe = /*#__PURE__*/(() => {\n  class SidebarNavIconPipe {\n    transform(item, args) {\n      const icon = item.icon;\n      const classes = {\n        'nav-icon': true,\n        [`${icon}`]: !!icon\n      };\n      return classes;\n    }\n  }\n  SidebarNavIconPipe.ɵfac = function SidebarNavIconPipe_Factory(t) {\n    return new (t || SidebarNavIconPipe)();\n  };\n  SidebarNavIconPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cSidebarNavIcon\",\n    type: SidebarNavIconPipe,\n    pure: true\n  });\n  return SidebarNavIconPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavLinkPipe = /*#__PURE__*/(() => {\n  class SidebarNavLinkPipe {\n    transform(item) {\n      const disabled = item?.attributes?.disabled;\n      const classes = {\n        'nav-link': true,\n        disabled,\n        'btn-link': disabled,\n        [`nav-link-${item.variant}`]: !!item.variant\n      };\n      return classes;\n    }\n  }\n  SidebarNavLinkPipe.ɵfac = function SidebarNavLinkPipe_Factory(t) {\n    return new (t || SidebarNavLinkPipe)();\n  };\n  SidebarNavLinkPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cSidebarNavLink\",\n    type: SidebarNavLinkPipe,\n    pure: true\n  });\n  return SidebarNavLinkPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavLinkContentComponent = /*#__PURE__*/(() => {\n  class SidebarNavLinkContentComponent {\n    constructor(helper) {\n      this.helper = helper;\n    }\n  }\n  SidebarNavLinkContentComponent.ɵfac = function SidebarNavLinkContentComponent_Factory(t) {\n    return new (t || SidebarNavLinkContentComponent)(i0.ɵɵdirectiveInject(SidebarNavHelper));\n  };\n  SidebarNavLinkContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavLinkContentComponent,\n    selectors: [[\"c-sidebar-nav-link-content\"]],\n    inputs: {\n      item: \"item\"\n    },\n    features: [i0.ɵɵProvidersFeature([SidebarNavHelper])],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function SidebarNavLinkContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, SidebarNavLinkContentComponent_ng_container_0_Template, 3, 1, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", true);\n      }\n    },\n    dependencies: [i1$1.NgIf],\n    encapsulation: 2\n  });\n  return SidebarNavLinkContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavLinkComponent = /*#__PURE__*/(() => {\n  class SidebarNavLinkComponent {\n    constructor(router) {\n      this.router = router;\n      // tslint:disable-next-line:variable-name\n      this._item = {};\n      this.linkClick = new EventEmitter();\n      this.navigationEndObservable = router.events.pipe(filter(event => {\n        return event instanceof NavigationEnd;\n      }));\n    }\n    set item(item) {\n      this._item = JSON.parse(JSON.stringify(item));\n    }\n    get item() {\n      return this._item;\n    }\n    ngOnInit() {\n      // @ts-ignore\n      this.url = typeof this.item.url === 'string' ? this.item.url : this.router.serializeUrl(this.router.createUrlTree(this.item.url));\n      this.linkType = this.getLinkType();\n      this.href = this.isDisabled() ? '' : this.item.href || this.url;\n      this.linkActive = this.router.url.split(/[?#(;]/)[0] === this.href.split(/[?#(;]/)[0];\n      this.navSubscription = this.navigationEndObservable.subscribe(event => {\n        const itemUrlArray = this.href.split(/[?#(;]/)[0].split('/');\n        const urlArray = event.urlAfterRedirects.split(/[?#(;]/)[0].split('/');\n        this.linkActive = itemUrlArray.every((value, index) => value === urlArray[index]);\n      });\n    }\n    ngOnDestroy() {\n      this.navSubscription.unsubscribe();\n    }\n    getLinkType() {\n      return this.isDisabled() ? 'disabled' : this.isExternalLink() ? 'external' : 'link';\n    }\n    isDisabled() {\n      return this.item?.attributes?.['disabled'];\n    }\n    isExternalLink() {\n      const linkPath = Array.isArray(this.item.url) ? this.item.url[0] : this.item.url;\n      return !!this.item.href || linkPath.substring(0, 4) === 'http';\n    }\n    linkClicked() {\n      this.linkClick.emit();\n    }\n  }\n  SidebarNavLinkComponent.ɵfac = function SidebarNavLinkComponent_Factory(t) {\n    return new (t || SidebarNavLinkComponent)(i0.ɵɵdirectiveInject(i3.Router));\n  };\n  SidebarNavLinkComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavLinkComponent,\n    selectors: [[\"c-sidebar-nav-link\"]],\n    inputs: {\n      item: \"item\"\n    },\n    outputs: {\n      linkClick: \"linkClick\"\n    },\n    features: [i0.ɵɵProvidersFeature([SidebarNavHelper])],\n    decls: 6,\n    vars: 3,\n    consts: [[3, \"ngSwitch\"], [3, \"ngClass\", \"cHtmlAttr\", 4, \"ngSwitchCase\"], [3, \"ngClass\", \"href\", \"cHtmlAttr\", \"click\", 4, \"ngSwitchCase\"], [\"routerLinkActive\", \"active\", 3, \"ngClass\", \"cHtmlAttr\", \"target\", \"queryParams\", \"fragment\", \"queryParamsHandling\", \"preserveFragment\", \"skipLocationChange\", \"replaceUrl\", \"state\", \"routerLink\", \"routerLinkActiveOptions\", \"click\", 4, \"ngSwitchDefault\"], [\"iconTemplate\", \"\"], [3, \"ngClass\", \"cHtmlAttr\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"item\"], [3, \"ngClass\", 4, \"ngIf\"], [3, \"ngClass\"], [3, \"ngClass\", \"href\", \"cHtmlAttr\", \"click\"], [\"routerLinkActive\", \"active\", 3, \"ngClass\", \"cHtmlAttr\", \"target\", \"queryParams\", \"fragment\", \"queryParamsHandling\", \"preserveFragment\", \"skipLocationChange\", \"replaceUrl\", \"state\", \"routerLink\", \"routerLinkActiveOptions\", \"click\"], [3, \"ngIf\"], [3, \"cIcon\", \"name\", \"customClasses\"]],\n    template: function SidebarNavLinkComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵtemplate(1, SidebarNavLinkComponent_a_1_Template, 5, 11, \"a\", 1);\n        i0.ɵɵtemplate(2, SidebarNavLinkComponent_a_2_Template, 5, 12, \"a\", 2);\n        i0.ɵɵtemplate(3, SidebarNavLinkComponent_a_3_Template, 5, 23, \"a\", 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(4, SidebarNavLinkComponent_ng_template_4_Template, 3, 3, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngSwitch\", ctx.linkType);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"disabled\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"external\");\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet, i1$1.NgSwitch, i1$1.NgSwitchCase, i1$1.NgSwitchDefault, i3.RouterLink, i3.RouterLinkActive, HtmlAttributesDirective, i5.IconDirective, SidebarNavLinkContentComponent, SidebarNavBadgePipe, SidebarNavIconPipe, SidebarNavLinkPipe],\n    encapsulation: 2\n  });\n  return SidebarNavLinkComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavTitleComponent = /*#__PURE__*/(() => {\n  class SidebarNavTitleComponent {\n    constructor(el, renderer) {\n      this.el = el;\n      this.renderer = renderer;\n    }\n    ngOnInit() {\n      const nativeElement = this.el.nativeElement;\n      const name = this.renderer.createText(this.item.name);\n      if (this.item.class) {\n        const classes = this.item.class;\n        this.renderer.addClass(nativeElement, classes);\n      }\n      if (this.item.wrapper) {\n        const wrapper = this.renderer.createElement(this.item.wrapper.element);\n        this.addAttribs(this.item.wrapper.attributes, wrapper);\n        this.renderer.appendChild(wrapper, name);\n        this.renderer.appendChild(nativeElement, wrapper);\n      } else {\n        this.renderer.appendChild(nativeElement, name);\n      }\n    }\n    addAttribs(attribs, element) {\n      if (attribs) {\n        for (const attr in attribs) {\n          if (attr === 'style' && typeof attribs[attr] === 'object') {\n            this.setStyle(attribs[attr], element);\n          } else if (attr === 'class') {\n            this.addClass(attribs[attr], element);\n          } else {\n            this.setAttrib(attr, attribs[attr], element);\n          }\n        }\n      }\n    }\n    setStyle(styles, el) {\n      for (const style in styles) {\n        if (style) {\n          this.renderer.setStyle(el, style, styles[style]);\n        }\n      }\n    }\n    addClass(classes, el) {\n      const classArray = Array.isArray(classes) ? classes : classes.split(' ');\n      classArray.filter(element => element.length > 0).forEach(element => {\n        this.renderer.addClass(el, element);\n      });\n    }\n    setAttrib(key, value, el) {\n      this.renderer.setAttribute(el, key, value);\n    }\n  }\n  SidebarNavTitleComponent.ɵfac = function SidebarNavTitleComponent_Factory(t) {\n    return new (t || SidebarNavTitleComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  SidebarNavTitleComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavTitleComponent,\n    selectors: [[\"c-sidebar-nav-title\"]],\n    inputs: {\n      item: \"item\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function SidebarNavTitleComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SidebarNavTitleComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavItemClassPipe = /*#__PURE__*/(() => {\n  class SidebarNavItemClassPipe {\n    constructor(helper) {\n      this.helper = helper;\n    }\n    // transform(item: any, ...args: any[]): any {\n    transform(item, args) {\n      const itemType = this.helper.itemType(item);\n      let itemClass;\n      if (['divider', 'title'].includes(itemType)) {\n        itemClass = `nav-${itemType}`;\n      } else if (itemType === 'group') {\n        // itemClass = 'c-sidebar-nav-group' ;\n        itemClass = '';\n      } else {\n        itemClass = 'nav-item';\n      }\n      return item.class ? `${itemClass} ${item.class}` : itemClass;\n    }\n  }\n  SidebarNavItemClassPipe.ɵfac = function SidebarNavItemClassPipe_Factory(t) {\n    return new (t || SidebarNavItemClassPipe)(i0.ɵɵdirectiveInject(SidebarNavHelper, 16));\n  };\n  SidebarNavItemClassPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cSidebarNavItemClass\",\n    type: SidebarNavItemClassPipe,\n    pure: true\n  });\n  return SidebarNavItemClassPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavGroupService = /*#__PURE__*/(() => {\n  class SidebarNavGroupService {\n    constructor() {\n      this.sidebarNavGroupState = new BehaviorSubject({});\n      this.sidebarNavGroupState$ = this.sidebarNavGroupState.asObservable();\n    }\n    toggle(action) {\n      this.sidebarNavGroupState.next(action);\n    }\n  }\n  SidebarNavGroupService.ɵfac = function SidebarNavGroupService_Factory(t) {\n    return new (t || SidebarNavGroupService)();\n  };\n  SidebarNavGroupService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SidebarNavGroupService,\n    factory: SidebarNavGroupService.ɵfac\n  });\n  return SidebarNavGroupService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavComponent = /*#__PURE__*/(() => {\n  class SidebarNavComponent {\n    constructor(sidebar, helper, router, renderer, hostElement, sidebarService) {\n      this.sidebar = sidebar;\n      this.helper = helper;\n      this.router = router;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.sidebarService = sidebarService;\n      this.navItems = [];\n      this.dropdownMode = 'path';\n      this.role = 'nav';\n      this.navItemsArray = [];\n    }\n    get hostClasses() {\n      return {\n        'sidebar-nav': !this.groupItems,\n        compact: !this.groupItems && !!this.compact\n      };\n    }\n    get sidebarNavGroupItemsClass() {\n      return !!this.groupItems;\n    }\n    ngOnChanges(changes) {\n      this.navItemsArray = Array.isArray(this.navItems) ? this.navItems.slice() : [];\n    }\n    hideMobile() {\n      // todo: proper scrollIntoView() after NavigationEnd\n      if (this.sidebar && this.sidebar.sidebarState.mobile) {\n        this.sidebarService.toggle({\n          toggle: 'visible',\n          sidebar: this.sidebar\n        });\n      }\n    }\n  }\n  SidebarNavComponent.ɵfac = function SidebarNavComponent_Factory(t) {\n    return new (t || SidebarNavComponent)(i0.ɵɵdirectiveInject(SidebarComponent, 8), i0.ɵɵdirectiveInject(SidebarNavHelper), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SidebarService));\n  };\n  SidebarNavComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavComponent,\n    selectors: [[\"c-sidebar-nav\"]],\n    hostVars: 5,\n    hostBindings: function SidebarNavComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n        i0.ɵɵclassProp(\"nav-group-items\", ctx.sidebarNavGroupItemsClass);\n      }\n    },\n    inputs: {\n      navItems: \"navItems\",\n      dropdownMode: \"dropdownMode\",\n      groupItems: \"groupItems\",\n      compact: \"compact\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [3, \"ngSwitch\"], [\"routerLinkActive\", \"show\", 3, \"dropdownMode\", \"item\", \"ngClass\", \"routerLinkActiveOptions\", 4, \"ngSwitchCase\"], [3, \"cHtmlAttr\", \"item\", \"ngClass\", 4, \"ngSwitchCase\"], [3, \"item\", \"ngClass\", 4, \"ngSwitchCase\"], [4, \"ngSwitchCase\"], [3, \"item\", \"ngClass\", \"linkClick\", 4, \"ngSwitchDefault\"], [\"routerLinkActive\", \"show\", 3, \"dropdownMode\", \"item\", \"ngClass\", \"routerLinkActiveOptions\"], [\"rla\", \"routerLinkActive\"], [3, \"cHtmlAttr\", \"item\", \"ngClass\"], [3, \"item\", \"ngClass\"], [3, \"item\", \"ngClass\", \"linkClick\"]],\n    template: function SidebarNavComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, SidebarNavComponent_ng_container_0_Template, 8, 6, \"ng-container\", 0);\n        i0.ɵɵprojection(1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.navItemsArray);\n      }\n    },\n    dependencies: function () {\n      return [i1$1.NgClass, i1$1.NgForOf, i1$1.NgSwitch, i1$1.NgSwitchCase, i1$1.NgSwitchDefault, i3.RouterLinkActive, HtmlAttributesDirective, SidebarNavDividerComponent, SidebarNavGroupComponent, SidebarNavLabelComponent, SidebarNavLinkComponent, SidebarNavTitleComponent, SidebarNavItemClassPipe];\n    }\n  });\n  return SidebarNavComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarNavGroupComponent = /*#__PURE__*/(() => {\n  class SidebarNavGroupComponent {\n    constructor(router, renderer, hostElement, helper, sidebarNavGroupService) {\n      this.router = router;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.helper = helper;\n      this.sidebarNavGroupService = sidebarNavGroupService;\n      this.dropdownMode = 'path';\n      this.navItems = [];\n      this.display = {\n        display: 'block'\n      };\n      this.navigationEndObservable = router.events.pipe(filter(event => event instanceof NavigationEnd));\n    }\n    get hostClasses() {\n      return {\n        'nav-group': true,\n        show: this.open\n      };\n    }\n    ngOnInit() {\n      this.navItems = [...this.item.children];\n      this.navSubscription = this.navigationEndObservable.subscribe(event => {\n        if (this.dropdownMode !== 'none') {\n          const samePath = this.samePath(event.url);\n          this.openGroup(samePath);\n        }\n      });\n      if (this.samePath(this.router.routerState.snapshot.url)) {\n        this.openGroup(true);\n      }\n      this.navGroupSubscription = this.sidebarNavGroupService.sidebarNavGroupState$.subscribe(next => {\n        if (this.dropdownMode === 'close' && next.sidebarNavGroup && next.sidebarNavGroup !== this) {\n          if (next.sidebarNavGroup.item.url.startsWith(this.item.url)) {\n            return;\n          }\n          if (this.samePath(this.router.routerState.snapshot.url)) {\n            this.openGroup(true);\n            return;\n          }\n          this.openGroup(false);\n        }\n      });\n    }\n    samePath(url) {\n      // console.log('item:', this.item.name, this.item.url, 'url:', url);\n      const itemArray = this.item.url?.split('/');\n      const urlArray = url.split('/');\n      return itemArray?.every((value, index) => {\n        // console.log(value === urlArray[index], 'value:', value, 'index:', index, urlArray[index], url);\n        return value === urlArray[index];\n      });\n    }\n    openGroup(open) {\n      this.open = open;\n    }\n    toggleGroup($event) {\n      $event.preventDefault();\n      this.openGroup(!this.open);\n      if (this.open) {\n        this.sidebarNavGroupService.toggle({\n          open: this.open,\n          sidebarNavGroup: this\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.navSubscription.unsubscribe();\n    }\n    onAnimationStart($event) {\n      this.display = {\n        display: 'block'\n      };\n      if ($event.toState === 'open') {\n        const host = this.sidebarNav.nativeElement;\n        this.renderer.setStyle(host, 'height', `${host['scrollHeight']}px`);\n      }\n    }\n    onAnimationDone($event) {\n      if ($event.toState === 'open') {\n        const host = this.sidebarNav.nativeElement;\n        this.renderer.setStyle(host, 'height', 'auto');\n      }\n      if ($event.toState === 'closed') {\n        setTimeout(() => {\n          this.display = null;\n        });\n      }\n    }\n  }\n  SidebarNavGroupComponent.ɵfac = function SidebarNavGroupComponent_Factory(t) {\n    return new (t || SidebarNavGroupComponent)(i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SidebarNavHelper), i0.ɵɵdirectiveInject(SidebarNavGroupService));\n  };\n  SidebarNavGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SidebarNavGroupComponent,\n    selectors: [[\"c-sidebar-nav-group\"]],\n    viewQuery: function SidebarNavGroupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(SidebarNavComponent, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sidebarNav = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function SidebarNavGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      item: \"item\",\n      dropdownMode: \"dropdownMode\",\n      show: \"show\"\n    },\n    features: [i0.ɵɵProvidersFeature([SidebarNavHelper])],\n    decls: 8,\n    vars: 12,\n    consts: [[\"href\", \"\", 1, \"nav-link\", \"nav-group-toggle\", 3, \"cHtmlAttr\", \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"ngClass\", 4, \"ngIf\"], [3, \"dropdownMode\", \"groupItems\", \"navItems\", \"ngStyle\"], [\"iconTemplate\", \"\"], [3, \"ngClass\"], [3, \"ngIf\"], [3, \"cIcon\", \"customClasses\", \"name\"]],\n    template: function SidebarNavGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"a\", 0);\n        i0.ɵɵlistener(\"click\", function SidebarNavGroupComponent_Template_a_click_0_listener($event) {\n          return ctx.toggleGroup($event);\n        });\n        i0.ɵɵtemplate(1, SidebarNavGroupComponent_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n        i0.ɵɵelementContainerStart(2);\n        i0.ɵɵtext(3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(4, SidebarNavGroupComponent_span_4_Template, 3, 4, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"c-sidebar-nav\", 3);\n        i0.ɵɵlistener(\"@openClose.done\", function SidebarNavGroupComponent_Template_c_sidebar_nav_animation_openClose_done_5_listener($event) {\n          return ctx.onAnimationDone($event);\n        })(\"@openClose.start\", function SidebarNavGroupComponent_Template_c_sidebar_nav_animation_openClose_start_5_listener($event) {\n          return ctx.onAnimationStart($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, SidebarNavGroupComponent_ng_template_6_Template, 3, 3, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(7);\n        i0.ɵɵproperty(\"cHtmlAttr\", ctx.item.attributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", _r2)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(10, _c8, ctx.item));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.item.name);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.helper.hasBadge(ctx.item));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"@openClose\", ctx.open ? \"open\" : \"closed\")(\"dropdownMode\", ctx.dropdownMode)(\"groupItems\", true)(\"navItems\", ctx.navItems)(\"ngStyle\", ctx.display);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet, i1$1.NgStyle, HtmlAttributesDirective, i5.IconDirective, SidebarNavComponent, SidebarNavBadgePipe, SidebarNavIconPipe],\n    styles: [\".nav-group-toggle[_ngcontent-%COMP%]{cursor:pointer}.nav-group-items[_ngcontent-%COMP%]{display:block}\"],\n    data: {\n      animation: [trigger('openClose', [state('open', style({\n        height: '*'\n      })), state('closed', style({\n        height: '0px'\n      })), transition('open <=> closed', [animate('.15s ease')])])]\n    }\n  });\n  return SidebarNavGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SidebarModule = /*#__PURE__*/(() => {\n  class SidebarModule {}\n  SidebarModule.ɵfac = function SidebarModule_Factory(t) {\n    return new (t || SidebarModule)();\n  };\n  SidebarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SidebarModule\n  });\n  SidebarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [SidebarService, SidebarNavHelper, SidebarNavGroupService],\n    imports: [CommonModule, RouterModule, SharedModule, IconModule]\n  });\n  return SidebarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TableColorDirective = /*#__PURE__*/(() => {\n  class TableColorDirective {\n    get hostClasses() {\n      return {\n        [`table-${this.color}`]: !!this.color\n      };\n    }\n  }\n  TableColorDirective.ɵfac = function TableColorDirective_Factory(t) {\n    return new (t || TableColorDirective)();\n  };\n  TableColorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TableColorDirective,\n    selectors: [[\"\", \"cTableColor\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableColorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: [\"cTableColor\", \"color\"]\n    }\n  });\n  return TableColorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TableActiveDirective = /*#__PURE__*/(() => {\n  class TableActiveDirective {\n    constructor() {\n      this._active = false;\n    }\n    /**\n     * Highlight a table row or cell\n     * @type boolean\n     */\n    set active(value) {\n      this._active = coerceBooleanProperty(value);\n    }\n    get active() {\n      return this._active;\n    }\n    get hostClasses() {\n      return {\n        'table-active': this.active\n      };\n    }\n  }\n  TableActiveDirective.ɵfac = function TableActiveDirective_Factory(t) {\n    return new (t || TableActiveDirective)();\n  };\n  TableActiveDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TableActiveDirective,\n    selectors: [[\"\", \"cTableActive\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableActiveDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      active: [\"cTableActive\", \"active\"]\n    }\n  });\n  return TableActiveDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TableDirective = /*#__PURE__*/(() => {\n  class TableDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this._bordered = false;\n      this._borderless = false;\n      this._hover = false;\n      this._small = false;\n      this._striped = false;\n      this._stripedColumns = false;\n    }\n    /**\n     * Add borders on all sides of the table and cells.\n     * @type boolean\n     */\n    set bordered(value) {\n      this._bordered = coerceBooleanProperty(value);\n    }\n    get bordered() {\n      return this._bordered;\n    }\n    /**\n     * Remove borders on all sides of the table and cells.\n     * @type boolean\n     */\n    set borderless(value) {\n      this._borderless = coerceBooleanProperty(value);\n    }\n    get borderless() {\n      return this._borderless;\n    }\n    /**\n     * Enable a hover state on table rows within table body.\n     * @type boolean\n     */\n    set hover(value) {\n      this._hover = coerceBooleanProperty(value);\n    }\n    get hover() {\n      return this._hover;\n    }\n    /**\n     * Make table more compact by cutting all cell `padding` in half.\n     * @type boolean\n     */\n    set small(value) {\n      this._small = coerceBooleanProperty(value);\n    }\n    get small() {\n      return this._small;\n    }\n    /**\n     * Add zebra-striping to any table row within the table body.\n     * @type boolean\n     */\n    set striped(value) {\n      this._striped = coerceBooleanProperty(value);\n    }\n    get striped() {\n      return this._striped;\n    }\n    /**\n     * Add zebra-striping to any table column.\n     * @type boolean\n     * @since 4.2.4\n     */\n    set stripedColumns(value) {\n      this._stripedColumns = coerceBooleanProperty(value);\n    }\n    get stripedColumns() {\n      return this._stripedColumns;\n    }\n    get hostClasses() {\n      return {\n        table: true,\n        [`align-${this.align}`]: !!this.align,\n        [`caption-${this.caption}`]: !!this.caption,\n        [`border-${this.borderColor}`]: !!this.borderColor,\n        'table-bordered': this.bordered,\n        'table-borderless': this.borderless,\n        [`table-${this.color}`]: !!this.color,\n        'table-hover': this.hover,\n        'table-sm': this.small,\n        'table-striped': this.striped,\n        'table-striped-columns': this.stripedColumns\n      };\n    }\n    ngOnInit() {\n      this.setResponsiveWrapper();\n    }\n    // todo\n    setResponsiveWrapper() {\n      if (!!this.responsive) {\n        const nativeElement = this.hostElement.nativeElement;\n        const wrapper = this.renderer.createElement('div');\n        const className = this.responsive === true ? 'table-responsive' : `table-responsive-${this.responsive}`;\n        this.renderer.addClass(wrapper, className);\n        const parentNode = this.renderer.parentNode(nativeElement);\n        this.renderer.appendChild(parentNode, wrapper);\n        this.renderer.insertBefore(parentNode, wrapper, nativeElement);\n        this.renderer.appendChild(wrapper, nativeElement);\n      }\n    }\n  }\n  TableDirective.ɵfac = function TableDirective_Factory(t) {\n    return new (t || TableDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  TableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TableDirective,\n    selectors: [[\"\", \"cTable\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      align: \"align\",\n      borderColor: \"borderColor\",\n      bordered: \"bordered\",\n      borderless: \"borderless\",\n      caption: \"caption\",\n      color: \"color\",\n      hover: \"hover\",\n      responsive: \"responsive\",\n      small: \"small\",\n      striped: \"striped\",\n      stripedColumns: \"stripedColumns\"\n    }\n  });\n  return TableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TableModule = /*#__PURE__*/(() => {\n  class TableModule {}\n  TableModule.ɵfac = function TableModule_Factory(t) {\n    return new (t || TableModule)();\n  };\n  TableModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TableModule\n  });\n  TableModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return TableModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabService = /*#__PURE__*/(() => {\n  class TabService {\n    constructor() {\n      this.activeTabPaneIdx = new Subject();\n      this.activeTabPaneIdx$ = this.activeTabPaneIdx.asObservable();\n    }\n    setActiveTabIdx(tabContentState) {\n      this.activeTabPaneIdx.next(tabContentState);\n    }\n  }\n  TabService.ɵfac = function TabService_Factory(t) {\n    return new (t || TabService)();\n  };\n  TabService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TabService,\n    factory: TabService.ɵfac,\n    providedIn: 'root'\n  });\n  return TabService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabPaneComponent = /*#__PURE__*/(() => {\n  class TabPaneComponent {\n    constructor(changeDetectorRef, tabService) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.tabService = tabService;\n      this._active = false;\n    }\n    set active(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (this._active !== newValue) {\n        this._active = newValue;\n        this.changeDetectorRef.markForCheck();\n      }\n    }\n    get active() {\n      return this._active;\n    }\n    get hostClasses() {\n      return {\n        'tab-pane': true,\n        fade: true,\n        show: this.active,\n        active: this.active\n      };\n    }\n    ngOnInit() {\n      this.subscribeTabService();\n    }\n    ngOnDestroy() {\n      this.subscribeTabService(false);\n    }\n    subscribeTabService(subscribe = true) {\n      if (subscribe) {\n        this.tabServiceSubscription = this.tabService.activeTabPaneIdx$.subscribe(tabContentState => {\n          if (tabContentState.tabContent === this.tabContent) {\n            this.active = tabContentState.activeIdx === this.tabPaneIdx;\n          }\n        });\n      } else {\n        this.tabServiceSubscription.unsubscribe();\n      }\n    }\n  }\n  TabPaneComponent.ɵfac = function TabPaneComponent_Factory(t) {\n    return new (t || TabPaneComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TabService));\n  };\n  TabPaneComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabPaneComponent,\n    selectors: [[\"c-tab-pane\"]],\n    hostVars: 2,\n    hostBindings: function TabPaneComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    exportAs: [\"cTabPane\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function TabPaneComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return TabPaneComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabContentComponent = /*#__PURE__*/(() => {\n  class TabContentComponent {\n    constructor(changeDetectorRef, tabService) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.tabService = tabService;\n      this._activeTabPaneIdx = -1;\n      /**\n       * Event emited on the active tab pane index change.\n       */\n      this.activeTabPaneIdxChange = new EventEmitter();\n    }\n    /**\n     * Set active tabPane index\n     * @type number\n     */\n    set activeTabPaneIdx(value) {\n      const newValue = coerceNumberProperty(value);\n      if (this._activeTabPaneIdx != newValue) {\n        this._activeTabPaneIdx = newValue;\n        this.activeTabPaneIdxChange.emit(newValue);\n        this.changeDetectorRef.markForCheck();\n        this.changeDetectorRef.detectChanges();\n      }\n    }\n    get activeTabPaneIdx() {\n      return this._activeTabPaneIdx;\n    }\n    get hostClasses() {\n      return {\n        'tab-content': true\n      };\n    }\n    ngAfterContentInit() {\n      this.subscribeTabService();\n    }\n    ngAfterContentChecked() {\n      this.panes?.forEach((tabPane, index) => {\n        tabPane.tabContent = this;\n        tabPane.tabPaneIdx = index;\n      });\n      this.refreshTabPaneActive(this.activeTabPaneIdx);\n      this.tabService.setActiveTabIdx({\n        tabContent: this,\n        activeIdx: this.activeTabPaneIdx\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes['activeTabPaneIdx']?.currentValue) {\n        this.tabService.setActiveTabIdx({\n          tabContent: this,\n          activeIdx: changes['activeTabPaneIdx'].currentValue\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.subscribeTabService(false);\n    }\n    subscribeTabService(subscribe = true) {\n      if (subscribe) {\n        this.tabServiceSubscription = this.tabService.activeTabPaneIdx$.subscribe(tabContentState => {\n          if (this === tabContentState.tabContent) {\n            this.activeTabPaneIdx = tabContentState.activeIdx;\n          }\n        });\n      } else {\n        this.tabServiceSubscription.unsubscribe();\n      }\n    }\n    refreshTabPaneActive(idx) {\n      // hack for active state pane refresh todo?\n      this.panes?.forEach((tabPane, index) => {\n        tabPane.active = idx === index;\n      });\n    }\n  }\n  TabContentComponent.ɵfac = function TabContentComponent_Factory(t) {\n    return new (t || TabContentComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TabService));\n  };\n  TabContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabContentComponent,\n    selectors: [[\"c-tab-content\"]],\n    contentQueries: function TabContentComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TabPaneComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panes = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function TabContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      activeTabPaneIdx: \"activeTabPaneIdx\"\n    },\n    outputs: {\n      activeTabPaneIdxChange: \"activeTabPaneIdxChange\"\n    },\n    exportAs: [\"cTabContent\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function TabContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"],\n    changeDetection: 0\n  });\n  return TabContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabContentRefDirective = /*#__PURE__*/(() => {\n  class TabContentRefDirective {\n    constructor(changeDetectorRef, tabService) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.tabService = tabService;\n      this._active = false;\n      this._disabled = false;\n      /**\n       * c-tab-pane index respectively\n       * @type number\n       */\n      this.tabPaneIdx = -1;\n    }\n    /**\n     * Set active state of tab content\n     * @type boolean\n     */\n    set active(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (this._active !== newValue) {\n        this._active = newValue;\n        this.changeDetectorRef.detectChanges();\n      }\n    }\n    get active() {\n      return this._active;\n    }\n    /**\n     * Set disabled state of tab content\n     * @type boolean\n     */\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    get disabled() {\n      return this._disabled || this.tabPaneIdx >= this.tabContentRef?.panes?.length;\n    }\n    get hostClasses() {\n      return {\n        active: this.active,\n        disabled: this.disabled\n      };\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    get attrDisabled() {\n      return this.disabled ? '' : null;\n    }\n    get getTabindex() {\n      return this.disabled ? '-1' : null;\n    }\n    ngOnChanges(changes) {\n      if (changes['active']?.currentValue) {\n        this.setActiveTabPane();\n      }\n    }\n    toggleOpen($event) {\n      $event.preventDefault();\n      this.setActiveTabPane();\n    }\n    setActiveTabPane() {\n      setTimeout(() => {\n        if (this.tabPaneIdx < this.tabContentRef.panes.length) {\n          this.active = true;\n          this.tabService.setActiveTabIdx({\n            tabContent: this.tabContentRef,\n            activeIdx: this.tabPaneIdx\n          });\n        } else {\n          this.active = false;\n        }\n      });\n    }\n    ngOnInit() {\n      this.subscribeTabService();\n    }\n    ngOnDestroy() {\n      this.subscribeTabService(false);\n    }\n    subscribeTabService(subscribe = true) {\n      if (subscribe) {\n        this.tabServiceSubscription = this.tabService.activeTabPaneIdx$.subscribe(tabContentState => {\n          if (tabContentState.tabContent === this.tabContentRef) {\n            this.active = tabContentState.activeIdx === this.tabPaneIdx;\n          }\n        });\n      } else {\n        this.tabServiceSubscription.unsubscribe();\n      }\n    }\n  }\n  TabContentRefDirective.ɵfac = function TabContentRefDirective_Factory(t) {\n    return new (t || TabContentRefDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TabService));\n  };\n  TabContentRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TabContentRefDirective,\n    selectors: [[\"\", \"cTabContent\", \"\"]],\n    hostVars: 5,\n    hostBindings: function TabContentRefDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function TabContentRefDirective_click_HostBindingHandler($event) {\n          return ctx.toggleOpen($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"disabled\", ctx.attrDisabled)(\"tabindex\", ctx.getTabindex);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      tabContentRef: [\"cTabContent\", \"tabContentRef\"],\n      active: \"active\",\n      disabled: \"disabled\",\n      tabPaneIdx: \"tabPaneIdx\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TabContentRefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabsModule = /*#__PURE__*/(() => {\n  class TabsModule {}\n  TabsModule.ɵfac = function TabsModule_Factory(t) {\n    return new (t || TabsModule)();\n  };\n  TabsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TabsModule\n  });\n  TabsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [TabService],\n    imports: [CommonModule]\n  });\n  return TabsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToasterService = /*#__PURE__*/(() => {\n  class ToasterService {\n    constructor() {\n      this.toasterState = new BehaviorSubject({});\n      this.toasterState$ = this.toasterState.asObservable();\n    }\n    setState(state) {\n      this.toasterState.next({\n        ...state\n      });\n    }\n  }\n  ToasterService.ɵfac = function ToasterService_Factory(t) {\n    return new (t || ToasterService)();\n  };\n  ToasterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ToasterService,\n    factory: ToasterService.ɵfac,\n    providedIn: 'root'\n  });\n  return ToasterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastComponent = /*#__PURE__*/(() => {\n  class ToastComponent {\n    constructor(hostElement, renderer, toasterService, changeDetectorRef) {\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.toasterService = toasterService;\n      this.changeDetectorRef = changeDetectorRef;\n      /**\n       * Auto hide the toast.\n       * @type boolean\n       */\n      this.autohide = true;\n      /**\n       * Sets the color context of the component to one of CoreUI’s themed colors.\n       * @type Colors\n       */\n      this.color = '';\n      /**\n       * Delay hiding the toast (ms).\n       * @type number\n       */\n      this.delay = 5000;\n      /**\n       * Apply fade transition to the toast.\n       * @type boolean\n       */\n      this.fade = true;\n      this._visible = false;\n      /**\n       * Event emitted on visibility change. [docs]\n       * @type boolean\n       */\n      this.visibleChange = new EventEmitter();\n      /**\n       * Event emitted on timer tick. [docs]\n       * @type number\n       */\n      this.timer = new EventEmitter();\n    }\n    /**\n     * Toggle the visibility of component.\n     * @type boolean\n     */\n    set visible(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (this._visible !== newValue) {\n        this._visible = newValue;\n        newValue ? this.setTimer() : this.clearTimer();\n        this.visibleChange.emit(newValue);\n        this.changeDetectorRef.markForCheck();\n      }\n    }\n    get visible() {\n      return this._visible;\n    }\n    get clock() {\n      return this._clock;\n    }\n    set clock(value) {\n      this._clock = value;\n      this.timer.emit(this._clock);\n      this.changeDetectorRef.markForCheck();\n    }\n    get animationDisabled() {\n      return !this.fade;\n    }\n    get animateType() {\n      return this.visible ? 'show' : 'hide';\n    }\n    onAnimationStart($event) {\n      this.onAnimationEvent($event);\n    }\n    onAnimationDone($event) {\n      this.onAnimationEvent($event);\n    }\n    onMouseOver() {\n      this.clearTimer();\n    }\n    onMouseOut() {\n      this.setTimer();\n    }\n    get hostClasses() {\n      return {\n        toast: true,\n        fade: this.fade,\n        show: !this.hide,\n        [`bg-${this.color}`]: !!this.color,\n        'border-0': !!this.color\n      };\n    }\n    ngOnInit() {\n      if (this.visible) {\n        this.toasterService.setState({\n          toast: this,\n          show: this.visible,\n          placement: this.placement\n        });\n        this.clearTimer();\n        this.setTimer();\n      }\n    }\n    ngOnDestroy() {\n      this.clearTimer();\n    }\n    setTimer() {\n      this.clearTimer();\n      if (this.autohide && this.visible) {\n        this.timerId = this.delay > 0 ? setTimeout(() => this.onClose(), this.delay) : null;\n        this.setClock();\n      }\n    }\n    clearTimer() {\n      this.clearClock();\n      clearTimeout(this.timerId);\n      this.timerId = null;\n    }\n    onClose() {\n      this.clearTimer();\n      this.toasterService.setState({\n        toast: this,\n        show: false,\n        placement: this.placement\n      });\n    }\n    setClock() {\n      this.clearClock();\n      this.clock = 0;\n      this.clockId = setInterval(() => {\n        this.clock += 1;\n        this.changeDetectorRef.markForCheck();\n      }, 1000);\n      this.clockTimerId = setTimeout(() => {\n        this.clearClock();\n      }, this.delay);\n    }\n    clearClock() {\n      clearTimeout(this.clockTimerId);\n      clearInterval(this.clockId);\n      this.clockId = null;\n    }\n    onAnimationEvent(event) {\n      this.hide = event.phaseName === 'start' && event.toState === 'show';\n      if (event.phaseName === 'done') {\n        this.hide = event.toState === 'hide' || event.toState === 'void';\n        if (event.toState === 'show') {\n          this.hide = false;\n        }\n      }\n    }\n  }\n  ToastComponent.ɵfac = function ToastComponent_Factory(t) {\n    return new (t || ToastComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ToasterService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  ToastComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToastComponent,\n    selectors: [[\"c-toast\"]],\n    hostVars: 4,\n    hostBindings: function ToastComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@fadeInOut.start\", function ToastComponent_animation_fadeInOut_start_HostBindingHandler($event) {\n          return ctx.onAnimationStart($event);\n        })(\"@fadeInOut.done\", function ToastComponent_animation_fadeInOut_done_HostBindingHandler($event) {\n          return ctx.onAnimationDone($event);\n        });\n        i0.ɵɵlistener(\"mouseover\", function ToastComponent_mouseover_HostBindingHandler() {\n          return ctx.onMouseOver();\n        })(\"mouseout\", function ToastComponent_mouseout_HostBindingHandler() {\n          return ctx.onMouseOut();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.animationDisabled)(\"@fadeInOut\", ctx.animateType);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      autohide: \"autohide\",\n      color: \"color\",\n      delay: \"delay\",\n      fade: \"fade\",\n      visible: \"visible\",\n      index: \"index\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\",\n      timer: \"timer\"\n    },\n    exportAs: [\"cToast\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ToastComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block;overflow:hidden}\"],\n    data: {\n      animation: [trigger('fadeInOut', [state('show', style({\n        opacity: 1,\n        height: '*',\n        padding: '*',\n        border: '*',\n        margin: '*'\n      })), state('hide', style({\n        opacity: 0,\n        height: 0,\n        padding: 0,\n        border: 0,\n        margin: 0\n      })), state('void', style({\n        opacity: 0,\n        height: 0,\n        padding: 0,\n        border: 0,\n        margin: 0\n      })), transition('show => hide', [animate('{{ time }} {{ easing }}')], {\n        params: {\n          time: '300ms',\n          easing: 'ease-out'\n        }\n      }), transition('hide => show', [animate('{{ time }} {{ easing }}')], {\n        params: {\n          time: '300ms',\n          easing: 'ease-in'\n        }\n      }), transition('show => void', [animate('{{ time }} {{ easing }}')], {\n        params: {\n          time: '300ms',\n          easing: 'ease-out'\n        }\n      }), transition('void => show', [animate('{{ time }} {{ easing }}')], {\n        params: {\n          time: '300ms',\n          easing: 'ease-in'\n        }\n      })])]\n    }\n  });\n  return ToastComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastBodyComponent = /*#__PURE__*/(() => {\n  class ToastBodyComponent {\n    constructor(toast) {\n      this.toast = toast;\n      this.toastBodyClass = true;\n    }\n  }\n  ToastBodyComponent.ɵfac = function ToastBodyComponent_Factory(t) {\n    return new (t || ToastBodyComponent)(i0.ɵɵdirectiveInject(ToastComponent, 8));\n  };\n  ToastBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToastBodyComponent,\n    selectors: [[\"c-toast-body\"]],\n    hostVars: 2,\n    hostBindings: function ToastBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"toast-body\", ctx.toastBodyClass);\n      }\n    },\n    exportAs: [\"cToastBody\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ToastBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return ToastBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastCloseDirective = /*#__PURE__*/(() => {\n  class ToastCloseDirective {\n    constructor(toasterService) {\n      this.toasterService = toasterService;\n    }\n    toggleOpen($event) {\n      $event.preventDefault();\n      this.toasterService.setState({\n        show: false,\n        toast: this.toast\n      });\n    }\n  }\n  ToastCloseDirective.ɵfac = function ToastCloseDirective_Factory(t) {\n    return new (t || ToastCloseDirective)(i0.ɵɵdirectiveInject(ToasterService));\n  };\n  ToastCloseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ToastCloseDirective,\n    selectors: [[\"\", \"cToastClose\", \"\"]],\n    hostBindings: function ToastCloseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ToastCloseDirective_click_HostBindingHandler($event) {\n          return ctx.toggleOpen($event);\n        });\n      }\n    },\n    inputs: {\n      toast: [\"cToastClose\", \"toast\"]\n    },\n    exportAs: [\"cToastClose\"]\n  });\n  return ToastCloseDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastHeaderComponent = /*#__PURE__*/(() => {\n  class ToastHeaderComponent {\n    constructor(toast) {\n      this.toast = toast;\n      /**\n       * Add close button to a toast header\n       * @type boolean\n       */\n      this.closeButton = true;\n      this.toastHeaderClass = true;\n    }\n  }\n  ToastHeaderComponent.ɵfac = function ToastHeaderComponent_Factory(t) {\n    return new (t || ToastHeaderComponent)(i0.ɵɵdirectiveInject(ToastComponent, 8));\n  };\n  ToastHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToastHeaderComponent,\n    selectors: [[\"c-toast-header\"]],\n    hostVars: 2,\n    hostBindings: function ToastHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"toast-header\", ctx.toastHeaderClass);\n      }\n    },\n    inputs: {\n      closeButton: \"closeButton\"\n    },\n    exportAs: [\"cToastHeader\"],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 1,\n    consts: [[\"aria-label\", \"close\", \"cButtonClose\", \"\", \"class\", \"ms-auto\", 3, \"cToastClose\", \"style\", 4, \"ngIf\"], [\"aria-label\", \"close\", \"cButtonClose\", \"\", 1, \"ms-auto\", 3, \"cToastClose\"]],\n    template: function ToastHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵtemplate(2, ToastHeaderComponent_button_2_Template, 1, 4, \"button\", 0);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.closeButton);\n      }\n    },\n    dependencies: [i1$1.NgIf, ButtonCloseDirective, ToastCloseDirective]\n  });\n  return ToastHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToasterHostDirective = /*#__PURE__*/(() => {\n  class ToasterHostDirective {\n    constructor(viewContainerRef) {\n      this.viewContainerRef = viewContainerRef;\n    }\n  }\n  ToasterHostDirective.ɵfac = function ToasterHostDirective_Factory(t) {\n    return new (t || ToasterHostDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  ToasterHostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ToasterHostDirective,\n    selectors: [[\"\", \"cToasterHost\", \"\"]],\n    exportAs: [\"cToasterHost\"]\n  });\n  return ToasterHostDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar ToasterPlacement = /*#__PURE__*/(() => {\n  (function (ToasterPlacement) {\n    ToasterPlacement[\"Static\"] = \"static\";\n    ToasterPlacement[\"TopStart\"] = \"top-start\";\n    ToasterPlacement[\"TopCenter\"] = \"top-center\";\n    ToasterPlacement[\"TopEnd\"] = \"top-end\";\n    ToasterPlacement[\"MiddleStart\"] = \"middle-start\";\n    ToasterPlacement[\"MiddleCenter\"] = \"middle-center\";\n    ToasterPlacement[\"MiddleEnd\"] = \"middle-end\";\n    ToasterPlacement[\"BottomStart\"] = \"bottom-start\";\n    ToasterPlacement[\"BottomCenter\"] = \"bottom-center\";\n    ToasterPlacement[\"BottomEnd\"] = \"bottom-end\";\n  })(ToasterPlacement || (ToasterPlacement = {}));\n  return ToasterPlacement;\n})();\nlet ToasterComponent = /*#__PURE__*/(() => {\n  class ToasterComponent {\n    constructor(componentFactoryResolver, hostElement, renderer, toasterService) {\n      this.componentFactoryResolver = componentFactoryResolver;\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.toasterService = toasterService;\n      this.placements = Object.values(ToasterPlacement);\n      this.toastsDynamic = [];\n      /**\n       * Toaster placement\n       * @type TToasterPlacement\n       */\n      this.placement = ToasterPlacement.TopEnd;\n      /**\n       * Toaster position\n       * @type (string | 'absolute' | 'fixed' | 'static')\n       */\n      this.position = 'absolute';\n    }\n    get hostClasses() {\n      return {\n        toaster: true,\n        'toast-container': true,\n        [`position-${this.position}`]: !!this.position,\n        'top-0': this.placement.includes('top'),\n        'top-50': this.placement.includes('middle'),\n        'bottom-0': this.placement.includes('bottom'),\n        'start-0': this.placement.includes('start'),\n        'start-50': this.placement.includes('center'),\n        'end-0': this.placement.includes('end'),\n        'translate-middle-x': this.placement.includes('center') && !this.placement.includes('middle'),\n        'translate-middle-y': this.placement.includes('middle') && !this.placement.includes('center'),\n        'translate-middle': this.placement.includes('middle') && this.placement.includes('center')\n      };\n    }\n    ngOnInit() {\n      this.stateToasterSubscribe(true);\n    }\n    ngOnDestroy() {\n      this.stateToasterSubscribe(false);\n    }\n    ngAfterContentChecked() {\n      this.toasts = this.contentToasts;\n    }\n    addToast(toast, props, options) {\n      let componentRef;\n      if (parseInt(VERSION.major) < 13) {\n        const factory = this.componentFactoryResolver.resolveComponentFactory(toast);\n        componentRef = this.toasterHost.viewContainerRef.createComponent(factory, options?.index, options?.injector, options?.projectableNodes, options?.ngModuleRef);\n      } else {\n        // @ts-ignore\n        componentRef = this.toasterHost.viewContainerRef.createComponent(toast, options);\n      }\n      this.toastsDynamic.push(componentRef);\n      const index = this.toastsDynamic.indexOf(componentRef);\n      for (const [key, value] of Object.entries(props)) {\n        componentRef.instance[key] = value;\n      }\n      componentRef.instance['placement'] = this.placement;\n      componentRef.instance['dynamic'] = true;\n      componentRef.instance['index'] = index;\n      componentRef.instance['visible'] = true;\n      componentRef.instance['visibleChange'].emit(true);\n      componentRef.changeDetectorRef?.detectChanges();\n      return componentRef;\n    }\n    removeToast(state) {\n      this.toastsDynamic?.forEach(item => {\n        if (state.toast?.dynamic && item.instance === state.toast) {\n          item.instance.visible = false;\n          item.instance['visibleChange'].emit(false);\n          setTimeout(() => {\n            item.destroy();\n          }, 300);\n        }\n      });\n      this.toasts?.forEach(item => {\n        if (item.element.nativeElement === state.toast?.hostElement.nativeElement) {\n          if (!state.toast?.dynamic) {\n            // @ts-ignore\n            state.toast.visible = false;\n          }\n        }\n      });\n    }\n    stateToasterSubscribe(subscribe = true) {\n      if (subscribe) {\n        this.stateToasterSubscription = this.toasterService.toasterState$.subscribe(state => {\n          if (state.show === false) {\n            this.removeToast(state);\n          }\n          if (state.show === true && state.toast?.dynamic === undefined) {}\n        });\n      } else {\n        this.stateToasterSubscription.unsubscribe();\n      }\n    }\n  }\n  ToasterComponent.ɵfac = function ToasterComponent_Factory(t) {\n    return new (t || ToasterComponent)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ToasterService));\n  };\n  ToasterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToasterComponent,\n    selectors: [[\"c-toaster\"]],\n    contentQueries: function ToasterComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ToastComponent, 4, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentToasts = _t);\n      }\n    },\n    viewQuery: function ToasterComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ToasterHostDirective, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toasterHost = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ToasterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      placement: \"placement\",\n      position: \"position\"\n    },\n    exportAs: [\"cToaster\"],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[\"cToasterHost\", \"\"]],\n    template: function ToasterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, ToasterComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        i0.ɵɵprojection(1, 0, [\"cToasterHost\", \"\"]);\n      }\n    },\n    dependencies: [ToasterHostDirective],\n    encapsulation: 2\n  });\n  return ToasterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastModule = /*#__PURE__*/(() => {\n  class ToastModule {}\n  ToastModule.ɵfac = function ToastModule_Factory(t) {\n    return new (t || ToastModule)();\n  };\n  ToastModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ToastModule\n  });\n  ToastModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ToasterService],\n    imports: [CommonModule, ButtonModule]\n  });\n  return ToastModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TooltipComponent = /*#__PURE__*/(() => {\n  class TooltipComponent {\n    constructor(renderer) {\n      this.renderer = renderer;\n      /**\n       * Content of tooltip\n       * @type {string | TemplateRef}\n       */\n      this.content = '';\n      /**\n       * Toggle the visibility of popover component.\n       * @type boolean\n       */\n      this.visible = false;\n      this.role = 'tooltip';\n    }\n    get hostClasses() {\n      return {\n        tooltip: true,\n        fade: true,\n        show: this.visible,\n        'bs-tooltip-auto': true\n      };\n    }\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.updateView(this.content);\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes['content']) {\n        setTimeout(() => {\n          this.updateView(this.content);\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.clear();\n    }\n    clear() {\n      this.viewContainerRef?.clear();\n      if (!!this.textNode) {\n        this.renderer.removeChild(this.textNode.parentNode, this.textNode);\n      }\n    }\n    updateView(content) {\n      this.clear();\n      if (!content) {\n        return;\n      }\n      if (content instanceof TemplateRef) {\n        this.viewContainerRef.createEmbeddedView(content);\n      } else {\n        this.textNode = this.renderer.createText(content);\n        const element = this.viewContainerRef.element.nativeElement;\n        this.renderer.appendChild(element.parentNode, this.textNode);\n      }\n    }\n  }\n  TooltipComponent.ɵfac = function TooltipComponent_Factory(t) {\n    return new (t || TooltipComponent)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  TooltipComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TooltipComponent,\n    selectors: [[\"c-tooltip\"]],\n    viewQuery: function TooltipComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c12, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function TooltipComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      content: \"content\",\n      visible: \"visible\",\n      id: \"id\",\n      role: \"role\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 0,\n    consts: [[\"data-popper-arrow\", \"\", 1, \"tooltip-arrow\"], [1, \"tooltip-inner\"], [\"tooltipTemplate\", \"\"]],\n    template: function TooltipComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelement(1, \"div\", 0);\n        i0.ɵɵelementStart(2, \"div\", 1);\n        i0.ɵɵelementContainer(3, null, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  return TooltipComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TooltipDirective = /*#__PURE__*/(() => {\n  class TooltipDirective {\n    constructor(document, renderer, hostElement, viewContainerRef, listenersService, changeDetectorRef) {\n      this.document = document;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.viewContainerRef = viewContainerRef;\n      this.listenersService = listenersService;\n      this.changeDetectorRef = changeDetectorRef;\n      /**\n       * Content of tooltip\n       * @type {string | TemplateRef}\n       */\n      this.content = '';\n      /**\n       * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.\n       */\n      this.placement = 'top';\n      /**\n       * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.\n       * @type {'hover' | 'focus' | 'click'}\n       */\n      this.trigger = 'hover';\n      this._visible = false;\n      this._popperOptions = {\n        modifiers: [{\n          name: 'offset',\n          options: {\n            offset: [0, 0]\n          }\n        }]\n      };\n    }\n    /**\n     * Optional popper Options object, takes precedence over cPopoverPlacement prop\n     * @type Partial<Options>\n     */\n    set popperOptions(value) {\n      this._popperOptions = {\n        ...this._popperOptions,\n        placement: this.placement,\n        ...value\n      };\n    }\n    get popperOptions() {\n      return {\n        placement: this.placement,\n        ...this._popperOptions\n      };\n    }\n    /**\n     * Toggle the visibility of tooltip component.\n     */\n    set visible(value) {\n      this._visible = value;\n    }\n    get visible() {\n      return this._visible;\n    }\n    get ariaDescribedBy() {\n      return this.tooltipId ? this.tooltipId : null;\n    }\n    ngOnChanges(changes) {\n      if (changes['visible']) {\n        changes['visible'].currentValue ? this.addTooltipElement() : this.removeTooltipElement();\n      }\n    }\n    ngOnDestroy() {\n      this.clearListeners();\n      this.destroyTooltipElement();\n    }\n    ngOnInit() {\n      this.setListeners();\n    }\n    setListeners() {\n      const config = {\n        hostElement: this.hostElement,\n        trigger: this.trigger,\n        callbackToggle: () => {\n          this.visible = !this.visible;\n          this.visible ? this.addTooltipElement() : this.removeTooltipElement();\n        },\n        callbackOff: () => {\n          this.visible = false;\n          this.removeTooltipElement();\n        },\n        callbackOn: () => {\n          this.visible = true;\n          this.addTooltipElement();\n        }\n      };\n      this.listenersService.setListeners(config);\n    }\n    clearListeners() {\n      this.listenersService.clearListeners();\n    }\n    getUID(prefix) {\n      let uid = prefix ?? 'random-id';\n      do {\n        uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;\n      } while (this.document.getElementById(uid));\n      return uid;\n    }\n    createTooltipElement() {\n      if (!this.tooltipRef) {\n        this.tooltipRef = this.viewContainerRef.createComponent(TooltipComponent);\n        // this.viewContainerRef.detach();\n      }\n    }\n\n    destroyTooltipElement() {\n      this.tooltip?.remove();\n      this.tooltipRef?.destroy();\n      // @ts-ignore\n      this.tooltipRef = undefined;\n      this.popperInstance?.destroy();\n      this.viewContainerRef?.detach();\n      this.viewContainerRef?.clear();\n    }\n    addTooltipElement() {\n      if (!this.tooltipRef) {\n        this.createTooltipElement();\n      }\n      this.tooltipId = this.getUID('tooltip');\n      this.tooltipRef.instance.id = this.tooltipId;\n      this.tooltipRef.instance.content = this.content;\n      this.tooltip = this.tooltipRef.location.nativeElement;\n      this.renderer.addClass(this.tooltip, 'd-none');\n      this.renderer.addClass(this.tooltip, 'fade');\n      this.popperInstance?.destroy();\n      this.viewContainerRef.insert(this.tooltipRef.hostView);\n      this.renderer.appendChild(this.document.body, this.tooltip);\n      this.popperInstance = createPopper(this.hostElement.nativeElement, this.tooltip, {\n        ...this.popperOptions\n      });\n      if (!this.visible) {\n        this.removeTooltipElement();\n        return;\n      }\n      this.renderer.removeClass(this.tooltip, 'd-none');\n      this.changeDetectorRef.markForCheck();\n      setTimeout(() => {\n        this.tooltipRef.instance.visible = this.visible;\n        this.popperInstance.forceUpdate();\n        this.changeDetectorRef.markForCheck();\n      }, 100);\n    }\n    removeTooltipElement() {\n      this.tooltipId = '';\n      if (!this.tooltipRef) {\n        return;\n      }\n      this.tooltipRef.instance.visible = false;\n      this.tooltipRef.instance.id = undefined;\n      this.changeDetectorRef.markForCheck();\n      setTimeout(() => {\n        this.viewContainerRef?.detach();\n      }, 300);\n    }\n  }\n  TooltipDirective.ɵfac = function TooltipDirective_Factory(t) {\n    return new (t || TooltipDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(ListenersService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  TooltipDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TooltipDirective,\n    selectors: [[\"\", \"cTooltip\", \"\"]],\n    hostVars: 1,\n    hostBindings: function TooltipDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-describedby\", ctx.ariaDescribedBy);\n      }\n    },\n    inputs: {\n      content: [\"cTooltip\", \"content\"],\n      popperOptions: [\"cTooltipOptions\", \"popperOptions\"],\n      placement: [\"cTooltipPlacement\", \"placement\"],\n      trigger: [\"cTooltipTrigger\", \"trigger\"],\n      visible: [\"cTooltipVisible\", \"visible\"]\n    },\n    exportAs: [\"cTooltip\"],\n    features: [i0.ɵɵProvidersFeature([ListenersService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return TooltipDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TooltipModule = /*#__PURE__*/(() => {\n  class TooltipModule {}\n  TooltipModule.ɵfac = function TooltipModule_Factory(t) {\n    return new (t || TooltipModule)();\n  };\n  TooltipModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TooltipModule\n  });\n  TooltipModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return TooltipModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BgColorDirective = /*#__PURE__*/(() => {\n  class BgColorDirective {\n    constructor() {\n      /**\n       * Set the background of an element to any contextual class\n       */\n      this.color = '';\n    }\n    get hostClasses() {\n      return {\n        [`bg-${this.color}`]: !!this.color,\n        'bg-gradient': this.gradient\n      };\n    }\n  }\n  BgColorDirective.ɵfac = function BgColorDirective_Factory(t) {\n    return new (t || BgColorDirective)();\n  };\n  BgColorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BgColorDirective,\n    selectors: [[\"\", \"cBgColor\", \"\"]],\n    hostVars: 2,\n    hostBindings: function BgColorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: [\"cBgColor\", \"color\"],\n      gradient: \"gradient\"\n    }\n  });\n  return BgColorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BorderDirective = /*#__PURE__*/(() => {\n  class BorderDirective {\n    constructor() {\n      /**\n       * Add or remove an element’s borders\n       * @type Border\n       */\n      this.border = true;\n    }\n    get hostClasses() {\n      if (typeof this.border === 'boolean') {\n        return {\n          border: true\n        };\n      }\n      if (typeof this.border === 'number' || typeof this.border === 'string') {\n        return {\n          border: true,\n          [`border-${this.border}`]: true\n        };\n      }\n      if (typeof this.border === 'object') {\n        const borderObj = {\n          top: undefined,\n          end: undefined,\n          bottom: undefined,\n          start: undefined,\n          color: undefined,\n          ...this.border\n        };\n        // @ts-ignore\n        const keys = Object.keys(borderObj).filter(key => borderObj[key] !== undefined);\n        const classes = {};\n        keys.forEach(key => {\n          // @ts-ignore\n          const val = borderObj[key];\n          if (typeof val === 'boolean') {\n            // @ts-ignore\n            classes[`border-${key}`] = true;\n          } else if (typeof val === 'number' || typeof val === 'string') {\n            // @ts-ignore\n            classes[`border-${key}-${val}`] = true;\n          } else if (typeof val === 'object') {\n            if ('color' in val) {\n              // @ts-ignore\n              classes[`border-${key}-${val.color}`] = true;\n            }\n            if ('width' in val) {\n              // @ts-ignore\n              classes[`border-${key}-${val.width}`] = true;\n            }\n          }\n        });\n        return Object.entries(classes).length === 0 ? {\n          border: false\n        } : classes;\n      }\n    }\n  }\n  BorderDirective.ɵfac = function BorderDirective_Factory(t) {\n    return new (t || BorderDirective)();\n  };\n  BorderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BorderDirective,\n    selectors: [[\"\", \"cBorder\", \"\"]],\n    hostVars: 2,\n    hostBindings: function BorderDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      border: [\"cBorder\", \"border\"]\n    }\n  });\n  return BorderDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TextColorDirective = /*#__PURE__*/(() => {\n  class TextColorDirective {\n    constructor() {\n      /**\n       * Set text-color of element\n       * @type TextColors\n       */\n      this.color = '';\n    }\n    get hostClasses() {\n      const color = this.color;\n      return {\n        [`text-${color}`]: !!color\n      };\n    }\n  }\n  TextColorDirective.ɵfac = function TextColorDirective_Factory(t) {\n    return new (t || TextColorDirective)();\n  };\n  TextColorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextColorDirective,\n    selectors: [[\"\", \"cTextColor\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TextColorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: [\"cTextColor\", \"color\"]\n    }\n  });\n  return TextColorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoundedDirective = /*#__PURE__*/(() => {\n  class RoundedDirective {\n    constructor() {\n      /**\n       * Set border radius variant and radius size\n       * @type Rounded\n       */\n      this.rounded = true;\n    }\n    get hostClasses() {\n      if (typeof this.rounded === 'boolean') {\n        return {\n          rounded: true\n        };\n      }\n      if (typeof this.rounded === 'number' || typeof this.rounded === 'string') {\n        return {\n          [`rounded-${this.rounded}`]: true\n        };\n      }\n      if (typeof this.rounded === 'object') {\n        const roundedObj = {\n          top: undefined,\n          end: undefined,\n          bottom: undefined,\n          start: undefined,\n          circle: undefined,\n          pill: undefined,\n          size: undefined,\n          ...this.rounded\n        };\n        // @ts-ignore\n        const keys = Object.keys(roundedObj).filter(key => roundedObj[key] !== undefined);\n        const classes = {};\n        keys.forEach(key => {\n          // @ts-ignore\n          const val = roundedObj[key];\n          if (typeof val === 'boolean') {\n            // @ts-ignore\n            classes[`rounded-${key}`] = val;\n          } else {\n            // @ts-ignore\n            classes[`rounded-${val}`] = true;\n          }\n        });\n        // console.log('rounded keys', keys, classes);\n        return Object.entries(classes).length === 0 ? {\n          rounded: false\n        } : classes;\n      }\n    }\n  }\n  RoundedDirective.ɵfac = function RoundedDirective_Factory(t) {\n    return new (t || RoundedDirective)();\n  };\n  RoundedDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RoundedDirective,\n    selectors: [[\"\", \"cRounded\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RoundedDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      rounded: [\"cRounded\", \"rounded\"]\n    }\n  });\n  return RoundedDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlignDirective = /*#__PURE__*/(() => {\n  class AlignDirective {\n    get hostClasses() {\n      return {\n        [`align-${this.align}`]: !!this.align\n      };\n    }\n  }\n  AlignDirective.ɵfac = function AlignDirective_Factory(t) {\n    return new (t || AlignDirective)();\n  };\n  AlignDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AlignDirective,\n    selectors: [[\"\", \"cAlign\", \"\"]],\n    hostVars: 2,\n    hostBindings: function AlignDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      align: [\"cAlign\", \"align\"]\n    }\n  });\n  return AlignDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UtilitiesModule = /*#__PURE__*/(() => {\n  class UtilitiesModule {}\n  UtilitiesModule.ɵfac = function UtilitiesModule_Factory(t) {\n    return new (t || UtilitiesModule)();\n  };\n  UtilitiesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UtilitiesModule\n  });\n  UtilitiesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return UtilitiesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatAComponent = /*#__PURE__*/(() => {\n  class WidgetStatAComponent {\n    constructor() {\n      this.templates = {};\n    }\n    get hostClasses() {\n      return {\n        'card': true,\n        [`bg-${this.color}`]: !!this.color,\n        'text-high-emphasis-inverse': !!this.color\n      };\n    }\n    get bodyClasses() {\n      return {\n        'pb-0': true,\n        'd-flex': true,\n        'justify-content-between': true,\n        'align-items-start': true\n      };\n    }\n    ngAfterContentInit() {\n      this.contentTemplates.forEach(child => {\n        this.templates[child.id] = child.templateRef;\n      });\n    }\n  }\n  WidgetStatAComponent.ɵfac = function WidgetStatAComponent_Factory(t) {\n    return new (t || WidgetStatAComponent)();\n  };\n  WidgetStatAComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatAComponent,\n    selectors: [[\"c-widget-stat-a\"]],\n    contentQueries: function WidgetStatAComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateIdDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplates = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function WidgetStatAComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      title: \"title\",\n      value: \"value\"\n    },\n    exportAs: [\"cWidgetStatA\"],\n    ngContentSelectors: _c14,\n    decls: 15,\n    vars: 5,\n    consts: [[3, \"ngClass\"], [\"class\", \"fs-4 fw-semibold\", 4, \"ngIf\"], [4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [\"defaultWidgetTitleTemplate\", \"\"], [\"defaultWidgetValueTemplate\", \"\"], [\"defaultWidgetChartTemplate\", \"\"], [\"defaultWidgetActionTemplate\", \"\"], [1, \"fs-4\", \"fw-semibold\"]],\n    template: function WidgetStatAComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c13);\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelementStart(1, \"c-card-body\", 0)(2, \"div\");\n        i0.ɵɵtemplate(3, WidgetStatAComponent_div_3_Template, 2, 1, \"div\", 1);\n        i0.ɵɵtemplate(4, WidgetStatAComponent_div_4_Template, 2, 1, \"div\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, WidgetStatAComponent_ng_container_5_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, WidgetStatAComponent_ng_container_6_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(7, WidgetStatAComponent_ng_template_7_Template, 1, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, WidgetStatAComponent_ng_template_9_Template, 1, 1, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, WidgetStatAComponent_ng_template_11_Template, 1, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, WidgetStatAComponent_ng_template_13_Template, 1, 0, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r8 = i0.ɵɵreference(12);\n        const _r10 = i0.ɵɵreference(14);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.bodyClasses);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.value || (ctx.templates == null ? null : ctx.templates.widgetValueTemplate));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.title || (ctx.templates == null ? null : ctx.templates.widgetTitleTemplate));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx.templates == null ? null : ctx.templates.widgetActionTemplate) || _r10);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx.templates == null ? null : ctx.templates.widgetChartTemplate) || _r8);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet, CardBodyComponent]\n  });\n  return WidgetStatAComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatBComponent = /*#__PURE__*/(() => {\n  class WidgetStatBComponent extends CardComponent {\n    constructor() {\n      super();\n      this._inverse = false;\n    }\n    /**\n     * Invert colors from their default dark shade.\n     * @type boolean\n     */\n    get inverse() {\n      return this._inverse;\n    }\n    set inverse(value) {\n      this._inverse = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        'card': true,\n        [`bg-${this.color}`]: !!this.color,\n        [`text-${this.textColor}`]: !!this.textColor,\n        'text-high-emphasis-inverse': !!this.color\n      };\n    }\n  }\n  WidgetStatBComponent.ɵfac = function WidgetStatBComponent_Factory(t) {\n    return new (t || WidgetStatBComponent)();\n  };\n  WidgetStatBComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatBComponent,\n    selectors: [[\"c-widget-stat-b\"]],\n    hostVars: 2,\n    hostBindings: function WidgetStatBComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      textColor: \"textColor\",\n      title: \"title\",\n      text: \"text\",\n      value: \"value\",\n      inverse: \"inverse\"\n    },\n    exportAs: [\"cWidgetStatB\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: [[\"class\", \"fs-4 fw-semibold\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [1, \"fs-4\", \"fw-semibold\"], [3, \"ngClass\"]],\n    template: function WidgetStatBComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"c-card-body\");\n        i0.ɵɵtemplate(1, WidgetStatBComponent_div_1_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(2, WidgetStatBComponent_div_2_Template, 2, 1, \"div\", 1);\n        i0.ɵɵprojection(3);\n        i0.ɵɵtemplate(4, WidgetStatBComponent_small_4_Template, 2, 2, \"small\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.text);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, CardBodyComponent]\n  });\n  return WidgetStatBComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatCComponent = /*#__PURE__*/(() => {\n  class WidgetStatCComponent extends CardComponent {\n    constructor() {\n      super();\n      this._inverse = false;\n      this.templates = {};\n    }\n    /**\n     * Invert colors from their default dark shade.\n     * @type boolean\n     */\n    get inverse() {\n      return this._inverse;\n    }\n    set inverse(value) {\n      this._inverse = coerceBooleanProperty(value);\n    }\n    get hostExtendedClass() {\n      return {\n        'high-emphasis-inverse': this.inverse\n      };\n    }\n    get iconClasses() {\n      return {\n        'mb-4': !this.textColor,\n        'text-end': true,\n        'text-medium-emphasis': !this.inverse,\n        'text-medium-emphasis-inverse': this.inverse,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n    get titleClasses() {\n      return {\n        'text-medium-emphasis': !this.inverse,\n        'text-medium-emphasis-inverse': this.inverse,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n    get valueClasses() {\n      return {\n        'fs-4': !this.textColor,\n        'fw-semibold': true,\n        'text-high-emphasis': !this.inverse,\n        'text-high-emphasis-inverse': this.inverse,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n    ngAfterContentInit() {\n      this.contentTemplates.forEach(child => {\n        this.templates[child.id] = child.templateRef;\n      });\n    }\n  }\n  WidgetStatCComponent.ɵfac = function WidgetStatCComponent_Factory(t) {\n    return new (t || WidgetStatCComponent)();\n  };\n  WidgetStatCComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatCComponent,\n    selectors: [[\"c-widget-stat-c\"]],\n    contentQueries: function WidgetStatCComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateIdDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplates = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function WidgetStatCComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostExtendedClass);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      title: \"title\",\n      value: \"value\",\n      inverse: \"inverse\"\n    },\n    exportAs: [\"cWidgetStatC\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 9,\n    vars: 4,\n    consts: [[3, \"ngClass\", 4, \"ngIf\"], [4, \"ngIf\"], [\"defaultWidgetIconTemplate\", \"\"], [\"defaultWidgetProgressTemplate\", \"\"], [3, \"ngClass\"], [4, \"ngTemplateOutlet\"]],\n    template: function WidgetStatCComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"c-card-body\");\n        i0.ɵɵtemplate(1, WidgetStatCComponent_div_1_Template, 2, 2, \"div\", 0);\n        i0.ɵɵtemplate(2, WidgetStatCComponent_div_2_Template, 2, 2, \"div\", 0);\n        i0.ɵɵtemplate(3, WidgetStatCComponent_div_3_Template, 2, 2, \"div\", 0);\n        i0.ɵɵtemplate(4, WidgetStatCComponent_ng_container_4_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, WidgetStatCComponent_ng_template_5_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, WidgetStatCComponent_ng_template_7_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || (ctx.templates == null ? null : ctx.templates.widgetIconTemplate));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.templates == null ? null : ctx.templates.widgetProgressTemplate);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet, CardBodyComponent]\n  });\n  return WidgetStatCComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatDComponent = /*#__PURE__*/(() => {\n  class WidgetStatDComponent {\n    constructor() {}\n    get hostClasses() {\n      return {\n        'card': true\n      };\n    }\n    get headerClasses() {\n      return {\n        'position-relative': true,\n        'd-flex': true,\n        'justify-content-center': true,\n        'align-items-center': true,\n        [`bg-${this.color}`]: this.color\n      };\n    }\n  }\n  WidgetStatDComponent.ɵfac = function WidgetStatDComponent_Factory(t) {\n    return new (t || WidgetStatDComponent)();\n  };\n  WidgetStatDComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatDComponent,\n    selectors: [[\"c-widget-stat-d\"]],\n    hostVars: 2,\n    hostBindings: function WidgetStatDComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      values: \"values\"\n    },\n    exportAs: [\"cWidgetStatD\"],\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 2,\n    consts: [[3, \"ngClass\"], [\"cRow\", \"\", 1, \"text-center\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"vr\", 4, \"ngIf\"], [1, \"fs-5\", \"fw-semibold\"], [1, \"text-uppercase\", \"text-medium-emphasis\", \"small\"], [1, \"vr\"]],\n    template: function WidgetStatDComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"c-card-header\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"c-card-body\", 1);\n        i0.ɵɵtemplate(3, WidgetStatDComponent_ng_template_3_Template, 6, 3, \"ng-template\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.headerClasses);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.values);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgForOf, i1$1.NgIf, CardBodyComponent, CardHeaderComponent, ColComponent, RowDirective]\n  });\n  return WidgetStatDComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatEComponent = /*#__PURE__*/(() => {\n  class WidgetStatEComponent extends CardComponent {\n    constructor() {\n      super();\n    }\n    get titleClasses() {\n      return {\n        'text-medium-emphasis': !this.textColor,\n        'small': true,\n        'text-uppercase': true,\n        'fw-semibold': true,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n  }\n  WidgetStatEComponent.ɵfac = function WidgetStatEComponent_Factory(t) {\n    return new (t || WidgetStatEComponent)();\n  };\n  WidgetStatEComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatEComponent,\n    selectors: [[\"c-widget-stat-e\"]],\n    inputs: {\n      title: \"title\",\n      value: \"value\"\n    },\n    exportAs: [\"cWidgetStatE\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 2,\n    consts: [[1, \"text-center\"], [3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"fs-6 fw-semibold py-3\", 4, \"ngIf\"], [3, \"ngClass\"], [1, \"fs-6\", \"fw-semibold\", \"py-3\"]],\n    template: function WidgetStatEComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"c-card-body\", 0);\n        i0.ɵɵtemplate(1, WidgetStatEComponent_div_1_Template, 2, 2, \"div\", 1);\n        i0.ɵɵtemplate(2, WidgetStatEComponent_div_2_Template, 2, 1, \"div\", 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !!ctx.value);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, CardBodyComponent]\n  });\n  return WidgetStatEComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetStatFComponent = /*#__PURE__*/(() => {\n  class WidgetStatFComponent {\n    constructor() {\n      this._padding = false;\n      this.templates = {};\n    }\n    /**\n     * Set padding of your component.\n     * @type boolean\n     */\n    get padding() {\n      return this._padding;\n    }\n    set padding(value) {\n      this._padding = coerceBooleanProperty(value);\n    }\n    get hostClasses() {\n      return {\n        card: true\n      };\n    }\n    get cardBodyClasses() {\n      return {\n        'd-flex': true,\n        'align-items-center': true,\n        'p-0': !this.padding\n      };\n    }\n    get iconClasses() {\n      return {\n        'me-3': !this.textColor,\n        'text-white': true,\n        [`bg-${this.color}`]: !!this.color,\n        'p-3': this.padding,\n        'p-4': !this.padding\n      };\n    }\n    get titleClasses() {\n      return {\n        'text-medium-emphasis': !this.textColor,\n        'small': true,\n        'text-uppercase': true,\n        'fw-semibold': true,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n    get valueClasses() {\n      return {\n        'fs-6': !this.textColor,\n        'fw-semibold': true,\n        [`text-${this.textColor}`]: !!this.textColor\n      };\n    }\n    ngAfterContentInit() {\n      this.contentTemplates.forEach(child => {\n        this.templates[child.id] = child.templateRef;\n      });\n    }\n  }\n  WidgetStatFComponent.ɵfac = function WidgetStatFComponent_Factory(t) {\n    return new (t || WidgetStatFComponent)();\n  };\n  WidgetStatFComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WidgetStatFComponent,\n    selectors: [[\"c-widget-stat-f\"]],\n    contentQueries: function WidgetStatFComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateIdDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplates = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function WidgetStatFComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.hostClasses);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      textColor: \"textColor\",\n      footer: \"footer\",\n      icon: \"icon\",\n      padding: \"padding\",\n      title: \"title\",\n      value: \"value\"\n    },\n    exportAs: [\"cWidgetStatB\"],\n    decls: 14,\n    vars: 8,\n    consts: [[3, \"ngClass\"], [4, \"ngTemplateOutlet\"], [4, \"ngIf\"], [\"defaultWidgetIconTemplate\", \"\"], [\"defaultFooterIconTemplate\", \"\"]],\n    template: function WidgetStatFComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelementStart(1, \"c-card-body\", 0)(2, \"div\", 0);\n        i0.ɵɵtemplate(3, WidgetStatFComponent_ng_container_3_Template, 1, 0, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\")(5, \"div\", 0);\n        i0.ɵɵtext(6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"div\", 0);\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(9, WidgetStatFComponent_c_card_footer_9_Template, 2, 1, \"c-card-footer\", 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(10, WidgetStatFComponent_ng_template_10_Template, 2, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, WidgetStatFComponent_ng_template_12_Template, 2, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(11);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.cardBodyClasses);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.iconClasses);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx.templates == null ? null : ctx.templates.widgetIconTemplate) || _r2);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", ctx.valueClasses);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.titleClasses);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.footer || (ctx.templates == null ? null : ctx.templates.widgetFooterTemplate));\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgIf, i1$1.NgTemplateOutlet, CardBodyComponent, CardFooterComponent]\n  });\n  return WidgetStatFComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WidgetModule = /*#__PURE__*/(() => {\n  class WidgetModule {}\n  WidgetModule.ɵfac = function WidgetModule_Factory(t) {\n    return new (t || WidgetModule)();\n  };\n  WidgetModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: WidgetModule\n  });\n  WidgetModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, CardModule, GridModule]\n  });\n  return WidgetModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of coreui-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AccordionButtonDirective, AccordionComponent, AccordionItemComponent, AccordionModule, AlertComponent, AlertHeadingDirective, AlertLinkDirective, AlertModule, AlignDirective, AvatarComponent, AvatarModule, BadgeComponent, BadgeModule, BgColorDirective, BorderDirective, BreadcrumbComponent, BreadcrumbItemComponent, BreadcrumbModule, BreadcrumbRouterComponent, BreadcrumbRouterService, BreakpointInfix, ButtonCloseDirective, ButtonDirective, ButtonGroupComponent, ButtonGroupModule, ButtonModule, ButtonToolbarComponent, CalloutComponent, CalloutModule, CardBodyComponent, CardComponent, CardFooterComponent, CardGroupComponent, CardHeaderActionsComponent, CardHeaderComponent, CardImgDirective, CardImgOverlayComponent, CardLinkDirective, CardModule, CardSubtitleDirective, CardTextDirective, CardTitleDirective, CarouselCaptionComponent, CarouselComponent, CarouselConfig, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent, CarouselModule, ClassToggleService, ColComponent, ColDirective, CollapseDirective, CollapseModule, ContainerComponent, DropdownCloseDirective, DropdownComponent, DropdownDividerDirective, DropdownHeaderDirective, DropdownItemDirective, DropdownItemPlainDirective, DropdownMenuDirective, DropdownModule, DropdownService, DropdownToggleDirective, FooterComponent, FooterModule, FormCheckComponent, FormCheckInputDirective, FormCheckLabelDirective, FormControlDirective, FormDirective, FormFeedbackComponent, FormFloatingDirective, FormLabelDirective, FormModule, FormSelectDirective, FormTextDirective, GridModule, GutterDirective, HeaderBrandComponent, HeaderComponent, HeaderDividerComponent, HeaderModule, HeaderNavComponent, HeaderTextComponent, HeaderTogglerDirective, HtmlAttributesDirective, ImgDirective, ImgModule, InputGroupComponent, InputGroupTextDirective, IntersectionService, ListGroupDirective, ListGroupItemDirective, ListGroupModule, ModalBodyComponent, ModalComponent, ModalContentComponent, ModalDialogComponent, ModalFooterComponent, ModalHeaderComponent, ModalModule, ModalService, ModalTitleDirective, ModalToggleDirective, NavComponent, NavItemComponent, NavLinkDirective, NavModule, NavbarBrandDirective, NavbarComponent, NavbarModule, NavbarNavComponent, NavbarTextComponent, NavbarTogglerDirective, OffcanvasBodyComponent, OffcanvasComponent, OffcanvasHeaderComponent, OffcanvasModule, OffcanvasService, OffcanvasTitleDirective, OffcanvasToggleDirective, PageItemComponent, PageItemDirective, PageLinkDirective, PaginationComponent, PaginationModule, PlaceholderAnimationDirective, PlaceholderDirective, PlaceholderModule, PopoverComponent, PopoverDirective, PopoverModule, ProgressBarComponent, ProgressComponent, ProgressModule, RoundedDirective, RowComponent, RowDirective, SharedModule, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarHeaderComponent, SidebarModule, SidebarNavComponent, SidebarService, SidebarToggleDirective, SidebarTogglerComponent, SpinnerComponent, SpinnerModule, TabContentComponent, TabContentRefDirective, TabPaneComponent, TabService, TableActiveDirective, TableColorDirective, TableDirective, TableModule, TabsModule, TemplateIdDirective, TextColorDirective, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPlacement, ToasterService, TooltipComponent, TooltipDirective, TooltipModule, UtilitiesModule, WidgetModule, WidgetStatAComponent, WidgetStatBComponent, WidgetStatCComponent, WidgetStatDComponent, WidgetStatEComponent, WidgetStatFComponent };\n//# sourceMappingURL=coreui-angular.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}