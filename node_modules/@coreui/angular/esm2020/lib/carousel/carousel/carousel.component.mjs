import { Component, EventEmitter, HostBinding, Inject, Input, Output } from '@angular/core';
import { fromEvent, withLatestFrom, zipWith } from 'rxjs';
import { IntersectionService } from '../../services/intersection.service';
import { ListenersService } from '../../services/listeners.service';
import { CarouselState } from '../carousel-state';
import { CarouselService } from '../carousel.service';
import { CarouselConfig } from '../carousel.config';
import * as i0 from "@angular/core";
import * as i1 from "../carousel.service";
import * as i2 from "../carousel-state";
import * as i3 from "../../services/intersection.service";
import * as i4 from "../../services/listeners.service";
import * as i5 from "../carousel.config";
export class CarouselComponent {
    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {
        this.config = config;
        this.hostElement = hostElement;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.intersectionService = intersectionService;
        this.listenersService = listenersService;
        /**
         * Index of the active item.
         * @type number
         */
        this.activeIndex = 0;
        /**
         * Carousel automatically starts cycle items.
         * @type boolean
         */
        this.animate = true;
        /**
         * Carousel direction. [docs]
         * @type {'next' | 'prev'}
         */
        this.direction = 'next';
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @type number
         * @default 0
         */
        this.interval = 0;
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @type {'hover' | 'focus' | 'click'}
         */
        this.pause = 'hover';
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @type boolean
         * @default true
         */
        this.touch = true;
        /**
         * Set type of the transition.
         * @type {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = 'slide';
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @type boolean
         * @default true
         */
        this.wrap = true;
        /**
         * Event emitted on carousel item change. [docs]
         * @type number
         */
        this.itemChange = new EventEmitter();
        this.activeItemInterval = 0;
        this._visible = true;
        Object.assign(this, config);
    }
    get hostClasses() {
        return {
            carousel: true,
            slide: true,
            'carousel-dark': !!this.dark,
            'carousel-fade': this.transition === 'crossfade'
        };
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.clearListeners();
        this.carouselStateSubscribe(false);
        this.intersectionServiceSubscribe(false);
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionService.createIntersectionObserver(this.hostElement);
        this.intersectionServiceSubscribe();
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.hostElement,
            trigger: this.pause || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.listenersService.setListeners(config);
    }
    clearListeners() {
        this.listenersService.clearListeners();
    }
    set visible(value) {
        this._visible = value;
    }
    get visible() {
        return this._visible;
    }
    setTimer() {
        const interval = this.activeItemInterval || 0;
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextItem) => {
                if ('active' in nextItem) {
                    this.itemChange.emit(nextItem.active);
                }
                this.activeItemInterval = typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;
                const isLastItem = ((nextItem.active === nextItem.lastItemIndex) && this.direction === 'next') || ((nextItem.active === 0) && this.direction === 'prev');
                !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();
            });
        }
        else {
            this.carouselIndexSubscription?.unsubscribe();
        }
    }
    intersectionServiceSubscribe(subscribe = true) {
        if (subscribe) {
            this.intersectingSubscription = this.intersectionService.intersecting$.subscribe(isIntersecting => {
                this.visible = isIntersecting;
                isIntersecting ? this.setTimer() : this.resetTimer();
            });
        }
        else {
            this.intersectingSubscription?.unsubscribe();
        }
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch && subscribe) {
            const carouselElement = this.hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$.pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
}
CarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.ElementRef }, { token: i1.CarouselService }, { token: i2.CarouselState }, { token: i3.IntersectionService }, { token: i4.ListenersService }], target: i0.ɵɵFactoryTarget.Component });
CarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: CarouselComponent, selector: "c-carousel", inputs: { activeIndex: "activeIndex", animate: "animate", dark: "dark", direction: "direction", interval: "interval", pause: "pause", touch: "touch", transition: "transition", wrap: "wrap" }, outputs: { itemChange: "itemChange" }, host: { properties: { "class": "this.hostClasses" } }, providers: [CarouselService, CarouselState, CarouselConfig, IntersectionService, ListenersService], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [":host{display:block}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content></ng-content>', providers: [CarouselService, CarouselState, CarouselConfig, IntersectionService, ListenersService], styles: [":host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i5.CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }, { type: i0.ElementRef }, { type: i1.CarouselService }, { type: i2.CarouselState }, { type: i3.IntersectionService }, { type: i4.ListenersService }]; }, propDecorators: { activeIndex: [{
                type: Input
            }], animate: [{
                type: Input
            }], dark: [{
                type: Input
            }], direction: [{
                type: Input
            }], interval: [{
                type: Input
            }], pause: [{
                type: Input
            }], touch: [{
                type: Input
            }], transition: [{
                type: Input
            }], wrap: [{
                type: Input
            }], itemChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJvdXNlbC9jYXJvdXNlbC9jYXJvdXNlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFFVCxZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBR0wsTUFBTSxFQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQWdCLGNBQWMsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFeEUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDMUUsT0FBTyxFQUFvQixnQkFBZ0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRXRGLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDOzs7Ozs7O0FBU3BELE1BQU0sT0FBTyxpQkFBaUI7SUF3RTVCLFlBQ2tDLE1BQXNCLEVBQzlDLFdBQXVCLEVBQ3ZCLGVBQWdDLEVBQ2hDLGFBQTRCLEVBQzVCLG1CQUF3QyxFQUN4QyxnQkFBa0M7UUFMVixXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUM5QyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUN2QixvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFDaEMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBN0U1Qzs7O1dBR0c7UUFDTSxnQkFBVyxHQUFHLENBQUMsQ0FBQztRQUN6Qjs7O1dBR0c7UUFDTSxZ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O2dCQUtHLE9BQU87c0JBQWYsS0FBSztnQkFLRyxJQUFJO3NCQUFaLEtBQUs7Z0JBS0csU0FBUztzQkFBakIsS0FBSztnQkFNRyxRQUFRO3NCQUFoQixLQUFLO2dCQUtHLEtBQUs7c0JBQWIsS0FBSztnQkFNRyxLQUFLO3NCQUFiLEtBQUs7Z0JBTUcsVUFBVTtzQkFBbEIsS0FBSztnQkFNRyxJQUFJO3NCQUFaLEtBQUs7Z0JBS0ksVUFBVTtzQkFBbkIsTUFBTTtnQkFHSCxXQUFXO3NCQURkLFdBQVc7dUJBQUMsT0FBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgU3Vic2NyaXB0aW9uLCB3aXRoTGF0ZXN0RnJvbSwgemlwV2l0aCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJbnRlcnNlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvaW50ZXJzZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSUxpc3RlbmVyc0NvbmZpZywgTGlzdGVuZXJzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2xpc3RlbmVycy5zZXJ2aWNlJztcblxuaW1wb3J0IHsgQ2Fyb3VzZWxTdGF0ZSB9IGZyb20gJy4uL2Nhcm91c2VsLXN0YXRlJztcbmltcG9ydCB7IENhcm91c2VsU2VydmljZSB9IGZyb20gJy4uL2Nhcm91c2VsLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuLi9jYXJvdXNlbC5jb25maWcnO1xuaW1wb3J0IHsgVHJpZ2dlcnMgfSBmcm9tICcuLi8uLi9jb3JldWkudHlwZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLWNhcm91c2VsJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgc3R5bGVVcmxzOiBbJy4vY2Fyb3VzZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbQ2Fyb3VzZWxTZXJ2aWNlLCBDYXJvdXNlbFN0YXRlLCBDYXJvdXNlbENvbmZpZywgSW50ZXJzZWN0aW9uU2VydmljZSwgTGlzdGVuZXJzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgYWN0aXZlIGl0ZW0uXG4gICAqIEB0eXBlIG51bWJlclxuICAgKi9cbiAgQElucHV0KCkgYWN0aXZlSW5kZXggPSAwO1xuICAvKipcbiAgICogQ2Fyb3VzZWwgYXV0b21hdGljYWxseSBzdGFydHMgY3ljbGUgaXRlbXMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIEBJbnB1dCgpIGFuaW1hdGUgPSB0cnVlO1xuICAvKipcbiAgICogQWRkIGRhcmtlciBjb250cm9scywgaW5kaWNhdG9ycywgYW5kIGNhcHRpb25zLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICBASW5wdXQoKSBkYXJrPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIENhcm91c2VsIGRpcmVjdGlvbi4gW2RvY3NdXG4gICAqIEB0eXBlIHsnbmV4dCcgfCAncHJldid9XG4gICAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb246ICduZXh0JyB8ICdwcmV2JyA9ICduZXh0JztcbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBiZXR3ZWVuIGF1dG9tYXRpY2FsbHkgY3ljbGluZyBhbiBpdGVtLiBJZiBmYWxzZSwgY2Fyb3VzZWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBjeWNsZS5cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIEBJbnB1dCgpIGludGVydmFsID0gMDtcbiAgLyoqXG4gICAqIFNldHMgd2hpY2ggZXZlbnQgaGFuZGxlcnMgeW914oCZZCBsaWtlIHByb3ZpZGVkIHRvIHlvdXIgcGF1c2UgcHJvcC4gWW91IGNhbiBzcGVjaWZ5IG9uZSB0cmlnZ2VyIG9yIGFuIGFycmF5IG9mIHRoZW0uXG4gICAqIEB0eXBlIHsnaG92ZXInIHwgJ2ZvY3VzJyB8ICdjbGljayd9XG4gICAqL1xuICBASW5wdXQoKSBwYXVzZTogVHJpZ2dlcnMgfCBUcmlnZ2Vyc1tdIHwgZmFsc2UgPSAnaG92ZXInO1xuICAvKipcbiAgICogU3VwcG9ydCBsZWZ0L3JpZ2h0IHN3aXBlIGludGVyYWN0aW9ucyBvbiB0b3VjaHNjcmVlbiBkZXZpY2VzLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIEBJbnB1dCgpIHRvdWNoOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIFNldCB0eXBlIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBAdHlwZSB7J3NsaWRlJyB8ICdjcm9zc2ZhZGUnfVxuICAgKiBAZGVmYXVsdCAnc2xpZGUnXG4gICAqL1xuICBASW5wdXQoKSB0cmFuc2l0aW9uOiAnc2xpZGUnIHwgJ2Nyb3NzZmFkZScgPSAnc2xpZGUnO1xuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGNhcm91c2VsIHNob3VsZCBjeWNsZSBjb250aW51b3VzbHkgb3IgaGF2ZSBoYXJkIHN0b3BzLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIEBJbnB1dCgpIHdyYXAgPSB0cnVlO1xuICAvKipcbiAgICogRXZlbnQgZW1pdHRlZCBvbiBjYXJvdXNlbCBpdGVtIGNoYW5nZS4gW2RvY3NdXG4gICAqIEB0eXBlIG51bWJlclxuICAgKi9cbiAgQE91dHB1dCgpIGl0ZW1DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgZ2V0IGhvc3RDbGFzc2VzKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcm91c2VsOiB0cnVlLFxuICAgICAgc2xpZGU6IHRydWUsXG4gICAgICAnY2Fyb3VzZWwtZGFyayc6ICEhdGhpcy5kYXJrLFxuICAgICAgJ2Nhcm91c2VsLWZhZGUnOiB0aGlzLnRyYW5zaXRpb24gPT09ICdjcm9zc2ZhZGUnXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY2Fyb3VzZWxJbmRleFN1YnNjcmlwdGlvbj86IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSB0aW1lcklkITogYW55O1xuICBwcml2YXRlIGludGVyc2VjdGluZ1N1YnNjcmlwdGlvbj86IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBhY3RpdmVJdGVtSW50ZXJ2YWwgPSAwO1xuICBwcml2YXRlIHN3aXBlU3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ2Fyb3VzZWxDb25maWcpIHByaXZhdGUgY29uZmlnOiBDYXJvdXNlbENvbmZpZyxcbiAgICBwcml2YXRlIGhvc3RFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgY2Fyb3VzZWxTZXJ2aWNlOiBDYXJvdXNlbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjYXJvdXNlbFN0YXRlOiBDYXJvdXNlbFN0YXRlLFxuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uU2VydmljZTogSW50ZXJzZWN0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIGxpc3RlbmVyc1NlcnZpY2U6IExpc3RlbmVyc1NlcnZpY2VcbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jYXJvdXNlbFN0YXRlU3Vic2NyaWJlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jYXJvdXNlbFN0YXRlU3Vic2NyaWJlKGZhbHNlKTtcbiAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoZmFsc2UpO1xuICAgIHRoaXMuc3dpcGVTdWJzY3JpYmUoZmFsc2UpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS5jcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoKTtcbiAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogdGhpcy5hY3RpdmVJbmRleCwgYW5pbWF0ZTogdGhpcy5hbmltYXRlIH07XG4gICAgdGhpcy5zZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN3aXBlU3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcml2YXRlIHNldExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWc6IElMaXN0ZW5lcnNDb25maWcgPSB7XG4gICAgICBob3N0RWxlbWVudDogdGhpcy5ob3N0RWxlbWVudCxcbiAgICAgIHRyaWdnZXI6IHRoaXMucGF1c2UgfHwgW10sXG4gICAgICBjYWxsYmFja09mZjogKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFRpbWVyKCk7XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tPbjogKCkgPT4ge1xuICAgICAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzU2VydmljZS5zZXRMaXN0ZW5lcnMoY29uZmlnKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnNTZXJ2aWNlLmNsZWFyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgc2V0VGltZXIoKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmFjdGl2ZUl0ZW1JbnRlcnZhbCB8fCAwO1xuICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmNhcm91c2VsU3RhdGUuZGlyZWN0aW9uKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5jYXJvdXNlbFN0YXRlLnN0YXRlID0geyBhY3RpdmVJdGVtSW5kZXg6IG5leHRJbmRleCB9O1xuICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0VGltZXIoKTogdm9pZCB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gIH1cblxuICBwcml2YXRlIGNhcm91c2VsU3RhdGVTdWJzY3JpYmUoc3Vic2NyaWJlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMuY2Fyb3VzZWxJbmRleFN1YnNjcmlwdGlvbiA9IHRoaXMuY2Fyb3VzZWxTZXJ2aWNlLmNhcm91c2VsSW5kZXgkLnN1YnNjcmliZSgobmV4dEl0ZW0pID0+IHtcbiAgICAgICAgaWYgKCdhY3RpdmUnIGluIG5leHRJdGVtKSB7XG4gICAgICAgICAgdGhpcy5pdGVtQ2hhbmdlLmVtaXQobmV4dEl0ZW0uYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1JbnRlcnZhbCA9IHR5cGVvZiBuZXh0SXRlbS5pbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgbmV4dEl0ZW0uaW50ZXJ2YWwgPiAtMSA/IG5leHRJdGVtLmludGVydmFsIDogdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgY29uc3QgaXNMYXN0SXRlbSA9ICgobmV4dEl0ZW0uYWN0aXZlID09PSBuZXh0SXRlbS5sYXN0SXRlbUluZGV4KSAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gJ25leHQnKSB8fCAoKG5leHRJdGVtLmFjdGl2ZSA9PT0gMCkgJiYgdGhpcy5kaXJlY3Rpb24gPT09ICdwcmV2Jyk7XG4gICAgICAgICF0aGlzLndyYXAgJiYgaXNMYXN0SXRlbSA/IHRoaXMucmVzZXRUaW1lcigpIDogdGhpcy5zZXRUaW1lcigpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2Fyb3VzZWxJbmRleFN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoc3Vic2NyaWJlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMuaW50ZXJzZWN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5pbnRlcnNlY3Rpb25TZXJ2aWNlLmludGVyc2VjdGluZyQuc3Vic2NyaWJlKGlzSW50ZXJzZWN0aW5nID0+IHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIGlzSW50ZXJzZWN0aW5nID8gdGhpcy5zZXRUaW1lcigpIDogdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnRlcnNlY3RpbmdTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzd2lwZVN1YnNjcmliZShzdWJzY3JpYmU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudG91Y2ggJiYgc3Vic2NyaWJlKSB7XG4gICAgICBjb25zdCBjYXJvdXNlbEVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zdCB0b3VjaFN0YXJ0JCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaHN0YXJ0Jyk7XG4gICAgICBjb25zdCB0b3VjaEVuZCQgPSBmcm9tRXZlbnQ8VG91Y2hFdmVudD4oY2Fyb3VzZWxFbGVtZW50LCAndG91Y2hlbmQnKTtcbiAgICAgIGNvbnN0IHRvdWNoTW92ZSQgPSBmcm9tRXZlbnQ8VG91Y2hFdmVudD4oY2Fyb3VzZWxFbGVtZW50LCAndG91Y2htb3ZlJyk7XG4gICAgICB0aGlzLnN3aXBlU3Vic2NyaXB0aW9uID0gdG91Y2hTdGFydCQucGlwZSh6aXBXaXRoKHRvdWNoRW5kJC5waXBlKHdpdGhMYXRlc3RGcm9tKHRvdWNoTW92ZSQpKSkpXG4gICAgICAgIC5zdWJzY3JpYmUoKFt0b3VjaHN0YXJ0LCBbdG91Y2hlbmQsIHRvdWNobW92ZV1dKSA9PiB7XG4gICAgICAgICAgdG91Y2hzdGFydC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB0b3VjaG1vdmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2VYID0gdG91Y2hzdGFydC50b3VjaGVzWzBdLmNsaWVudFggLSB0b3VjaG1vdmUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpID4gMC4zICogY2Fyb3VzZWxFbGVtZW50LmNsaWVudFdpZHRoICYmIHRvdWNoc3RhcnQudGltZVN0YW1wIDw9IHRvdWNobW92ZS50aW1lU3RhbXApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuY2Fyb3VzZWxTdGF0ZS5kaXJlY3Rpb24oZGlzdGFuY2VYID4gMCA/ICduZXh0JyA6ICdwcmV2Jyk7XG4gICAgICAgICAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogbmV4dEluZGV4IH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2lwZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==